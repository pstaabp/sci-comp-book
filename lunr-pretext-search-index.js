var ptx_lunr_search_style = "textbook";
var ptx_lunr_docs = [
{
  "id": "frontmatter-2",
  "level": "1",
  "url": "frontmatter-2.html",
  "type": "Colophon",
  "number": "",
  "title": "Colophon",
  "body": "  My Website   copyright  "
},
{
  "id": "ch-intro",
  "level": "1",
  "url": "ch-intro.html",
  "type": "Chapter",
  "number": "1",
  "title": "Introduction to Scientific Computing",
  "body": " Introduction to Scientific Computing   So you picked up (or probably actually clicked on) this text and maybe you wonder what Scientific Computing actually is. This will give a brief overview of the field and try to explain with some actual examples.  In short, scientific computing is a field of study that solves problems from the sciences and mathematics that are generally too difficulty to solve using standard techniques and need to resort to writing some computer code to get an answer.    Examples of Scientific Computing  The classic example of scientific computing is that of weather prediction. Atmospheric scientists and meteorologists use weather models (mathematical equations) that are run on fairly powerful computers. The results are generally a large amount of data (temperature, pressure, humidity, etc.) that often is plotted for various regions of the U.S. or other countries. The resulting data gives the standard forecasts that many of us look at on smart phone apps or on TV or other places.  Data analysis is also ubiquitous and one can think about this falling in the realm of scientific computing. Although this varies, an autonomous vehicle can generate 25 Gb of data per day. see this link . Although there is plenty of scientific computing without the data generation in self-driving cars, this is an example of needing to handle and analyze large amount of data quite quickly.  Recently, disease modeling came into focus with the COVID-19 pandemic. Plenty of research posted updates on predicted cases and deaths in the U.S. and throughout the world. Most of these model involve using existing data to fit mathematical functions and then use the resulting functions to predict the future. In addition, due to the diversity of conditions in different regions of the country and world, many localized models are developed at once with some predicted interaction as people travel from region to region.    Modeling  In nearly every example of scientific computing, a mathematical model is used. In short, a model is an equation, set of equations or some algorithm that is assumed as a mathematical understanding of the underlying problem. Mathematical models range vastly from field to field and generally the details are only taught in the individual fields, so we're not covering too much about models in this course, but here's a few examples.     In weather prediction, if the underlying physics is assumed, there is a large set of partial differential equations called the Navier-Stokes equations. Some approximation of these is used often with some statistical modeling for weather models.    In the autonomous car example above, modeling of the car dynamics often consists of the physics of moving objects which link position, velocity, acceleration and force. There is also a lot of artificial intelligence (AI) for object detection.    In the contagious disease models, there is usually some please of differential equations (the SIR model is a simple version) and some probability modeling. We will discuss both of these in this text.       Computing  The computing side of Scientific Computing is generally very important as well. As mentioned above, most of the problems studied get much too large or complicated to solve analytically (generally as a mathematical problem) and some sort of approximation is needed.  In many cases, there are existing algorithms that are developed to solve some underlying mathematical problem and the main focus is on setting up the problem is the right way. For example, if there is a differential equation to solve, a package can be loaded to use a particular differential equation solver and then the results need to be analyzed.  But in general, those that succeed in Scientific Computation are good at the coding\/computation side of things. It takes such skills to manage problems common in this fields.  I want to emphasize that Scientific computation, however, is not just computer programming. It takes a blend of skills to succeed at this. One needs a fairly deep knowledge of the field they are working in to understand how solving the problem using some algorithm is generating the correct answer.    Ideas needed to do Effective Scientific Computing  Scientific Computing is generally used to solve problems in Mathematics and various Science fields. There are a number of important things that you need to know to solve problems effectively.      Find\/develop code that runs quickly. Everyone wants the answer as soon as possible. However, if you write some code that doesn't take long to develop and returns the correct answer in a few seconds, it probably doesn't matter how efficient the algorithm is. However, if it takes a few hours to run, you probably want to investigate your solution algorithm.     Find\/develop code that uses an appropriate amount of memory. Another important aspect is that of memory consumption. It's not hard to find datasets these days that are 1TB or more in size, however few desktop\/laptop machines have more than 16 or 32Gb of RAM, so you can't load the entire file into memory. Such a dataset would need to be processed in chunks.     Make sure you have known solutions\/unit tests How do you know that your solution is correct? It is important to have relatively simple cases that you can test your code on before solving more complex things.       Examples of Scientific Computing     Consider a list of 5 cities that you need to visit and return to where you started. If you know the distances between each pair of cities, what is the most efficient path (in terms of distance or time) that gets you to each city and return.    Poker is a card game in which certain sets of cards (hands) beat other hands. Determine the probability (or chance) of getting any particular hand in Poker.    Given a dataset of Major League Baseball scores from 2000-2017, find the game with the largest score, most innings played, biggest winning margin, etc.     We will look at these an other problems in this course.    Writing Code for Scientific Computing  Look back at the list of requirements for Scientific Computing projects. A general rule of thumb is to use a computing language that you know will work well for those tasks. Typically, most students have learned one or two languages and aren't quite sure which to use. In most cases it doesn't matter what to use, but for complex problems it will matter.  One of the best languages for scientific computing has been Matlab over the past 3 or 4 decades. It is used extensively in engineering firms throughout the world (and the headquarters is in nearby Natick, MA). We won't be using Matlab here though. One of the nice things about taking a class is exploring new languages. Here we will use Julia , which is a very new language that a lot of people in scientific computing are excited about. We will give examples using Julia, but the ideas here should be applicable to other languages. Julia was designed as a scientific computing language, but in short is a modern language. There are number of aspects that makes Julia a good language for this. Julia is     a scripting language with dynamic types  This means you can get started right away--there's no need to learn about compilation--and you can prototype things quickly.    a language with just-in-time compilation  Most of the time scripting languages are slow, however with modern under-the-hood tools, languages can be compiled on the fly to create very fast runtimes. There is a webpage on benchmarks comparing Julia to other standard languages.    open source  Although often open-source implies free but not high-quality, the free part holds, but more important is that anyone can contributed to the code. The Julia community is committed to creating a high-quality piece of software and many discussion revolve around writing code that will improve the speed or other aspects. This is very opaque and unclear if it happens with commercial software.    easy to use  The syntax of Julia is similar to that of python, a very popular language, and is often intuitive.    a joy to use  Additionally, the structure of the language makes it easy to start with, but as projects get more complex, it can be written in a simple way.       Let's get started  You can start by just reading the book, but to get the most out of this, make sure that you have a computer with access to Julia. If you already have this, great. If not, see which will show you a few way to get the code up and running.  Solving Scientific Computing problems ultimately boils down to manipulating data and at the most basic is that of strings and numbers. We begin with understanding these data types and how to store values in them. We also show some of Julia syntax, which looks like other languages (like python). Hopefully you have some basic knowledge of computing, but no assumption of any particular language is necessary.   "
},
{
  "id": "ch-variables",
  "level": "1",
  "url": "ch-variables.html",
  "type": "Chapter",
  "number": "2",
  "title": "Storing number and strings and using Julia syntax",
  "body": " Storing number and strings and using Julia syntax     Basic syntax of string and numbers.    Assigning values (strings and numbers) to variables.    Simple string operations like concatenation and string length.    Expressions and operator precedence.    Comments in code.      Although Scientific Computing problems generally involved developing models, at the lowest level, one is manipulating data generally strings and numbers. We begin with understanding these data types and how to store values in them.  We also show some of Julia syntax, which looks like other languages (like python). If you have some basic knowledge of computing, it is helpful, but no particular language is needed. We will see many standard programming structures in this book with a emphasis on those relevant to solving scientific computing problems.    Numbers  Not surprisingly, the most important data type in scientific computing--at least at the most atomic level is numbers. Numbers in computation mimic those in mathematics with some important differences. Julia, like most computing languages, have two main number types: integers and floating points. Julia's integers and much like mathematical integers in that they store numbers like . Floating-point numbers generally are approximations to real or decimal numbers, such as 3.14159 or 1.23e+08 and more details will be covered in .  Julia also has a rational data type for numbers commonly though of as fractions like or . Recall that typically represents , the base imaginary number. Complex numbers like are also native to Julia, however instead of , Julia uses im . We will explore both rational and complex numbers in greater depth in and have an entire chapter on complex numbers in .    Assignment Statement and Variables   Anything can be stored as a variable using the single equal sign like x=6 . This is an assignment operator, which creates the number 6 and stores it under the name x .  And now that the variable x is stored, we can use it in calculations. For example    x+3    returns 9 .  Variables in Julia, much like other languages are primarily sequences of alphanumeric characters as well as an underscore _ . Primarily, a variable needs to start with a alphabetic character or _ and after the first character can contain numbers. A variable cannot have a space in the name.  Julia also allows many unicode symbols in variable names, however not everything. For example, all of the greek letters are allowed, so α=45 is valid.  To get a greek letter in Jupyter or the REPL, type \\alpha , hit the TAB key and it will be turned into an α .    Storing Variable in a Virtual Whiteboard  The details of storing variables in computer hardware isn't necessary, however, thinking of storing as writing variables and values on a whiteboard is a helpful paradigm. Imagine a whiteboard with a column of variable names and a column of values. For example, if we have    x=6  y=-1  z=8.5    then you can think of the whiteboard looking like:   Whiteboard analogy of the storage of variables    Variable  Value    x  6    y  -1    z  8.5     If we evaluate the expression x+3 , then the value of x is looked up and the value 6 is substituted into the expression or 6+3 .  If we change one of the values, like y=y+5 , this means that to the right of the equals sign is evaluated first. y is looked up as -1 , then 5 is added to it to get 4, then the 4 is placed into the whiteboard, which will now look like:   Updated whiteboard of variables    Variable  Value    x  6    y  4    z  8.5     If you are thinking of how a piece of code works, often you will need to get to the point of writing down a version of the whiteboard.     Strings   In many Scientific Computing fields, such as Data Science, strings arise often and it is important to understand some of the basics of them. In Julia, a string is a sequence of characters surrounded by \"\" (double quotes). For example:    str = \"This is a string\"    and if you enter typeof(str) then you should see String . The individual parts of the string are called characters, which have type Char and are by default Unicode Characters (which will we see are super helpful). We will see other data types in , but note that types in Julia are capitalized. A few other helpful things about strings are     The length of a string is found using the length command. length(str) returns 16     To access the first element of the string, type first(str) , the last is found by last(str) and the 3rd character for example is str[3] . In Julia, string indexing starts at 1.    To turn other data types into string, use string . For example string(3.0) returns the string \"3.0\" .       String Operations  We saw how to access elements of a string. Another helpful operation is that of concatenation, or the merging of two strings. If    str1 = \"The tide is high \"  str2 = \"and I'm having fun.\"    we can concatenate in multiple ways. First, the * operator symbol with strings as both operands or the string() function. Both    str1 * str2  string(str1,str2)    returns The tide is high and I'm having fun. I find that the * is an odd choice for string concatenation. Many languages including java and ecmascript (javascript) use + instead for string concatenation. Another way of performing concatenation is shown below using string interpolation.  Another cute operation for strings is the caret ^ operation. This could be helpful and a (not so helpful) example is    \"Hip, hip, hooray! \"^3    returns    Hip, hip, hooray! Hip, hip, hooray! Hip, hip, hooray!      String Interpolation  Mixing strings and other variables together is often needed. If you have a variable x and would like to insert it at the end of \"The value of x is \"   we can use concatenation as above to do this, but instead we will use string interpolation by putting a $ in front of a variable.    result = \"The value of x is $x\"    and the result will be \"The value of x is 6\" .  There is actually one other way to do string concatenation if you use this method. If we have the variables stored in str1 and str2 , then \"$str1$str2\" also will concatenate the strings.    Other String Functions  There are many other string functions, which are generally used for manipulating a string. The string chapter of the Julia documentation is a good place to look.  To effectively use strings, a knowledge of regular expressions are needed. Regular expressions are ways to parse a string and extract key information. goes through details on how to develop and use regular expressions. We also use these to parse points written in string form and in we develop the parsing of a polynomial written as a string.     Expressions  An expression is a combination of variables, data elements (like numbers and strings), operations (like + or *) and functions (like length ). We've seen a number of expressions throughout this chapter so far like    x = 6  x+3  str1 * str2  length(str)    In short, writing things in Julia will consist of writing expressions (and slightly more complicated structures).    Operator Precedence  When we type out an expression like 11+2*(4+3)^3 , it is important to understand the order in which operators are performed. For mathematics, the PEMDAS mnemonic is helpful to remember in that the order is:      Parentheses : The expression inside the ( ) are done first. For the example above, the 4+3 is the first operation done.     Exponentials : The ^ is done next. Raise the 7 from above to the power of 3.     Multiplication and Division : In this example, the 2*(343) is done next     Addition and Subtraction : Lastly add 11 to the result.     In any computing language, there are other operators as well and there is order to that precedence, so we will see that there are other things to think about. For example, the assignment operator, = has the lowest precedence. That is when assigning something to a variable, all calculations are done on the right side of the = before the assignment.  Details on all this can be found on the Julia documentation page on operator precedence .    Comments  A comment in computer code is sequences of characters which are ignored. The purpose of a comment is to alert a human on what is going on. You may have been told to write comments so that someone else who reads your code understands what you are doing. However, I have found that the person mostly like to read your code is you at a later date. You should add comments for yourself.  In Julia, a comment is anything to the right of a # , pound sign or hash tag. For example:   # This calculates the area of a circle r = 3 pi*r^2 # this is the actual formula for the area   Both lines 1 and 3 have comments. On line 1, the entire line is ignore since the line starts with # . On line 3, everything after the 2 (the power) is ignored. Also, notice that there are two hash tags on line 1 and 1 on line 3. This is simply different style. Since anything after a single # is a comment, everything after the first one is ignored.   "
},
{
  "id": "ch-variables-2",
  "level": "2",
  "url": "ch-variables.html#ch-variables-2",
  "type": "Objectives",
  "number": "2",
  "title": "",
  "body": "   Basic syntax of string and numbers.    Assigning values (strings and numbers) to variables.    Simple string operations like concatenation and string length.    Expressions and operator precedence.    Comments in code.    "
},
{
  "id": "ch-variables-5-3-5",
  "level": "2",
  "url": "ch-variables.html#ch-variables-5-3-5",
  "type": "Table",
  "number": "2.1",
  "title": "Whiteboard analogy of the storage of variables",
  "body": " Whiteboard analogy of the storage of variables    Variable  Value    x  6    y  -1    z  8.5    "
},
{
  "id": "ch-variables-5-3-8",
  "level": "2",
  "url": "ch-variables.html#ch-variables-5-3-8",
  "type": "Table",
  "number": "2.2",
  "title": "Updated whiteboard of variables",
  "body": " Updated whiteboard of variables    Variable  Value    x  6    y  4    z  8.5    "
},
{
  "id": "ch-data-types",
  "level": "1",
  "url": "ch-data-types.html",
  "type": "Chapter",
  "number": "3",
  "title": "Introduction to Data Types",
  "body": " Introduction to Data Types     Details about integers including the limitations of integers in computers.    The subtypes of integers especially signed and unsigned integers as well as big versions.    Details of floating-point numbers on computers and how they different from real numbers and decimal numbers.    Introduction to BigFloats, extended versions of floating point numbers.    Introduction to complex and rational numbers.    Definitions and differences between abstract and concrete datatypes and their hierarchy.    Converting between different types of numbers and parsing strings as numbers.    Definition and uses of a tuple.      In , we saw a little bit about number and string data types. This chapter goes into greater detail about numbers and other datatypes. It is important to understand how integer and floating point number are stored as their binary representation. We will cover this as well.    Integers   Recall that mathematically, an integer is a counting number ( ) along with 0 and the negative counting numbers ( ). Mathematically thinking, there is no largest (or smallest) integer, however, in reality if we are storing a number on a computer (which is a finite device), there must be a limit on the smallest and largest integers to be stored. Practically speaking, we will limit an integer to some number of bits and the standard sizes are 8, 16, 32, 64 and 128.    Unsigned Integers  First, we will examine unsigned integers and typically these are thought of as the nonnegative integers (0,1,2,3, ...). For example, 8-bit unsigned integers have a total of nonnegative numbers and since the smallest is 0, the largest is 255.  In Julia, the datatypes for unsigned integers are UInt8, UInt16, UInt32, UInt64 and UInt128 . We can get the smallest and largest value for these with the typemin and typemax functions. Int(typemin(UInt8)) and Int(typemax(UInt8)) return 0 and 255 respectively. Note: the functions typemin and typemax on unsigned integers return values in hexadecimal. The function Int converts to a decimal integer.   covers many of the details of representation integers in binary and performing basic operations. We will cover the a superficial level of integer representation and operations here in this chapter, but for those with desire for more depth see .  In Julia, we can use the bitstring function to give the binary representation of integers and floating points. For example  bitstring(UInt8(18))    returns 00010010 . Notice that bitstring(UInt8(255)) returns 11111111 .  Similarly, the unsigned integers with more bits work the same with largest range of integers. For example bitstring(UInt64(100000)) returns    \"0000000000000000000000000000000000000000000000011000011010100000\"    which is a string of length 64.    Signed Integers  In Julia, the signed integers are Int8, Int16, Int32, Int64 and Int128 . Also, there is a integer type Int which defaults to the sized integer of the typical integer size on your machine. This is generally Int64 .  Let's look in detail about 8-bit signed integers. The largest and smallest values that can be stored with Int8 can be found with typemin(Int8) and typemax(Int8) , which returns -128 and 127 respectively. Basically the number between 0 and 127 are identical between Int8 and UInt8 .    Overflow and Underflow of integer operations  Again, unlike mathematical integers, any computer-based integer has a maximum and minimum values. In short, if an operation results in a number above the maximum, then there is an overflow error and less than the minimum there is an underflow error.  Here's a simple example with 8-bit integers. Let x=Int8(95) and y=Int8(70) . The sum of 95 and 70 is 165 and above the maximum value for Int8 . However, entering x+y results in -91 , not either the expected result or an error.  What just happened? If you want to know why the value of -91 arose, dig into the details in , but the reason why there was no overflow error is that Julia does not automatically check for such errors, due to the fact that there is overhead in checking, which will slow down operations.  If you want to check, there are a suite of operations that will check. For example Base.checked_add(x,y) will return  ERROR: OverflowError: 95 + 70 overflowed for type Int8    Go to Julia's documentation on checked_add which starts a list of functions that will check for over and underflow. If there is any chance of overflow\/underflow errors, then the results may be wrong. Keep this in mind as in we will write tests for code.     Floating Point Numbers  Many fields in scientific computing rely on using decimals and the standard way to store these in a computer is with floating point numbers . Details on floating-point numbers are in . Julia has 16-,32- and 64-bit floating point numbers called Float16, Float32 and Float64 and the default on most systems is the Float64 .  There are two limitations to any floating-point number. First, the number of digits stored in the number and secondly, the maximum and minimum values. Each built-in type splits the number of bits into storing both and there is a balance between these. A rule of thumb is that      Float16 stores 4 decimal digits and the max is about 65,000.     Float32 stores 8 decimal digits and the max is about .     Float64 stores 16 decimal digits and the max is about      If you tried to find the largest values of these three types, you will notice that you get Inf16, Inf32, Inf , which are constants representing infinity in the three datatypes. Instead try using the function floatmax on these three types and you will get the largest values that you can represent in these types.  We can using the bitstring function in Julia to find the binary representation. Notice that  bitstring(Float16(8.625))  returns \"0100100001010000\" , which is a binary string of length 16. Again, details are in but, in short, a floating-point number is stored in scientific notation with the abscissa, exponent and the sign all combined together.  Unlike integers, most numbers cannot be stored exactly with a floating-point number. For example, divides 1 by 3 and results in the floating-point number closest to the fraction . In Julia this is print(1\/3) and also note that bitstring(1\/3) results in  \"0011111111010101010101010101010101010101010101010101010101010101\"    Notice that there are non-zero bits throughout the number in this case that didn't occur with 8.625. This is because as a fraction 8.625 has a denominator of 8, which is a power of 2. If a fraction can be written with such a denominator, the number in binary has 0s that pad the right end of the number.  What does this matter? Well, consider the following:  1\/9+1\/9+1\/9+1\/9+1\/9+1\/9+1\/9+1\/9+1\/9  which returns 1.0000000000000002 , which is not 1. This occurred because the closest floating point to the fraction 1\/9 was just slightly above 1\/9 and adding up 9 of those numbers results in the extra amount. This is an example of the limitations of floating-point numbers and 1) either we deal with it or 2) use a different data type (in this case either a BigFloat or Rational would be better).  Unless you know you have some reason to choose otherwise, choose Float64 for most floating-point numbers. There are still underflow and overflow errors associated with it, but as we will see in , generally round-off error associated with floating-point number is more detrimental to calculations.    Extending integers, the BigInt type  In , we will explore prime numbers and it is common for them to exceed the maximum allowable Int64 or even Int128 . If this is needed, there is a type called BigInt with no maximum or minimum. Here's the number one googol   big(10)^100  which returns  10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000    This integer is 1 followed by 100 zeros. Note: the command big creates a BigInt and generally normal operations with integers result in BigInt s as well.  It's very important to understand how big(10)^100 works. First a number of type BigInt is made with a value of 10. Then that is raised to the 100th power. As noted earlier, a BigInt doesn't have a upper or lower limit on the number. It can grow as needed.  If instead, we enter big(10^100) , the result is 0 , a surprising result, however note that because of order of operations, first 10^100 is calculated in standard Int64 and then turned into a BigInt . Again, for details on what happens here, look at , in short this continually multiplies the number ten, 100 times which results in overflow and as such results in 0.  It is recommended only to use a BigInt if needed. Operations with them are significantly slower than Int64 or even Int128 . Under few cases do you need to do this, however, we will point out in with prime numbers when we might need to use them.    Extending Floating Point Numbers with BigFloat   As we discussed above, a floating point number has two limitations 1) the number of digits stored and 2) the maximum exponent used. If we run into numbers that exceed either of these, we can turn to BigFloat . For example, what if you want to calculate to 100 or more digits. See for details on how to do this.  To get a floating point number of type BigFloat , wrap the big function around a float. For example x=big(0.25) returns 0.25 and we can verify it's type with typeof(x) which returns BigFloat .  Let's revisit an example from earlier and sum 1\/9 nine times. If we try to turn this into a BigFloat with a=big(1\/9) , then the result is  0.111111111111111104943205418749130330979824066162109375    This seems to have an accuracy of only 17 digits, which is typical for a 64-bit floating point, so it doesn't appear to have improved anything. This, like above, is a case of being careful in constructing a BigFloat . What happens with big(1\/9) ? Put on order-of-operations hat and let's take a look. The 1\/9 is done first and since both 1 and 9 are regular integers ( Int64 ), the result is a Float64 . Then the big function turns the Float64 into a BigFloat , but not we the accuracy expected.  Instead, if we define a=big(1)\/big(9) , then we get  0.1111111111111111111111111111111111111111111111111111111111111111111111111111109    which looks more like an expected result. To determine the number of digits of accuracy, you can count (painfully) or try length(string(a)) which will return 81 , which is about 5 times the accuracy of Float64 . Technically if you type precision(a) and this returns 256, which is the number of bits and it has 4 times the binary precision of Float64 but about 5 times the decimal precision.  Note: looking again at order of operations, the command length(string(a)) first takes the number a and returns it as a String . Then working inside to outside, find the length of the string.  As noted at the beginning of this section, though, if we want to compute to 1 million decimal digits Don't peek yet, but, really, we will do this in . , what we've seen so far only has about 80 digits of accuracy. However, the BigFloat type is quite flexible. The above example used it in its default precision. We can change this with the setprecision function. For example:  setprecision(2^10)    returns 1024, showing that now BigFloat s will be stored in this many bits. Such a number will using 16 times the number of binary digits as a Float64 . Entering a2=big(1)\/big(9) returns  0.111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111    a number that, at a glance, looks to store about 4 times the number of digits as the default BigFloat size. To determine the total number of decimal digits, if we enter length(string(big(a2)))   returns 311 as the number of decimal digits. This is about 20 times the precision of Float64 .    Limitations of BigFloats  Although a BigFloat stores more digits and allows a wider range of possible numbers, it still has a limitation. Once you create a BigFloat , it uses the given precision from setprecision and cannot be changed. So typically, thought needs to be put in before using setprecision on what the desired level of precision that is needed.  Additionally, operations with BigFloat s are significantly slower that the Float64 type and unless you need the extra precision, stay with the base type.     Rational numbers   A rational number is the ratio of integers and more commonly called a fraction. Julia (unlike many other general computing languages) has rational numbers built-in. To put in a ratio, enter a \/\/ to separate the numerator and denominator. For example:  2\/\/3  4\/\/7  178\/\/11  -1\/\/2    are examples of rational numbers. One advantage that they have is that the numerator and denominator are stored as integers (64-bit by default) and are not subject to round-off errors that floating points are. The standard operations between rationals results in a rational and as we will see in this course, there are advantages to using rationals instead of floating points.    Exercise   Perform the following operations involving rationals in Julia:                     The Rational Type  If you enter typeof(1\/\/2) , note that Julia returns Rational{Int64} and this is called a Parametric Composite Type , which will be talked about later. In this particular case, this is a rational type, but inside it (the numerator and denominator), they are type Int64 . For example, to make a different type of rational you need to declare a different integer type inside, enter  Int16(1)\/\/Int16(2)    and if you check the type of this, you will see it is of type Rational{Int16} .  Since operations with rational do not round off, like with floating-point numbers, you may want to consider using them. For example, if we  1\/\/9+1\/\/9+1\/\/9+1\/\/9+1\/\/9+1\/\/9+1\/\/9+1\/\/9+1\/\/9    results in 1\/\/1 , which is actually the number 1 (written as a rational number).  Build the rational with BigInts within it. Check that in fact it is stored as you expect.    Other Operations with Rationals  As long as you stay in the basic operations, , the result will be a rational. However, many other operations are not. For example sin(1\/\/2) will return a floating-point number. (2\/\/3)^3 will return a rational, since this is ultimately multiplication, but (2\/\/3)^(1\/\/2) will return a floating-point since raising a number to the is the same as square root.    Limitations of Rational Numbers  It seems like any time that you have fractions that you should simply use rational data types. For example, let's say we want to add the following:  1\/\/1 + 1\/\/2 + 1\/\/3 + 1\/\/4 + 1\/\/5 + 1\/\/6 + 1\/\/7 + 1\/\/8 + 1\/\/9 + 1\/\/10  which we can write with the sum function that we will see in as  sum(i->1\/\/i,1:10)  and the result is 7381\/\/2520 . This seems great, but if we sum the first 50 reciprocals with sum(i->1\/\/i,1:50) , then the result is an overflow error. Note that rationals check for overflow and underflow, which is different than integers and floats which do not check.     Complex Numbers  Recall that the imaginary number is defined as . A complex number is a number of the form for and in general real numbers. In Julia, there is a built-in constant im , which can be used to create complex numbers. For example z=1+2im has type Complex{Int64} , which is a composite type with the values of the numbers and are Int64 .  Complex numbers play a huge role in many aspects of scientific computing and in some cases, formulating a problem using complex numbers can make calculations faster and easier to program. This includes the very important algorithm, fast-Fourier transforms or better known as FFTs. This and other examples are explained in .    Abstract and Concrete Number Types   The numerical data types we have seen in this chapter are examples of concrete data types in that we can create data (usually numbers) with those types. These include the integer types Int8, Int16, Int32, Int64, Int128, BigInt and floating-point versions Float16, Float32, Float64, BigFloat . The rational and complex types are composite, however the internal part is a concrete type.  Julia is a bit different than other languages in that there are also abstract data types that 1) you can't make data in the type and 2) are collections of other types.    Abstract Number types  For example, Integer is the abstract type (also called a supertype) of all integer types. The other abstract number types are:      Signed : supertype of all signed integers like Int32, BigInt .     Unsigned : supertype of all unsigned integers like UInt32,UInt128 .     Integer : supertype of all signed and unsigned integers.     AbstractFloat : supertype of all floating-point numbers.     AbstractIrrational : supertype of irrational numbers.     Real : supertype of all floating-point, rational, irrational and integer numbers.     Number : supertype of all numbers.     See a bare-bones description of all of Julia's standard number types .    Concrete Number Types  The numbers shown above are concrete number types like:      Float16 , Float32 , Float64 , BigFloat which are all subtypes of AbstractFloat      UInt8 , UInt16 , UInt32 , UInt64 , UInt128 : which are all subtypes of Unsigned      Int8 , Int16 , Int32 , Int64 , Int128 , BigInt : which are all subtypes of Signed      Rational types are subtypes of Real      Complex types of subtypes of Number .     To test if something is a subtype of another use the <: operation. For example    UInt8 <: Integer    returns true , but  Float16 <: Signed    returns false .     Converting numbers    float(x) converts any type of number to a floating point, like   float(1\/\/3)   returns 0.3333333333333333   More generally is the convert method which has a template of convert(TYPE,value) which attempts to convert value to type TYPE . We can also convert the rational 1\/\/3 to a float with    convert(Float64,1\/\/3)    and we can use this to convert say a 64-bit floating point to a 16-bit floating point with:    convert(Float16,1\/3)    which returns Float16(0.3333) Similarly, we can parse strings to different number types. parse(TYPE,str) parses str of type String into a number of type TYPE .    parse(Int,\"1234\")    returns the integer 1234 and  parse(Float64,\"1234\")    returns the floating point 1234.0 .  If you have a number in another base, you can still parse it. For example, consider the binary number 10011,  parse(Int,\"10011\",base=2)  results in 19 .    Converting to Integers  If you have a floating point number or rational and you want to convert to an integer, typically use the ceil , floor , round functions. For example    ceil(Int,3.2)    returns the integer 4 , since ceiling rounds up to the next integer.     Tuples   Another type that allows one to combine two or more elements of data is called a tuple. For example, if we want two integers that are combined, we can make:  (1,2)    For example, this could be a way to store a geometric point in the plane. Determining the data type with typeof((1,2)) returns Tuple{Int64, Int64} , which is another example of a composite type. The type is a Tuple but there are Int64 types for the components of the tuple.  Tuples can consists of different types for different parts. For example, t = (5,7.8, \"Hello\") is a valid tuple and its type is Tuple{Int64, Float64, String} .  You can access the elements of the tuple using bracket notation. Using the value of t above, we can get the first element of t with t[1] . Note, this is similar to array notation, which we will see in . Note: the first element of things like tuples and array is 1, not 0.    Named Tuples  Sometimes it's easier to associated the individual elements of a tuple with a name instead of an index. We can generate a named tuple as    pt=(x=1,y=3.2,z=9)    which would be like a point in three dimensions. We can access the elements using dot notation, such as    pt.x    returns 1 .  Named tuples can be helpful to build complex datatypes, where there are multiple fields are associated with the same piece of data. Another example might be if you have data associated with a person, such as    p = (first_name = \"Homer\", last_name = \"Simpson\", age=45)    where there are a mix of strings and integers in the same tuple. This may be all that you need for an example like this, however, we will see more complex data types in , which creates a new data type or struct . Such a type will allow more flexibility. For example if we define a point using a tuple, it is difficult to do operations on the point.    Tuples are Immutable  However, if we try to change one of the elements of a tuple, then an error will occur.  p.age=46  results in  setfield!: immutable struct of type NamedTuple cannot be changed    This is because tuples are immutable, meaning once created, any part of the tuple cannot be changed.    "
},
{
  "id": "ch-data-types-2",
  "level": "2",
  "url": "ch-data-types.html#ch-data-types-2",
  "type": "Objectives",
  "number": "3",
  "title": "",
  "body": "   Details about integers including the limitations of integers in computers.    The subtypes of integers especially signed and unsigned integers as well as big versions.    Details of floating-point numbers on computers and how they different from real numbers and decimal numbers.    Introduction to BigFloats, extended versions of floating point numbers.    Introduction to complex and rational numbers.    Definitions and differences between abstract and concrete datatypes and their hierarchy.    Converting between different types of numbers and parsing strings as numbers.    Definition and uses of a tuple.    "
},
{
  "id": "sect-rational-numbers-3-2",
  "level": "2",
  "url": "ch-data-types.html#sect-rational-numbers-3-2",
  "type": "Check Your Understanding",
  "number": "3.1",
  "title": "",
  "body": " Perform the following operations involving rationals in Julia:                  "
},
{
  "id": "sect-rational-type-6",
  "level": "2",
  "url": "ch-data-types.html#sect-rational-type-6",
  "type": "Check Your Understanding",
  "number": "3.2",
  "title": "",
  "body": "Build the rational with BigInts within it. Check that in fact it is stored as you expect. "
},
{
  "id": "sect-abstract-type-2-1",
  "level": "2",
  "url": "ch-data-types.html#sect-abstract-type-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "concrete data types "
},
{
  "id": "sect-abstract-type-2-2",
  "level": "2",
  "url": "ch-data-types.html#sect-abstract-type-2-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "abstract data types "
},
{
  "id": "ch-intro-functions",
  "level": "1",
  "url": "ch-intro-functions.html",
  "type": "Chapter",
  "number": "4",
  "title": "Introduction to Functions",
  "body": " Introduction to Functions     The definition of a function.    How to write a function in full or shortcut form.    How to return a value or multiple values from a function.    The definition of the function arguments and how to specify a type.    How to write a function with arbitrary number of arguments.    The definition of Multiple Dispatch and how this helps us write functions.    Introduction to recursive functions.    Variable scope related to functions.      In any language, the function is one of the most important ideas and this chapter covers the introduction of functions with examples in Julia. There are four main purposes of functions in scientific computation.     A function in a computer language mimics that of a mathematical function, which are crucial in this field.    Functions simplify code. Wherever code is repeated either exactly or nearly exactly, functions are one way to reduce the amount of code written and makes code conceptually easier.    Functions abstract code. If you can create a piece of code that does a particular task, then this helps in the abstraction process.    Functions allow separation of code. If there is a large code and a section of it does a specific task, making it a function will separate code resulting in simplification.       Simple example  A simple example of a Julia function is  function sq(x)  x*x  end    which just returns the square of the argument, called x . The name of the function is sq and the x inside the parentheses is called the argument of the function. Both the function name and any argument must adhere to the rules of variables from .  An alternative way to write this is the following:  sq(x)=x*x    which is often used if a function is a single line of code. This also looks a lot like a mathematical function. To make it even more mathematical, we could also write this as  sq(x)=x^2    To call a function, it is much like that of any other language. If we type sq(3) , which returns 9 , the square of 3 and sq(-4) returns 16 . In the latter case, this assigns the argument x the value -4 and runs the code in the function.    Function Arguments  The function arguments are names associated with data passed into the function. In the function sq above, the number x is the only argument. We can have more arguments by separating by commas. The (quite unnecessary function) theSum will take two arguments and add the result:  theSum(x,y) = x+y    Typically, if a function can be written in one line, we will use this style of functions. For more complex functions, use the function keyword as a block of code.  Write a function theMean that finds the mean (average) of two arguments x and y .    Returning values from a function   The functions sq or theSum returned the value that is the last line of the function. If you want to return a value before the last line you can use the return command. The following will return true if the number is odd and false if the number is true:   function isOdd(n) if mod(n,2)==1 return true end false end   The mod function is the remainder of n divided by 2 and can also be written n % 2 . If the remainder is 1, then the number is odd. On line #3, return true the code stops here and exits the function and doesn't execute any of the other lines.  Note: the == tests for equality. This will be discussed in .  A better way to write this (but doesn't use the return statement) just evaluates if mod(n,2) is 1 or not:    isOdd(n) = mod(n,2) == 1    which will return true if mod(n,2) is actually 1 and false if it is anything else (but the only other possibility is 0). Again, since this is just one line, we'll use the shorthand notation.    Indentation in Functions  You should notice that the isOdd function written above as a block of 5 lines has different indentation. In Julia, the indentation doesn't matter This isn't true of all languages. Python, for example, relies significantly on indentation for blocks of code and therefore the end isn't needed to terminate a block. but it is standard to indent for clarity. Notice first that in all of the functions so far, the code has been indented I have a preference for 2 spaces, but 3 and 4 are common as well. two spaces and then the if block is indented again 2 spaces. One can use any number of spaces for indentation as long as it is consistent.     Specifying Argument Types  The isOdd function above should only work on integers, but if type isOdd(3.5) you get a result. (But does it give you want you want?). What if you enter isOdd(\"odd\") ? Try it.  Since odd numbers only make sense with positive integers, declaring the type of argument makes sense. Therefore, if instead, you specify a type in the following way:  isOdd(n::Integer) = mod(n,2)==1    where the double colon, :: tells the type of the argument n . Any type that is an Integer can go in here and note that we used the abstract data type Integer as seen in .  Also, make sure to restart the kernel and details on how to do this can be found in . After restarting the kernel make sure that you rerun the function isOdd above.  Once you have done this, entering isOdd(3.5) returns    MethodError: no method matching isOdd(::Float64)  The function `isOdd` exists, but no method is defined for this combination of argument types.    This just means that there is not function isOdd that takes a Float64 as an argument, which is what we want. A similar error should now occur for isOdd(\"odd\") .  Throughout the rest of this text, we will always specific an argument type. This is not only good style and practice, we will see that this results in faster code.   Rewrite the theMean function from above using types for the arguments. Since both floats and integers are real numbers, use the abstract Real type for this. Restart the kernel and test your function using both numbers (floats, integers or rationals) and non numbers (like a string).     theMean(x::Real, y::Real) = (x+y)\/2       Multiple Dispatch   Before starting this, make sure that you have completed the exercise above to write a 2-argument version of the mean and it is currently in the kernel (this means, just run it again, if in doubt.)  It would be nice to have a mean function that takes more than 2 numbers as well, so the following is a three-argument version of the mean function can be written    theMean(x::Real,y::Real,z::Real) = (x+y+z)\/3    Depending on the number of arguments, Julia will call the appropriate function. This is an example of Multiple Dispatch , in which either the number or type of arguments determine the actual function call.  If you look back at your document when you declared the functions, you should see that the second one entered said theMean (generic function with 2 methods) , which says that there are two functions called mean. Typing methods(theMean) results in:    # 3 methods for generic function theMean from Main:  theMean(x::Real, y::Real) in Main at \/Users\/XXXXX\/code\/sci-comp-book\/Julia-output\/intro-functions.ipynb:1  theMean(x, y) in Main at \/Users\/XXXXX\/code\/sci-comp-book\/Julia-output\/intro-functions.ipynb:1  theMean(x::Real, y::Real, z::Real) in Main at \/Users\/XXXXX\/code\/sci-comp-book\/Julia-output\/intro-functions.ipynb:1    Much of yours will be different depending on using the REPL or a notebook, however the important part is that you will see that there are 3 methods and the rest shows where they were defined.  Multiple dispatch also allows different types of arguments as well. Let's say we want to create a function theMean that take a single string as a argument like:    function theMean(str::String)  \"This should return the definition of $str\"  end    and entering methods(theMean) shows you that there are now 4 functions. Try typing    theMean(\"definition\")      Multiple Dispatch of built-in functions  Multiple dispatch allows Julia to be quite nice. For example, the + function allows code to be written with the plus symbol and execute different code. Type methods(+) and the top of the results should be similar to   # 197 methods for generic function + from Base: +(B::BitMatrix, J::LinearAlgebra.UniformScaling) in LinearAlgebra at \/Users\/XXXXX\/.Julia\/Juliaup\/Julia-1.11.0-beta2+0.aarch64.apple.darwin14\/share\/Julia\/stdlib\/v1.11\/LinearAlgebra\/src\/uniformscaling.jl:151 +(x::Bool, z::Complex{Bool}) in Base at complex.jl:308 +(x::Bool, y::Bool) in Base at bool.jl:166 +(x::Bool) in Base at bool.jl:163 +(x::Bool, z::Complex) in Base at complex.jl:315 +(x::Real, z::Complex{Bool}) in Base at complex.jl:322 +(x::Bool, y::T) where T>:AbstractFloat in Base at bool.jl:173 +(x::Dates.CompoundPeriod, y::Dates.CompoundPeriod) in Dates at \/Users\/XXXXX\/.Julia\/Juliaup\/Julia-1.11.0-beta2+0.aarch64.apple.darwin14\/share\/Julia\/stdlib\/v1.11\/Dates\/src\/periods.jl:335 +(x::Dates.CompoundPeriod, y::Dates.Period) in Dates at \/Users\/XXXXX\/.Julia\/Juliaup\/Julia-1.11.0-beta2+0.aarch64.apple.darwin14\/share\/Julia\/stdlib\/v1.11\/Dates\/src\/periods.jl:333 +(x::Dates.CompoundPeriod, y::Dates.TimeType) in Dates at \/Users\/XXXXX\/.Julia\/Juliaup\/Julia-1.11.0-beta2+0.aarch64.apple.darwin14\/share\/Julia\/stdlib\/v1.11\/Dates\/src\/periods.jl:363 +(dt::Dates.DateTime, y::Dates.Year) in Dates at \/Users\/XXXXX\/.Julia\/Juliaup\/Julia-1.11.0-beta2+0.aarch64.apple.darwin14\/share\/Julia\/stdlib\/v1.11\/Dates\/src\/arithmetic.jl:25 +(dt::Dates.DateTime, z::Dates.Month) in Dates at \/Users\/XXXXX\/.Julia\/Juliaup\/Julia-1.11.0-beta2+0.aarch64.apple.darwin14\/share\/Julia\/stdlib\/v1.11\/Dates\/src\/arithmetic.jl:49 +(x::Dates.DateTime, y::Dates.Quarter) in Dates at \/Users\/XXXXX\/.Julia\/Juliaup\/Julia-1.11.0-beta2+0.aarch64.apple.darwin14\/share\/Julia\/stdlib\/v1.11\/Dates\/src\/arithmetic.jl:77 +(x::Dates.DateTime, y::Dates.Period) in Dates at \/Users\/XXXXX\/.Julia\/Juliaup\/Julia-1.11.0-beta2+0.aarch64.apple.darwin14\/share\/Julia\/stdlib\/v1.11\/Dates\/src\/arithmetic.jl:83 +(z::Complex{Bool}, x::Bool) in Base at complex.jl:309 +(z::Complex{Bool}, x::Real) in Base at complex.jl:323   A few things about this:     There are 197 different methods for + . This doesn't include all of the packages that could be loaded.    Each of the methods shows where the method is defined. Generally, you can click on the link and go directly to the code.    Line 13 adds a Date and a Month , useful for handles dates.    Many of the rest are adding a number (often a Complex) and a Bool.        Variable Number of arguments  From the last exercise, it would be unfortunate if we have to write different functions for different number of arguments. We can write a variable number of arguments with a ... trailing the last argument. The following is a generalized version of the mean:   function theMean(x::Real...) local sum=0 for val in x sum += val end sum\/length(x) end   which uses a for loop that we will discuss later. This function will now find the mean using any number of arguments. Try theMean(1,2,3,4) , theMean(11\/\/2,5\/\/6,1\/\/9) and theMean(1.0,2.0,3.0,4.0,5.0) and determine if it is returning what you expect. You may notice that the mean of the two rational numbers results in a floating-point number. A better way to do this would be to return a rational.   Also, note that the argument x with the ... is a tuple, (see ). An alternative way to access the individual elements of x would be to use brackets. For example, x[3] would be the third argument.    Multiple Return Values  A very nice feature of Julia functions is that of multiple return values. Instead of only being able to return a single number (or requiring to send an array or structural type), you can return more than 1 number (or other data type). For example:    function h(x,y)  x+y,x-y  end    and if you call this, say h(3,5) you will get the result (8,-2) or if you say    p,q=h(3,5)    The variable p will take on the value 8 and q will take on the value of -2 .  The result of this function is a tuple as we saw in . Although in that section we used parentheses around the tuple, it is not necessary and generally isn't used to return a tuple in a function. We will use this for the result of the quadratic formula in .    Factorial Function  Mathematically, we define the factorial as a function on a non-negative integer as     or the product of all of the numbers from itself down to 1. There are a number of ways to program this function as we will see. Using   function fact(n::Integer) local prod=1 for i=1:n prod *= i end prod end   uses a for loop and we will see the details of this in . The for loop first assigns i the value 1 then executes the lines, then sets the value to 2, then executes the block, and so on until i is n . Since prod starts as 1, this multiplies prod by every integer between 1 and , and thus is the factorial. The result in prod is returned.   Test the function above for various positive integers.   What happens if you put in 0 or a negative integer?   What happens if you put in a number that is not an integer?     Recursive Functions  Any function that calls itself within its block of code is called a recursive function . One of the standard examples of this is the factorial function.  Above, we saw how to compute the factorial of a number using a for loop. There's another way to do this. We can define the factorial in the following way:     and this is a mathematical piecewise function that returns 1 if and otherwise returns .  The reason that this is recursive is that the factorial function is within the function. That is it calls itself.  We can write the Julia version of the factorial in the following:   function factr(n::Integer) if n == 0 return 1 else return n*factr(n-1) end end   where n == 0 tests if the variable n is 0 or not. If n is 0, then 1 is returned. Otherwise, n*factr(n-1) is calculated and then returned. The equality test as well as the if-then-else statement will be covered in detail in .  Another example of a recursive function is that of a Fibonacci number. If we let , , and then   The first few values are 1, 1, 2, 3, 5, 8, 13, 21, ... Write a recursive function that produces fibonacci numbers. Test it on values of that are smaller than 20 If you play with this a bit, you will that computing the fibonacci numbers in a recursive manner, although simple, is very slow as the values increase. In , we will examine another way to compute this more quickly.     Variable Scope  If you are using the command line Julia (also called the REPL) or in a notebook, then entering x=6 will create x as a global variable, even without saying so explicitly. If we consider the factorial function above:   function fact(n::Integer) prod=1 for i=1:n prod *= i end prod end   then recall that n is the function argument and the variable prod is actually declared locally implicitly and it is good form to say it is local by   function fact(n::Integer) local prod=1 for i=1:n prod *= i end prod end   The variable prod is not defined or visible outside the function. If we type 2*prod outside the function for example, an error will occur saying that prod is not defined. It is actually a good thing that variables inside a function is only visible inside the function (that is has local scope), because this encapsulates the code inside a function in that the function doesn't affect anything outside of it.  Let's look at local a global variables in a bit more detail, by the following function whose only purpose is to understand global and local variables.   x=3 function f() local x=2 x end f()   then evaluating the function with f() this will return 2 and typing x outside the function just to see it's (to see it's value) returns 3 , indicating that there are two different x variables.  If we indeed need a variable inside of a function to use a global variable, we can use the global keyword. If instead we have   x=3 function g() global x x += 1 end   then executing g() results in 4 showing that it is using the global value. Entering x after evaluating the function, also will return 4 . Although it is rare to need to use a global variable, we will use this technique to determine the number of function evaluations to test a function in .    Summary of Function basics  Functions are useful to separate code into a series of statements that should do one thing. A function is designated with a name and has arguments which should be typed for clarity and speed.   Julia documentation on functions is a has additional information on functions and we will cover some advanced features of functions in and .   "
},
{
  "id": "ch-intro-functions-2",
  "level": "2",
  "url": "ch-intro-functions.html#ch-intro-functions-2",
  "type": "Objectives",
  "number": "4",
  "title": "",
  "body": "   The definition of a function.    How to write a function in full or shortcut form.    How to return a value or multiple values from a function.    The definition of the function arguments and how to specify a type.    How to write a function with arbitrary number of arguments.    The definition of Multiple Dispatch and how this helps us write functions.    Introduction to recursive functions.    Variable scope related to functions.    "
},
{
  "id": "ch-intro-functions-5-4",
  "level": "2",
  "url": "ch-intro-functions.html#ch-intro-functions-5-4",
  "type": "Check Your Understanding",
  "number": "4.1",
  "title": "",
  "body": "Write a function theMean that finds the mean (average) of two arguments x and y . "
},
{
  "id": "ch-intro-functions-7-10",
  "level": "2",
  "url": "ch-intro-functions.html#ch-intro-functions-7-10",
  "type": "Check Your Understanding",
  "number": "4.2",
  "title": "",
  "body": " Rewrite the theMean function from above using types for the arguments. Since both floats and integers are real numbers, use the abstract Real type for this. Restart the kernel and test your function using both numbers (floats, integers or rationals) and non numbers (like a string).     theMean(x::Real, y::Real) = (x+y)\/2    "
},
{
  "id": "sect-factorial-7",
  "level": "2",
  "url": "ch-intro-functions.html#sect-factorial-7",
  "type": "Check Your Understanding",
  "number": "4.3",
  "title": "",
  "body": " Test the function above for various positive integers.   What happens if you put in 0 or a negative integer?   What happens if you put in a number that is not an integer?  "
},
{
  "id": "sect-recursion-10",
  "level": "2",
  "url": "ch-intro-functions.html#sect-recursion-10",
  "type": "Check Your Understanding",
  "number": "4.4",
  "title": "",
  "body": "Another example of a recursive function is that of a Fibonacci number. If we let , , and then   The first few values are 1, 1, 2, 3, 5, 8, 13, 21, ... Write a recursive function that produces fibonacci numbers. Test it on values of that are smaller than 20 If you play with this a bit, you will that computing the fibonacci numbers in a recursive manner, although simple, is very slow as the values increase. In , we will examine another way to compute this more quickly.  "
},
{
  "id": "ch-boolean-loops",
  "level": "1",
  "url": "ch-boolean-loops.html",
  "type": "Chapter",
  "number": "5",
  "title": "Boolean Statements, Loops and Branching",
  "body": " Boolean Statements, Loops and Branching     Understanding the operators equal, less than, less than or equal, greater than, and greater than or equal applied to variables, numbers and strings.    Understanding the boolean operators AND, OR and NOT and compound boolean statements.    How to write an if-then-else statement and when to use it.    How to write a while loop and examine the troubles that can occur.    How to write a for loop and when to use it versus a while loop.    Introduction to ranges, which store linear sequences of numbers.      The basic computer science structures of if statements, while and for loops are crucial in scientific computing. In this chapter, we cover the basics of these structures in Julia. We will see all of these in more context in later chapters, but here's the syntax and basics.  Lastly, because of the syntax of a for loop, we show details about ranges in Julia, which is a compact way to write a set of numbers that are either sequential or sequential with skips in it.    Boolean values and if statements   A boolean value is something that is either true or false . These are built-in constants in Julia. Sometimes we will want to know if a statement is true or false, but generally, we will use them in other structures.  We often use boolean to test various conditions. For each, testing equality using == , or comparison of numbers we use <, <=, >, >= for less than, less than or equal, greater than and greater than or equal respectively.  If we set x=3 and then can just type x==3 , x < 3 , x > 3 to test a variety of comparisons.  In addition, we can test if a boolean value does not have some value using the != and ! operators. For example using the same example x=3 as above, then we can test that x is not 4 with x != 4 . If a variable is a boolean, like b = true , the operator that changes true to false or vice versa with !b .    Compounds boolean statements  We often want to test multiple boolean statements and can build up compound ones with either the and (using the code && ) or or (using the code || ) operators. Recall the following table for && and ||    Truth Table    AND  T  F   OR  T  F    T  T  F   T  T  T    F  F  F   F  T  F     If we have x=3 and y=10 , if we want to test that x is greater than 0 and y is 5, by    x >= 0 && y==5    which will return false , since only the first is true and both must be true for this compound statement to be true. However,    x >= 0 || y==5    returns true , because the first is true.  In both of these examples, it is important to note the order of operations or operator precedence. This was mentioned in , however as the number of operators grows, it's important to know the precedence. In these cases the tests ==,<=,<,>=,> have precedence over && and || .  Also, && has precedence over || in that if we evaluate    x >=0 && y > 7 || y == 5    results in true . You can think of this resulting in true && true || false and because of precedence the first pair is tested (to be true ) then the result true || false results in true .  Often when precedence is unclear, adding parentheses can be helpful. Instead, perhaps write the above as:    (x >=0 && y > 7) || y == 5       If Statements   An if statement is used to do different things depending on the value of a variable. A standard example of this is the piecewise version of the absolute value. Mathematically, we write:     We could write this as a function as   function absValue(x::Real) if x >= 0 return x end return -1*x end   Evaluate absValue(3) and absValue(-7) to ensure this is returning expected results.  Notice that we basically had two situations here, either was greater than or equal to 0 or else not. We can rewrite this use an if-else statement.   function absValue(x::Real) if x >= 0 return x else return -1*x end end   Try entering this and seeing if the results are the same.  The absolute value function is quite important in mathematics and thus is built-in to Julia as abs .    Further choices with if statements  You may need more than 2 choices on an if statement. Recall the quadrants of the -plane start at I for the upper right and increase as you traverse counterclockwise. A function could be written:   function quadrant(x::Real,y::Real) if x > 0 && y > 0 return \"I\" elseif x < 0 && y > 0 return \"II\" elseif x < 0 && y < 0 return \"III\" elseif x > 0 && y < 0 return \"IV\" else return \"NONE\" end end   and technically if you are on an axis, then you are not in a quadrant, so that is the reason for the last option.   Evaluate the function quadrant at the following points and see if the results are as expected.                  Ternary if-then-else  A common use of an if-then-else statement is to assign a value to a variable (or return from a function) depending on some condition. There is a compact way to do this with a ternary if-then-else statement that has the form:    condition ? value_if_condition_is_true : value_if_condition_is_false    which returns value_if_condition_is_true if condition is true otherwise value_if_condition_is_false is returned. The absolute value example above can be written as a single line:    absVal2(x::Real) = x >= 0 ? x : -1*x    and once you practice with this, it will be easy to read and much shorter (1 line versus 7). Be careful with the syntax of this. It is required that the expressions around the ? be padded with spaces to parse correctly. The error is reasonably clear if you don't write it correctly.  Alternatively, you can write this as    absVal3(x::Real)=ifelse(x >=0, x, -1*x)    The ifelse is not used in this book, preference goes to the ? : format instead--which is available in almost all modern languages as well.  The ternary if-then-else is useful if you want to store a value that has a branching condition and that branch is relatively simple. If you have more complicated logic or need to call a function, this is where a if-then or if-then-else statement would be used.  Write the recursive factorial function above using the ternary if-then-else.  You can nest the ternary if-then-else . For example, the following will perform the same as the quadrant function above.   function quadrant2(x::Real, y::Real) x > 0 && y > 0 ? \"I\" : x < 0 && y > 0 ? \"II\" : x < 0 && y < 0 ? \"III\" : x > 0 && y < 0 ? \"IV\" : \"NONE\" end   Note that although this can be written on a single line (it is a single nested statement), it has been split on lines for clarity. Also, the precedence order is that : is higher that ? in order for this to evaluate as expected without parentheses.    Loops   A loop is a series of statements that are repeated either a fixed number of times or until a condition occurs. They can be very helpful if a large number of operations need to be done in a predictable manner.    While Loops  Another very common construction for programming is called a while loop. Basically, we want to run a few statements while some boolean statement is true. Here's a simple, but uninteresting example:   let local n=1 while n < 10 @show n n+=1 end end   and note that the expression n+=1 is shorthand for n=n+1 . We are using the @show macro which dumps the expression and its value to the screen. Also, we are using a let block to just encapsulate the variables.  A more practical example of a for loop will be the Bisection Method for finding a root.   function bisection(f::Function, a::Real, b::Real) local c while (b-a) > 1e-6 c = 0.5*(a+b) # find the midpoint # test if f(a) and f(c) have opposite signs to determine the new interval (a,b) = f(a)*f(c) < 0 ? (a,c) : (c,b) end c end   In short, this method takes a function and an interval and continually bisects it ensuring there is a root in the resulting interval. It continues while the length of the interval is greater than 1e-6 or . We use a tuple to handle the interval and on line 6, we have used a ternary if-then-else to first test which interval to use and then return either the left or right hand subintervals.  To test it, consider    f(x) = x^2-2    which has a root of . The function call    bisection(f,1,2)    returns 1.4142141342163086 , which is approximately .  Note that we used a ternary if-then-else in the bisection function in conjunction with a tuple to update both points in the interval. This makes the function reasonably simple. A standard if-then-else statement can be used instead if desired.  This was used as a practical example and we will explore this and other rootfinding techniques in .    Infinite Loops  It is common in a while loop to keep running it forever. This occurs if there is some bug or you haven't considered all cases. For example, in the bisection method above, if the function doesn't have a root (like ), then this will never stop.  Here's a few things that can help prevent or debug the code:     Make sure something is changing in your loop. If you intend to stop the loop on an index, make sure the index is updating.    Look at your code and see if you have something that you think will stop the loop. What ever is in the boolean statement needs to eventually switch.    Consider an additional stopping condition. You may need to add a variable to count the number of times you've gone through the loop and stop if it hits some maximum, which is greater than what you would expect.    Stop the code if you need to. You may need to interrupt the kernel. In the REPL, CTRL-C will stop and in a notebook, selecting the Kernel menu then Interrupt or there is often a stop button which should stop it. The square in the toolbar should work too. See for more information.    If you can't figure out why it is in an infinite loop, use @show to print out values of variables.       Debugging While Loops  As we mentioned above, if we use a function that does not have a root, like , the bisection function will not stop. Go ahead and try it. Here we will add some code to that method that will prevent it from running forever.     we will introduce a variable n which will keep track of the number of steps we have done. We will start this variable with the value 0 .    Then, inside the loop update the value of n with the statement n += 1 .    Lastly, add another condition to the while statement that will only continue if n is less than some value, say 10 .     The following update to the bisection method will now stop if we go too many times:   function bisection(f::Function, a::Real, b::Real) local c local n = 0 while (b-a) > 1e-6 && n lt; 10 c = 0.5*(a+b) # find the midpoint # test if f(a) and f(c) have opposite signs to determine the new interval (a,b) = f(a)*f(c) lt; 0 ? (a,c) : (c,b) n += 1 end c end      For loops   A for loop executes some code a fixed number of times and has a variable (called an index) that updates. The next few examples are not practical, but are designed to illustrate the syntax and what is possible. The following is a simple for loop that prints out the numbers 1 to 10    for i=1:10  @show i  end    If you want to skip numbers or count backwards, a range in the form start : skip : stop is used. The following starts at 1 and skips by 2 up to 21:    for i=1:2:21  @show i  end    and the following starts at 10, counting down to 1:    for i=10:-1:0  @show i  end    We can use the for var in list form to go through elements in a list or array (or tuple). The following adds all numbers in the list (array) [1,5,7,11,20] :    let  local sum=0  for i in [1,5,7,11,20]  sum += i  end  sum  end    Recall that in we used this in the formation to find the mean:   function theMean(x::Number...) local sum=0 for val in x sum += val end sum\/length(x) end     While Loops Versus For Loops  No this, isn't a smackdown between these while and for loops. A big question often is when I have a problem that I want to solve and I know a loop is needed, when should I use a while loop and when should I use a for loop. The general rule of thumb is:     If you know that you need to run code for a fixed number of times, use a for loop    If you don't use a while loop. Generally, the doing something in the loop will affect how many times the loop is run.     Notice in the examples above, the bisection method used a while loop because it is unclear when you start how many times you want to go through the loop. Instead we stopped in while the interval was small enough.  In the summing of the terms for the mean, a for loop was used because of the fixed number of values in the tuple x .     Ranges   In a for loop with the syntax var=x:y:z , such as    for i=1:4  @show i  end    The syntax 1:4 is called a Range and is shorthand for all integer between 1 and 4 inclusively. Technically, this is called a UnitRange because the skip size between numbers is 1.  If you type typeof(1:4) , it will return UnitRange{Int64} , a composite type which is a UnitRange with integers. Note the difference using 1.0:4.0 . This is of type StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} , and the details of this are skipped for now. In short, it is Floating Point version of a UnitRange .  The other ranges we say included 1:2:11 and entering typeof(1:2:11) results in StepRange{Int64, Int64} .  We will see in that there is a handy way of expanding this shorthand way of writing these sets of numbers to that of an entire list (or technically array) of numbers.    Linear Ranges  As we see above, it easy to make ranges if we know the step between each pair. Another use would be to know the starting and ending value and the number of values. For example, if we want to start at 3 and end at 11 with 5 values, it's not too hard to compute this, but Julia has a built-in way to do it with the range command. For example,    range(3,11,length=5)    returns 3.0:2.0:11.0 and note that even though all of the arguments were integers that the result is a floating point range.  Another nice function that does a similar thing is the LinRange function.    LinRange(3,11,5)    which returns 3.0, 5.0, 7.0, 9.0, 11.0 and this is an expanded version from above.    "
},
{
  "id": "ch-boolean-loops-2",
  "level": "2",
  "url": "ch-boolean-loops.html#ch-boolean-loops-2",
  "type": "Objectives",
  "number": "5",
  "title": "",
  "body": "   Understanding the operators equal, less than, less than or equal, greater than, and greater than or equal applied to variables, numbers and strings.    Understanding the boolean operators AND, OR and NOT and compound boolean statements.    How to write an if-then-else statement and when to use it.    How to write a while loop and examine the troubles that can occur.    How to write a for loop and when to use it versus a while loop.    Introduction to ranges, which store linear sequences of numbers.    "
},
{
  "id": "ch-boolean-loops-4-3-3",
  "level": "2",
  "url": "ch-boolean-loops.html#ch-boolean-loops-4-3-3",
  "type": "Table",
  "number": "5.1",
  "title": "Truth Table",
  "body": " Truth Table    AND  T  F   OR  T  F    T  T  F   T  T  T    F  F  F   F  T  F    "
},
{
  "id": "ch-boolean-loops-5-3-5",
  "level": "2",
  "url": "ch-boolean-loops.html#ch-boolean-loops-5-3-5",
  "type": "Check Your Understanding",
  "number": "5.2",
  "title": "",
  "body": " Evaluate the function quadrant at the following points and see if the results are as expected.              "
},
{
  "id": "ch-boolean-loops-6-11",
  "level": "2",
  "url": "ch-boolean-loops.html#ch-boolean-loops-6-11",
  "type": "Check Your Understanding",
  "number": "5.3",
  "title": "",
  "body": "Write the recursive factorial function above using the ternary if-then-else. "
},
{
  "id": "ch-arrays",
  "level": "1",
  "url": "ch-arrays.html",
  "type": "Chapter",
  "number": "6",
  "title": "Arrays",
  "body": " Arrays     Learn that arrays are ordered collections of things that can be accessed and updated.    There are numerous methods including direct entry and comprehensions to construct an array.    There are many methods on arrays including some arithmetic ones on both vectors and matrices as well as the sum and product of numeric vectors.    There are numerous methods to extract, delete, insert and append elements to vectors.    Understanding how to sort vectors either numerically, lexicographically or by applying another function first.    The join method takes an array and returns a string and similarly a split method, takes a string and splits into an array.      Arrays are a fundamental data structure for nearly every computer language and it is a crucial for scientific computing as that it is an efficient way of handling large amount of the same datatype. Additionally, arrays are the computing version of mathematical vectors and matrices.  In short an array is a collection of data of (typically) the same type under the same name. We have seen arrays before. For example, if we say    arr = [1,2,3]    then we get a 1-dimensional array of length 3. Note that when returned, Julia says 3-element Vector{Int64}: which means     it is length 3 (since it is a 3-element)    The internal type is Int64 .    The Vector indicates it is 1-dimensional.     There are some basic functions that tell us some information:      length(arr) returns 3, the length.     eltype(arr) returns Int64 , the type of the elements in the array.       Constructing arrays  We can create arrays in many ways. As seen above, the line    arr=[1,2,3]    creates a vector (1-D array) of length 3. A 2D array can be made like:    arr2=[1 2 3; 4 5 6]    Note that each row of the array is separated by a semicolon and the individual elements in a row are separated by spaces. The result of this is    2×3 Matrix{Int64}:  1 2 3  4 5 6    and the size is 2 by 3 (2 rows and 3 columns). A Matrix is a 2 dimensional array. One can make an array of more than 2 dimensions.  The following are useful for creating arrays of 1 or more dimensions.      zeros(type,dims...) makes an array of all zeros with datatype type and given dimensions. For example,    zeros(Int, 4, 6)    returns an array filled with zeros (of integer type) with 4 rows and 6 columns.     ones(type,dims...) is similar to zeros except it is filled with 1s.     rand(dims...) makes a random array of floating points (uniformly distributed between 0 and 1).     collect(range) takes a Range object (the pair or triples of numbers separated by colons) and creates an 1D array with the numbers from the range. For example, collect(1:10) returns    10-element Vector{Int64}:  1  2  3  4  5  6  7  8  9  10         Comprehensions  If the elements of an array form a functional pattern, we can use what is called a comprehension to construct it in a compact manner. For example, a 1D array [1, -1, 1, -1, 1, -1, 1, -1] can be made:   [(-1)^n for n=0:7]   and the following:   [m+n for n=1:8,m=1:8]   makes an 8 by 8 matrix where each element is the sum of the row and column number or    8×8 Matrix{Int64}:  2 3 4 5 6 7 8 9  3 4 5 6 7 8 9 10  4 5 6 7 8 9 10 11  5 6 7 8 9 10 11 12  6 7 8 9 10 11 12 13  7 8 9 10 11 12 13 14  8 9 10 11 12 13 14 15  9 10 11 12 13 14 15 16     Using the techniques in this section, create the following arrays in Julia:                                Hint: there is no pattern for the array in #4, so just enter the numbers.     Accessing elements of an array  Let x=collect(1:2:13) which generates:    7-element Vector{Int64}:  1  3  5  7  9  11  13    To access the 2nd element, type x[2] . To get a vector consisting of the elements 3, 4 and 5, type   x[3:5]   or if we want the last 3 elements, we can use:   x[end-2:end]   where end is an alias for the last element, so this returns an array of the last 3 elements of x .  Let   A=[i+j for i=1:4,j=1:5]   to access the 1st row, 3rd column, type A[1,3] . If you want the subarray of the first and 3rd and 5th columns and all rows type:   A[:,1:2:5]   returns the matrix    4×3 Matrix{Int64}:  2 4 6  3 5 7  4 6 8  5 7 9    where the : in the first slot means all rows and 1:2:5 are the columns 1, 3 and 5.  If we want the first 2 rows and then shuffle the 2,3 and 5th columns in the order 5,3,2 type    A[1:2,[5,3,2]]    returns    2×3 Matrix{Int64}:  6 4 3  7 5 4    There are a number of different ways to return subarrays. See the Julia matrices documentation for more information.    Common Operations on Arrays  There are a number of operations on array. For each + and - adds and subtracts two arrays of the same size in an element by element manner. For example if   A=[1 2 3; 4 5 6]   and   B=[1 3 5; 2 4 6]   then A+B returns the array:    2×3 Matrix{Int64}:  2 5 8  6 9 12    and B-A returns    2×3 Matrix{Int64}:  0 1 2  -2 -1 0      Element by Element Operations (Broadcasting)  Many methods exist to simplify a vectorized method that returns the operation applied element by element to the matrix. To do this, most operations have a . variety and is also called broadcasting . For example, if we want multiply A and B in an element by element manner then   A.*B   returns    2×3 Matrix{Int64}:  1 6 15  8 20 36    Note that this is not matrix multiplication, which is A*B and we will discuss this in . Many other operations can be done in similar way. For example, to take the square root of every number in the matrix A , we can enter sqrt.(A) which returns:    2×3 Matrix{Float64}:  1.0 1.41421 1.73205  2.0 2.23607 2.44949    Let A=[1 2; 3 4] and B=[1 -1;1 -1] .    Find and explain the results of      A.^2      A.*B      1 .\/ A        Find the sin of every number in A .     Broadcasting can be applied to other array-like structures like tuples, but also scalars and other collections. For example,    (1,2,3) .+ (4,5,6)    returns (5, 7, 9) . And if we want to add 10 to every element of a matrix, we can use this syntax as well. [1, 2, 3, 4] .+ 10 returns [11, 12, 13, 14] . Note that having broadcasting simplifies a lot of operations with arrays. Without this, typically a for loop would be needed to be written, which is not difficult, but more more complicated than a single operation.  There is also a macro that can apply broadcasting. Let's say that we are applying the function on an array x = collect(-3:3) . To write this operation element by element: one must do x .* sin.(x)+exp.(x.^2) and also that isn't too difficult, there is a bit of an easier way using the @. macro. If we add this in front of a non-broadcasting expression, it will apply all functions an operations in the right way. You should notice that @. x*sin(x) + exp(x^2) returns the same array.  We will use both forms of broadcasting in the rest of this book. Often, it broadcasting is relatively simple, we'll use the non-macro version, but for more complicated ones, we'll use the macro.    Other Operations on Arrays  There are also other operations on arrays. For example, summing all elements in an array is just the sum functions. For example:    sum([1 2 3 4 5 6 7 8 9 10])    returns 55. There are also the min , max and prod functions, with the last one, the product of elements.    prod([1,3,5,7])    returns 105 .    Sorting Vectors and matrices  Julia can sort an array using the sort function. If A=[3,2,1,4,8,6,5] , then    sort(A)    results in [1 2 3 4 5 6 8] . The sort function returns a new array that is the sorted version of the original. If you want a sorted version of A in place, use the sort! function instead.  Also, you may want to sort in a descending manner. If this is true use the keyword argument rev=true in the sort or sort! function. For example:    sort(A,rev=true)    results in [8 6 5 4 3 2 1] .  If an array element type is a String , then it is sorted lexicographically (similar to alphabetical). If    B = [\"This\",\"is\",\"a\",\"string\",\"array\"]  sort(B)    which returns [\"This\", \"a\", \"array\", \"is\", \"string\"] , where capitalized words come before lower case.  We can also specify the function that is applied before sorting is done. For example,    C = collect(1:9)  sort(C, by = x -> x % 3)    where C is the array from 1 to 9 and before sorting, the mod is taken. The by is a keyword argument that takes a function. in this case, we have used an anonymous function , which is a function without a name and is often used inside of other functions. We will explore these in more detail in . The result of the sort function is [3,6,9,1,4,7,2,5,8] , where the mod of the first 3 are 0, the next three are 1 and the last three are 2.  Check out the Julia docs on sorting and sorting algorithms for more details on how Julia does sorting.    Push and Pop; Array as a Stack  There is a computer science data structure called a stack which acts like a stack of things (paper, dishes, Pokémon cards) and there are two operations on it: 1) put something on top of the stack or 2) take something off the top of the stack. Many languages including Julia don't have a separate data structure but use an array like one with two operations, push and pop . In Julia these have ! at the end to indicate that the operations change the array. If A=collect(1:5) then    push!(A,7)    returns the array [1 2 3 4 5 7] . And multiple values can be pushed.    push!(A,8,9,10,100)    results in the array [1 2 3 4 5 7 8 9 10 100] . To get an element off of the end of the array, we can use pop! . If A=collect(1:5) , then    pop!(A)    returns 5 and now the array A is [1 2 3 4] .    Other Nice Array Functions   Julia has a ton of other nice functions that act on arrays.    Append  If we want to concatenate two arrays, we should use the append! command. For example:    A=[1,2,3]  append!(A,[4,5,6])    and now the array stored in A is [1,2,3,4,5,6]     Adding and Removing Elements in the Middle of an Array  The functions push! and pop! add and remove an element from the end of a Vector or 1D array. If we want to add or remove elements in the middle there is are the functions insert! and deleteat! . They both act on a position in the array and you can see how they work with the following examples. If A=collect(1:2:11) , then    insert!(A,3,15)    results in the array A being [1 3 15 5 7 9 11] and then resetting the array with A=collect(1:2:11) then    deleteat!(A,2)    results in the array A being [1 5 7 9 11] .    It Splices, It Dices!! --- okay, it doesn't dice  Although you can get a long ways with push!, pop!, insert! and deleteat! , the splice! function is a Swiss Army knife for arrays. It can take an array, pull elements out and put elements in. We will walk through the options:     Removing elements from an array  We saw using the deleteat! function above how to remove a single element, but if   A=collect(1:2:13) then   splice!(A, 3:4)   removes and returns the 3rd and 4th elements which are [5, 7] . Also, the array A is the original array without these elements or [1, 3, 9, 11, 13] . If we let A=collect(1:2:11) , then   x = splice!(A,2)   returns the element in the 2nd position vector or 3 . The array A is now [1, 5, 7, 9, 11] . This is the same as deleteat!(A,2) we saw above.    Inserting elements from an array  We saw the function insert! above, which will insert a single element in a 1D array. The splice! function will insert multiple elements. For example, if we have   A = collect(1:2:11)   then to insert elements in the 3rd position (and shifting everything else to the right), we can enter   B=splice!(A,3:2,[11,12,13,14])   then the function returns Int64[] . This is an empty array of type Int64 . The result is empty because nothing was removed in the process. The array A is now [1, 3, 11, 12, 13, 14, 5, 7, 9, 11] . A few things to note about this. The second argument is a bit strange in that you insert 3:2 which is a range in which the last element is smaller than the first. This will let Julia know that you don't want to remove any elements, unlike either a single number or a range with the first element smaller than the last.    Replacing elements from an array  We say splice! is the Swiss army knife, because it does even more!! (Now, how much would you pay?). This last section shows that we can both remove and insert elements into an array at the same time.  If A=collect(1:2:11) , then   x = splice!(A,3,4)   returns 5 and replaces the 3rd position with the number 4. The result is [1, 3, 4, 7, 9, 11] . If A=collect(1:2:11) , then replacing the 3rd element with [-1,-2,-3] by   splice!(A,3,[-1,-2,-3])   returns 5 (the element in position 3) and now the array A is [1, 3, -1, -2, -3, 7, 9, 11] .       Filtering Arrays  A very handle array method, is  filter which takes an array and returns only the elements that satisfy some condition.  If A=collect(1:20) , then   filter(n -> n%2==0, A)   returns all elements that satisfy that the mod 2 is 0 (or even numbers) or [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] . The first argument is a function and we use an anonymous function for this.  In general, the filter command has the form: filter(cond,array)   where the result is the array consisting of elements in array in which the function cond is true.  In addition, if you want to filter on an array with the results in the place of the original array use filter! instead. For small arrays, one can use either, however, for a large array, to use filter would require a new array be made and we will see in that creating arrays is a slow down and often a bottleneck for code. In such a case filter! would be more efficient.    Removing Duplicate Elements  Another handy function is the unique function that takes an array and returns only the unique elements.  If A=[1,2,3,2,3,4,3,4,5,4,3,2,1] then   unique(A)   returns [1,2,3,4,5] . And if you want to update the original array, use the unique! function instead.     Joining Arrays and Splitting Strings  There are a couple of related functions that involve arrays, that of joining an array to get a string and splitting a string to get an array. We show a few examples here.  Let's say that we have the vector formed by x=collect(1:6) . If we want to create a string in which all of the elements are joined, consider    join(x, \", \")    which outputs \"1, 2, 3, 4, 5, 6\" , which is the 6 elements of the vector stringified and concatenated separated by \", \" . The join function has another option to separate the last one differently. For example if    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]    then join(days, \", \", \" and \") returns    \"Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday\"    notice that the first 6 elements are separated by \", \" and the last one with \" and \" .  Additionally, Julia has the ability to split a string into an array of substrings. For example if    str = \"1; 2; 3; 4; 5; 6\"    then split(str, \"; \") returns the array    6-element Vector{SubString{String}}:  \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"    and notice that this is an array elements of type Substring{String} . This type is used as an efficiency to show where in the original string the substring occurs. If it is desirable to extract the integer representations of the strings, then use the parse function explained in . The integers can be extracted with    map(s-> parse(Int,s), split(str, \"; \"))    where the map function from is used. This returns the integer array [1, 2, 3, 4, 5, 6] . See the Julia documentation on split for more information and options.    Arrays as a Collection  An array is one example of a Collection in Julia. We will cover these in more details in and it is helpful to have knowledge of the more abstract idea when handling arrays.   "
},
{
  "id": "ch-arrays-2",
  "level": "2",
  "url": "ch-arrays.html#ch-arrays-2",
  "type": "Objectives",
  "number": "6",
  "title": "",
  "body": "   Learn that arrays are ordered collections of things that can be accessed and updated.    There are numerous methods including direct entry and comprehensions to construct an array.    There are many methods on arrays including some arithmetic ones on both vectors and matrices as well as the sum and product of numeric vectors.    There are numerous methods to extract, delete, insert and append elements to vectors.    Understanding how to sort vectors either numerically, lexicographically or by applying another function first.    The join method takes an array and returns a string and similarly a split method, takes a string and splits into an array.    "
},
{
  "id": "sect-comprehensions-2",
  "level": "2",
  "url": "ch-arrays.html#sect-comprehensions-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "comprehension "
},
{
  "id": "sect-comprehensions-8",
  "level": "2",
  "url": "ch-arrays.html#sect-comprehensions-8",
  "type": "Check Your Understanding",
  "number": "6.1",
  "title": "",
  "body": " Using the techniques in this section, create the following arrays in Julia:                                Hint: there is no pattern for the array in #4, so just enter the numbers.  "
},
{
  "id": "sect-broadcasting-8",
  "level": "2",
  "url": "ch-arrays.html#sect-broadcasting-8",
  "type": "Check Your Understanding",
  "number": "6.2",
  "title": "",
  "body": "Let A=[1 2; 3 4] and B=[1 -1;1 -1] .    Find and explain the results of      A.^2      A.*B      1 .\/ A        Find the sin of every number in A .    "
},
{
  "id": "ch-functional-programming",
  "level": "1",
  "url": "ch-functional-programming.html",
  "type": "Chapter",
  "number": "7",
  "title": "Functional Programming",
  "body": " Functional Programming     Explain what functional programming is and how it differs from non-functional programming.    Understanding anonymous functions, how to write them and when to use them.    Using the map command to create a new array from an old one.    Using the reduce and mapreduce commands to take an array and combine it to a single value.    Understand what is needed to develop fast code.      This chapter introduces ideas of functional programming , which is a way to think about programming using functions. Typically this requires a language that falls into the category of a functional computer language , one of which is Julia. In short, a language that has this feature has a function (or procedure) as a fundamental element of the language and one of which can be passed as arguments.    Functional vs. Non-functional forms   A common operation is to start with some array and create a new array based on the first one where there is some relation between the two. This is often called a mapping. If we start with the following array:    arr=collect(1:5)    and we want a new array that is the square of each element. Using a statement-based method, the following will create this using a for loop:    newarr=zeros(Int,5) # this an array of zeros of length 5  for i=1:5  newarr[i]=arr[i]^2  end  newarr    which returns the array [1,4,9,16,25] .  There is a much simpler way to do this using a method called map which takes in a function and an array and produces another array in which a function acts on each element of the array. In this case, the function is the square.    f(x)=x^2  arr=[1,2,3,4,5]  map(f,arr)    This can be written even more simply, by using an anonymous function for the first element or:    map(x->x^2,arr)    The key to this example is the ability to pass the function as an argument to the map command. Once you get a feeling for functional programming, it is often an easier way to write code. An extreme example of this is to avoid using any for loops after understanding maps and other related functions. Although, often this can happen, it doesn't 1) make the underlying code any faster or 2) any easier to understand, so I don't generally prescribe to this philosophy.     Anonymous Functions  The example above included in the first argument x->x^2 , which is an example of a anonymous function . In short, it is anonymous because we didn't assign it to a name and instead just included the function as an argument to the map command and this is precisely when anonymous functions are used.  Recall that we saw a couple of examples of this in . One example was filter(n -> n%2 == 0, A) which returns all elements of A where the element is an even number. The first argument of filter is a function and if the function is simple, passing in as an anonymous function is typical. The other example we used was in the sort command and can pass a function which is applied before sorting using the by command.  Any time that a function is used in the form -> , it is anonymous. For example, if we want to sum the contents of the array A=[1,2,3,4,5] , one way is to    reduce((x,y)-> x+y, A)    which results in 15 , the sum of the elements of the array. We'll see the reduce function in the next section. Concentrate right now on the (x,y)->x+y , an anonymous functions can take on more than one variable.     Write a statement-based loop to take the array [1,2,3,4,5] and output an array that is the reciprocal of each number.    Write a functional-based code using the map command to do the same.       Mapping over two arrays  The map function can work over multiple arrays as long at the first argument, which is the function can take as inputs multiple values. A simple example is to multiply element by element over vectors like    map(*,[1,2,3],[10,20,30])    and the result is [10, 40, 90] .  An astute reader will remember that we could have also done this with broadcasting as in [1,2,3] .* [10, 20, 30] , but the point of this is show an example with mapping over two arrays. Another example of this using an anonymous functions is    map((x,y)->x^2+y,[1,2,3],[10,20,30])    which squares each element in the first array, then adds to a second array resulting in [11, 24, 39] and again this could have been done with broadcasting.     Reducing an array  The map command in general takes in an array and returns an array. Another common task with arrays is to reduce the entire array to a single value. If arr=[1,2,3,4,5] , then we can sum the values with the reduce command as in:    reduce((x,y)->x+y,arr)    which returns 15 . This could be written simpler with reduce(+, arr) .  To multiply all numbers, we can type:    reduce((x,y)->x*y,arr)    and the result is 120 . This could be written simpler with reduce(*, arr) . In both of these cases, there is a little bit hidden, so let's look at these in more detail.     First, the first argument of the reduce command is a 2-argument (or binary) function.    Secondly, the operation is done on all numbers on the array, but needs to start with some value (because it is a binary function). In the sum case, the initial value is 0 (by default) and in the multiply case it is 1.     These are perhaps obvious examples and each of these have the built-in functions sum and prod that find the sum and product of an array.  Let's look at an example that returns the number of array elements that are greater than zero:    numPos(arr) = reduce((n,val) -> val > 0 ? n+1 : n, arr, init=0)    and then if it is tested on an array of both positive and negative numbers:    numPos([-3,5,8,-2,11])    this returns 3 . How this works is as follows. There are two values associated within reduce from the function. The first is n and the second is val .     The variable n is initially 0 (this is the init=0 part of the function call)    On the first step, val takes on the first value in the array (or -3 ). It is checked if it is positive and if so, return n+1 or n . Since n=0 and -3 is not positive, then the function returns 0.    On the second step, val is 5 and this time the function returns n+1 or 1     val is 8 and the function returns n+1 or 2     val is -2 and the function returns n or 2     val is 11 and the function returns n+1 or 3.    Since the array has been passed through, the result is the last value or 3.        Write a reduce function that will count the number of times the string \"hi\" appears in an array. Test it on [\"hi\",\"bye\",\"hi\",\"hello\"] and other arrays of strings.    What does reduce(*, [\"J\",\"u\",\"l\",\"i\",\"a\"],init=\"\") do?       The mapreduce function  The  mapreduce function is perhaps more helpful than reduce . For example, if we want to sum the squares of each number in an array, then mapreduce can do this easily.    mapreduce(x->x^2,+,[1,2,3],init=0)    is a short-hand way to do . For mapreduce , the first argument is a function of one variable (unary) that is applied to every element of array. The second argument is a binary element that is used for the reduce part. Note: Julia also has a version of the sum function that can apply a function. For example, sum(x->x^2,[1,2,3]) returns the sum of 14 .  Another example that we will see later is how to write a polynomial using its coefficients. For example, if coeffs = [-2,4,5,7] , then we want to create a way to produce the polynomial \"-2 x^0 + 4 x^1 + 5 x^2 + 7 x^3\" . This is a clear candidate for either a reduce or mapreduce because we have an array and reduce a single thing (in this case a string). We will use mapreduce in this case because there is a transformation of each element which produces the polynomial term and then the reduce is a concatenation.  Although it seems like we should use the array itself, we are going to use the array (technically the range), 1:length(coeffs) , so we can produce the powers in each of the term. Therefore the mapping function will be    i -> \"$(coeffs[i])x^($i-1)\"    which take a number i and looks up the right coeffs and raise to the i-1 power, since we need to shift the power by one. Next, we need a function that will concatenate the terms. This will be    (str, term) -> str * \" + $term \"    where str is the current version of the polynomial string and term will be the current term (which is created with the mapping function). Putting this altogether    mapreduce(i -> \"$(coeffs[i]) x^$(i-1)\", (str, term) -> str * \" + $term \" , 1:length(coeffs) )    and this will return the string \"-2 x^0 + 4 x^1 + 5 x^2 + 7 x^3 \" . We will use this in when we crate a Polynomial type and this function will show the results in a more natural way.   In calculus, an important infinite series is     and although we can't sum an infinite number of terms, a finite version of this is still useful.  Use mapreduce to sum the first 20 terms.   Use arr=1:20 for the array and the mapping function is the reciprocal.     Mapping a Function over an 2D array  Above, we saw the map function which applies a function over each element of the array. We will see in that the mapslices functions is quite helpful.  Consider the array A=[i+j for i=1:10,j=1:3] which returns the array  10×3 Matrix{Int64}:  2 3 4  3 4 5  4 5 6  5 6 7  6 7 8  7 8 9  8 9 10  9 10 11  10 11 12  11 12 13    If we want to sum down the columns of the array, we can enter    mapslices(sum,A,dims=[1])    which returns the array [65 75 85] , which is a 1D array with the column sums. The mapslices function needs three arguments, a function that can take an array, a 2D array and the keyword dims which says how to apply the sum. Note: we can also replace the command sum with + as well.  If instead we wanted to sum along rows, then    mapslices(sum,A,dims=[2])    which returns    10×1 Matrix{Int64}:  9  12  15  18  21  24  27  30  33  36    Although note that this is a 2D array. The function mapslices returns an array of one fewer dimensions as the original.  Using the matrix A=[i+j for i=1:10,j=1:3] ,    evaluate mapslices(prod,A,dims=[1]) . What does that function do?    evaluate mapslices(prod,A,dims=[2]) . What does that function do?    use the mapslices function to find the maximum element in each row.    use the mapslices function to find the maximum element in each column.      "
},
{
  "id": "ch-functional-programming-2",
  "level": "2",
  "url": "ch-functional-programming.html#ch-functional-programming-2",
  "type": "Objectives",
  "number": "7",
  "title": "",
  "body": "   Explain what functional programming is and how it differs from non-functional programming.    Understanding anonymous functions, how to write them and when to use them.    Using the map command to create a new array from an old one.    Using the reduce and mapreduce commands to take an array and combine it to a single value.    Understand what is needed to develop fast code.    "
},
{
  "id": "ch-functional-programming-4-2-8",
  "level": "2",
  "url": "ch-functional-programming.html#ch-functional-programming-4-2-8",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "anonymous function "
},
{
  "id": "ch-functional-programming-4-3-7",
  "level": "2",
  "url": "ch-functional-programming.html#ch-functional-programming-4-3-7",
  "type": "Check Your Understanding",
  "number": "7.1",
  "title": "",
  "body": "   Write a statement-based loop to take the array [1,2,3,4,5] and output an array that is the reciprocal of each number.    Write a functional-based code using the map command to do the same.    "
},
{
  "id": "sect-reduce-array-16",
  "level": "2",
  "url": "ch-functional-programming.html#sect-reduce-array-16",
  "type": "Check Your Understanding",
  "number": "7.2",
  "title": "",
  "body": "   Write a reduce function that will count the number of times the string \"hi\" appears in an array. Test it on [\"hi\",\"bye\",\"hi\",\"hello\"] and other arrays of strings.    What does reduce(*, [\"J\",\"u\",\"l\",\"i\",\"a\"],init=\"\") do?    "
},
{
  "id": "section-mapreduce-13",
  "level": "2",
  "url": "ch-functional-programming.html#section-mapreduce-13",
  "type": "Check Your Understanding",
  "number": "7.3",
  "title": "",
  "body": " In calculus, an important infinite series is     and although we can't sum an infinite number of terms, a finite version of this is still useful.  Use mapreduce to sum the first 20 terms.   Use arr=1:20 for the array and the mapping function is the reciprocal.  "
},
{
  "id": "ch-functional-programming-7-12",
  "level": "2",
  "url": "ch-functional-programming.html#ch-functional-programming-7-12",
  "type": "Check Your Understanding",
  "number": "7.4",
  "title": "",
  "body": "Using the matrix A=[i+j for i=1:10,j=1:3] ,    evaluate mapslices(prod,A,dims=[1]) . What does that function do?    evaluate mapslices(prod,A,dims=[2]) . What does that function do?    use the mapslices function to find the maximum element in each row.    use the mapslices function to find the maximum element in each column.    "
},
{
  "id": "ch-fast-code",
  "level": "1",
  "url": "ch-fast-code.html",
  "type": "Chapter",
  "number": "8",
  "title": "Timing Code and Writing for Speed",
  "body": " Timing Code and Writing for Speed     Introduction to timing code and doing comparisons between code that gets the same results.    Understanding why code takes longer than other code.    Comparing recursive and non-recursive code in terms of number of function evaluations.      This chapter will show one aspect of writing fast code, an important aspect of scientific computing. We will study a number of ways to sum up the first counting numbers and determine why the timing of things are different. Also, we are going to test the various types of integers as well to determine the speed of things with that. In each case we are going to create a function and then time it.    Attempt #1  Let's start by making an array of all of the numbers, then summing them in a for loop:   function sum1(n::Int) local arr = collect(1:n) local sum = 0 for i in arr sum += i end sum end   On my laptop: @time sum1(1_000_000) returns    0.026257 seconds (2 allocations: 7.629 MiB, 91.73% gc time)   500000500000    The @time is called a macro (note the \"@\" symbol that starts this), which is similar to a function, however is more flexible. The first line clearly has the time, but also the array allocations and memory allocated. The second line of the macro returns the value of the function.  If we repeat this for the sum of the first billion counting numbers:  @time sum1(1_000_000_000)    it takes a while to get    4.286106 seconds (2 allocations: 7.451 GiB, 7.30% gc time)   500000000500000000    The big difference between these is the total memory allocation. There is a 1000-fold increase in memory allocated (note the MiB or megabytes versus GiB or gigabytes). This also shows about a 160-fold increase in time, surprising that it didn't go up 1000 times as well.  Allocating memory is a time-expensive endeavor. Also, even though the machine that I ran this on has 16 gigabytes, perhaps it couldn't get all 7.5 GiB it needed for this operation at once. This is shown with the 7.30% gc time, which mean garbage collection. In short, there was some time needed to handling so much memory. Garbage collection is a way to clean up allocated memory that is no longer needed. It's complicated, but the percentage of gc can reveal why a calculation may be taking longer than expected.  If you have some patience, try this will 2 billion or more and see the results. You will probably need more allocation time and should be at least twice as long.    Attempt #2  The big difference seemed to be the total memory allocation, so let's try a version where we don't allocate the array.   function sum2(n::Integer) local sum = 0 for i=1:n sum+=i end sum end   and running it as @time sum2(1_000_000_000) we get    0.000000 seconds   500000000500000000    and notice that the time has shrunk to zero--we'll see later why this is true. If we try for larger numbers, such as @time sum2(100_000_000_000) , which still takes almost no time, but notice that that the result is not correct. Why? Consider the ideas from .    Attempt #3  Hopefully you thought about the strange result above. If you thought overflow, give yourself a gold star. To avoid this, let's write a BigInt version of this:   function sum3(n::Int) local sum = big(0) for i=1:n sum+=i end sum end   and, @time sum3(1_000_000) returns    0.146406 seconds (3.00 M allocations: 45.776 MiB)   500000500000    Comparing this with the results at the beginning of Attempt #1, shows that BigInts are much slower as mentioned in .    @time sum3(10_000_000)    returns    2.288845 seconds (30.00 M allocations: 457.764 MiB, 34.08% gc time)   50000005000000    which is more than 10 times slower, so it appears that this is linear as possibly as expected. This isn't practical to find much larger sums though.    Attempt #4  Let's trying using the reduce function on BigInts:   function sum4(n::Int) reduce(+,1:big(n)) end   Then @time sum4(1_000_000) returns    0.335802 seconds (5.00 M allocations: 91.553 MiB, 20.56% gc time)   500000500000    Notice that this allocates about 91 MiB of memory, which isn't a lot, but this is probably due to the BigInt allocations. Also, this is about twice the amount of time as that in Attempt #3. Notice also a significant amount of gc (garbage collection) time.  Also, @time sum4(10_000_000) returns    3.254972 seconds (50.00 M allocations: 915.528 MiB, 16.57% gc time)   50000005000000    which is about 10 times slower that the previous one, and still about twice the speed of sum3 for the same number n .  Also notice that the number and size of the allocations have increased by a factor of 10, which should not be surprising. However, notice that they are quite large. For the second sum, there was nearly 1 Gb of allocation despite no array. This is due to the BigInt which allocates quite a bit of memory. It appears that Julia allocates memory for every BigInt created (and there are 10 million in this example).    Attempt #5  Let's use the built-in sum command. Entering @time sum(1:big(10)^6) returns    0.001495 seconds (41 allocations: 816 bytes)   500000500000    and note that higher powers of 10 do not increase the time much. For example, @time sum(1:big(10)^20) results in    0.000828 seconds (42 allocations: 904 bytes)   5000000000000000000050000000000000000000    What is going on? How is this so fast? Think about this and we'll answer it below.  Repeat Attempts #1--#4 for Int128 . That is, make sure that the calculations are being done using this type. For the for loops, start with   local sum = Int128(0)   and for the reduce function use Int128(n) instead of big(n) . Compare your results with those above.    Summary of Results  There were a lot of factors going on in the above example. Here's a summary.      Allocating an array is expensive (in terms of memory and time). In Attempt #1, we created an array using the collect function. The creation was why this took so much time.     BigInts and Int128 are slower than Int64 s. We noticed that switching from Int64 to BigInt in Attempt #2 to #3, there was a significant drop in speed. In short, BigInt s are slow. Only use them when needed.  You should have noticed from the exercise that Int128 is a viable alternative to Int64 if you need larger integers. Int128 is slower than Int64 , but still much better than BigInt . Only use BigInt when you need really large integers.     Sometimes Julia is super smart about some operations. In both Attempt #2 and Attempt #5, we got much shorter times than expected. In both, you would expect summing 1000 times more numbers would take 1000 times longer, but this isn't true. In both cases, Julia recognizes that integers are begin summed and is probably using the formula,     and using this formula can be done for any number with no summing at all.       Computing Fibonacci Numbers   In , there was an exercise to use recursion to find the fibonacci numbers. A possible solution to this is:    fibonacci(n::Integer) = (n==1 || n==2) ? 1 : fibonacci(n-1) + fibonacci(n-2)    where we have used the ternary if-then-else . Note: if n is 1 or 2, then 1 is returned, if not it uses the recursive formula. The first 10 fibonacci numbers are found with    map(fibonacci,1:10)    and this results in the array [1 1 2 3 5 8 13 21 34 55] .  It is fast to find the fibonacci numbers for smaller values, but consider    @time fibonacci(45)    took 3.149046 seconds. If we find @time fibonacci(46) , it takes about 60% longer. To determine what's going on, consider fibonacci(5) . Inside the function, it calls fibonacci(4) and fibonacci(3) . Each of these then called the previous two. This can be seen in the following tree graph where is the fibonacci function:   A tree graph that shows how the recursive fibonacci numbers are created.      Since each of the endpoints (either or ) requires and evaluation as does each arrow, there are a total of 13 evaluations for this. If we define:   function fibonacciEval(n::Integer) global num_evals if n==1 || n==2 num_evals +=1 return 1 else num_evals += 2 return fibonacciEval(n-1) + fibonacciEval(n-2) end end   then  num_evals=0  fibonacciEval(5)  num_evals    returns 13 . Also    num_evals=0  fibonacciEval(20)  num_evals    returns 20293 and    num_evals=0  fibonacciEval(21)  num_evals    returns 32836 and notice that finding the 21st fibonacci number takes about 60% more operations and therefore would take about this much longer.  Thinking about this result shows that we aren't doing things efficiently. If we have already calculated the 19th and 20th fibonacci numbers, why does it take an extra 60% longer? Basically this is because we aren't saving the results to be reused.    Speeding Up Fibonacci  As we saw above, the standard recursive version of fibonacci function is very slow. in fact, it is  We now attempt to find a faster version. The following is a fibonacci function that uses a for loop:   function fibonacci2(n::Integer) local x,y = (1,1) for i = 1:n-1 x,y = (y, x+y) end x end   and note that there is no recursive call. Instead, we use a tuple to iterate pairs of numbers (x,y) which get updated each time through the for loop. Notice on line 2, this initializes the fibonacci sequence and line 4 is the key to this. x takes on the value of y and then y is the sum of the previous two integers.  You should run this and if you do, note that @time fibonacci2(100) returns  0.000000 seconds  3736710778780434371    and clearly obviously much faster than the 45th fibonacci number with the original function. The exercise below explores the fibonacci2 function.     Determine which fibonacci number results in an overflow for Int64 . Do this by trial and error with the fibonacci2 function.    Rewrite the fibonacci2 function to return a BigInt version if is greater than or equal to the number in #1.    Find the first 200 fibonacci numbers.       "
},
{
  "id": "ch-fast-code-2",
  "level": "2",
  "url": "ch-fast-code.html#ch-fast-code-2",
  "type": "Objectives",
  "number": "8",
  "title": "",
  "body": "   Introduction to timing code and doing comparisons between code that gets the same results.    Understanding why code takes longer than other code.    Comparing recursive and non-recursive code in terms of number of function evaluations.    "
},
{
  "id": "ch-fast-code-8-7",
  "level": "2",
  "url": "ch-fast-code.html#ch-fast-code-8-7",
  "type": "Check Your Understanding",
  "number": "8.1",
  "title": "",
  "body": "Repeat Attempts #1--#4 for Int128 . That is, make sure that the calculations are being done using this type. For the for loops, start with   local sum = Int128(0)   and for the reduce function use Int128(n) instead of big(n) . Compare your results with those above. "
},
{
  "id": "fig-fibonacci-tree-graph",
  "level": "2",
  "url": "ch-fast-code.html#fig-fibonacci-tree-graph",
  "type": "Figure",
  "number": "8.2",
  "title": "",
  "body": " A tree graph that shows how the recursive fibonacci numbers are created.     "
},
{
  "id": "sect-fast-fibonacci-7",
  "level": "2",
  "url": "ch-fast-code.html#sect-fast-fibonacci-7",
  "type": "Check Your Understanding",
  "number": "8.3",
  "title": "",
  "body": "   Determine which fibonacci number results in an overflow for Int64 . Do this by trial and error with the fibonacci2 function.    Rewrite the fibonacci2 function to return a BigInt version if is greater than or equal to the number in #1.    Find the first 200 fibonacci numbers.    "
},
{
  "id": "ch-number-theory",
  "level": "1",
  "url": "ch-number-theory.html",
  "type": "Chapter",
  "number": "9",
  "title": "Number theory and Algorithm Development",
  "body": " Number theory and Algorithm Development     Introduction to prime numbers and development of related algorithms.    How and why to benchmark functions in algorithmic development.    Incremental development of the isPrime function using benchmarking.    Using the Primes package to find primes.      This chapter investigates some aspects of Number Theory, which is the study of the integers. Prime numbers are the building blocks of the integers and play a huge role in other fields, like cryptography. We will use this topic as an example of scientific computing. We will look at examples of computational number theory throughout this chapter and then spend some time investigating the efficiency of the code here by formally benchmarking functions.    Prime Numbers  Recall that a prime number is an integer greater than 1 whose only factors are 1 and itself. Most languages have built-in versions of testing for primes, and Julia has a package for this, and we will see it toward the end of this chapter. However, we will start by writing our own versions.  Based on the definition, if we can find the factors of an integer, then we can use it to determine if the number is prime. Also, recall that a number k is a factor of n if mod(n,k) or n % k is 0. For example, 4 is a factor of 24 because mod(24,4) is 0. Thus we can check all integers between 2 and n-1 are factors. Because we are trying to find a subset of all numbers in 1 to n , we will use the filter command seen in .    findAllFactors(n::Integer) = filter(k -> n % k == 0, 1:n)     Type in the function above and test it on various prime and non-prime (composite) numbers.   Use the function above to write a function isPrime that returns true or false depending on if the input is prime.   The template for the function should be    function isPrime(n::Integer)   end    And recall the definition of prime and use that with the findAllFactors function to determine primeness.   We basically want to know if the factors is length 2, thus we can use the following:    isPrime(n::Integer) = length(findAllFactors(n)) == 2       Finding Primes  Now that we have a method that determines whether a number is prime or not, we'll turn to finding prime numbers. Many languages have a function called nextPrime that takes a number as an input and returns a prime number greater than that. Also, you will need to have the isPrime function that you were asked to write in the exercise above. If you haven't done that get the solution above. Before presenting the code, here's some things to think about:     Since we want a function that takes in an integer and returns an integer, here's a good template for our function:    function nextPrime(n::Integer)   end      We will need to test if n+1 is prime (that the smallest possible one).    If n+1 is prime, return it, if not check the next one.    One way to approach this is a loop (probably a while loop because we don't know how many steps to do before finding a prime), but this is another great example of a recursive function.     Here's the result:    nextPrime(n::Integer) = isPrime(n+1) ? n+1 : nextPrime(n+1)    where again, we have used a ternary if-then-else . This first checks if n+1 is prime. If it is return it, if not call nextPrime on the next integer.   Test this function on some numbers that are less than 100 to see if it is working.   Examples may include nextPrime(16) which returns 17 and nextPrime(26) which returns 29    Find the smallest prime less than 1 million.   This is found by entering nextPrime(1_000_000) and returns 1000003 .   Write a function that produces the first n prime numbers and returns those numbers as an array.   The template for this will look like:    function getPrimes(n::Integer)   end    and there are many ways to accomplish this. One includes using filter on the numbers 2:n . Secondly, one might start with the empty array [] and using a while loop, call nextPrime until an index reaches n .   Using the filter method on the numbers 2:n is straightforward in that we can do    filter(isPrime, 2:n)    The while looks is more challenging. We will use an index k and set it to 1 initially and every time through the loop call nextPrime(k) to get the next one. The following function finds the primes:   function getPrimes2(n::Integer) local primes = Int[] local k = 2 while k < n push!(primes, k) k = nextPrime(k) end primes end      Perfect Numbers   A perfect number is an integer, n which has the sum of the factors (except itself) equal to n . For example, 28 is a perfect number because the factors are 1,2,4,7,14,28. The sum of the factors (except itself) is . A nice function would be to check if a number is perfect. Here's a template:    function isPerfect(n::Integer)  # find the factors of n and check the sum  end    The following will go through the steps to look at this. And we will use the function findAllFactors that we wrote above.  First, entering findAllFactors(28) returns the array [1 2 4 7 14 28] . To use the definition of a perfect number, we need to exclude the last element of the array above. One way to do this is to use the pop! function. If we define    A = findAllFactors(28)  pop!(A)  A    then the result is [1 2 4 7 14] . Then we can test if the sum is 28 by sum(A)==28 .  We can put all of this together as the function.   function isPerfect(n::Integer) A=findAllFactors(n) pop!(A) sum(A)==n end   We should also test this. We know that 6 and 28 are perfect, so isPerfect(6) returns true and isPerfect(28) returns true . Many other integers are not perfect, so isPerfect(10) and isPerfect(100) both return false .  Although there is nothing wrong with the above function, we can shorten it a bit by not removing the last element of the array. Note that if we sum all of the factors of a perfect number , the sum will be . The following is alternative way to do this.    isPerfect2(n::Integer) = sum(findAllFactors(n)) == 2n    Note that in the function at the end is 2n , which has a implicit multiply in there. If you multiply any variable on the left with a numerical literal (that is a number, not a variable that is a number), then multiply is implied.    Timing the two functions and the BenchmarkTools package  An objective way to determine which of the two functions is better is to test if one is faster. Let's test if 10,000 is perfect or not. Using @time on both of these. First, @time isPerfect(100_000) returns    0.000117 seconds (4 allocations: 528 bytes)   false    And running @time isPerfect2(100_000) returns    0.000118 seconds (4 allocations: 528 bytes)   false    These both seem to return about the same time, but trying running each of these a number of times. You'll notice that since the time is fairly short, the results bounce around quite a time. This is common for functions that don't take much time.  We'll examine the BenchmarkTools package. Recall that you need to add it using the package manager described in . Once you have added the package, we'll need to tell Julia that we're using it by    using BenchmarkTools    And this package has the macro @btime , which is much like the @time macro, however is much more accurate in that it runs the code a few times, reporting the average results. Running @btime isPerfect(100_000) takes a few seconds then reports    180.292 μs (4 allocations: 528 bytes)   false    returns (and you'll notice it takes a while)  and running @btime isPerfect2(100_000) returns.    181.000 μs (4 allocations: 528 bytes)   false    Note that the is microseconds where 1 is one-millionth of a second or seconds. If you rerun each of these a few times, you'll get consistent results and times. That's the point of the package BenchmarkTools . It runs the code many times and returns an average time.  About the results, since both versions of the isPerfect function are nearly identical, you may want to check a wider range of numbers (try this for numbers in the millions) to see if there is a difference. If you find there is virtually no difference between the functions, typically go with the one is that easier to understand (this is often the shorter one, but not always).     Happy Numbers   Here's another fun example. A positive integer is called happy if you perform the following steps:     Take the digits of and square each one.    Sum the squares.    If the sum is 1, then the number is happy. If not repeat these steps.     Note: it's also helpful that if this process results in the number 4, then you can never result in a sequence that reaches 1. You can call these number unhappy . Here's some examples:     13 is happy because and , so the result ends in 1.    The number 19 is also a happy number because , then , then , then .    The number isn't happy because      , then     , then     , then     , then     , then     , then     , then          and since we have returned to 4, this will continue cycling, so we stop and say 4 is unhappy . Any number in this sequence is unhappy as well. (It has been proven that any unhappy number will eventually hit this cycle.)       Computing Happy Numbers in Julia  Julia has a built-in function to take a number and split the digits called digits . For example digits(1234) returns [4 3 2 1] , where the position in the array is the digit in the corresponding place in the number. For example, the 4 in the first slot in the array is the ones digit and the 1 is the thousands digit (since it is element 4 of the array).  Next, let's write a function called isHappy which determines if a number n is happy. The function should be recursive and return true if it is 1, return false if it is 4 and do the steps above otherwise.  We will find a function that takes in a single integer and outputs a boolean. Our first attempt will be with a loop. We need to go through the digits, square the numbers and find the sum. We can do this as   function isHappy(n::Integer) if n==1 return true elseif n==4 return false else local d = digits(n) local sum = 0 for i=1:length(d) sum += d[i]^2 end return isHappy(sum) end end   Here's a few things to note:     Since we want a recursive function we call isHappy inside the function.    Also since it is recursive, we need to make sure that there is a way to stop the recursion. This occurs in the first two parts of the if statement.    The for loop between lines 9 and 11 sum the squares of each of the digits.    the return isHappy(sum) statement on line 12 calls the function recursively on the sum of the digits.     Try running the isHappy code on many positive integers.    Alternative forms  We can shorten the last block of code into the following:   function isHappy2(n::Integer) if n==1 return true elseif n==4 return false else return isHappy2(sum(x->x^2,digits(n))) end end   where instead of using a for loop, we sum the squares of an array using the sum command.  Lastly, we can write this as a one-liner again using the ternary if-then-else (but in this case, it is nested as    isHappy3(n::Integer) = n == 1 ? true : n == 4 ? false : isHappy3(sum(x->x^2,digits(n)))    and unless you're strange (like me) and like such if-then-else statements, this is much less readable.   Test the three versions of isHappy presented here using the macro @btime from the package BenchmarkTools to see if there is a difference in speed.   For all of these we use (somewhat arbitrarily) n=1_234 . @btime isHappy(n) returns 901.786 ns , @btime isHappy3(n) returns 890.957 ns and @btime isHappy3 returns 892.196 ns . These are all within 0.5% of each other, so basically identical.     Finding Happy numbers  One way to find happy numbers then is check a range of integers using the function you wrote above. For example, you can type    [isHappy(n) for n=1:100]    which will return an array of true\/false if the number is happy or not. Try running it. Note that if you have an array of booleans, Julia returns 0 as false and 1 as true.  This isn't so helpful. If your look down through the list, it's hard to tell which numbers are happy and which are not. A better way to do this is to use Julia's built-in function filter that we saw in . For example,    filter(isHappy, 1:100)    returns all integers between 1 and 100 that are happy or the array [1 7 10 13 19 23 28 31 32 44 49 68 70 79 82 86 91 94 97 100]   We saw the filter command with an array, but you can also use it with a range as shown above.     Primes can be big!!  According to Wikipedia See https:\/\/en.wikipedia.org\/wiki\/Largest\\_known\\_prime\\_number . , the largest prime number has 24,862,048 digits and was found in 2018. The prime is It is interesting in that as of writing this (September 2024), this is still the largest. I'm sure people are looking for larger ones, but haven't found one in 6 years. .  The number is prime. However, if we type 2^89-1 into Julia, we get -1 . Does this imply that ? Recall that the problem with this is that does not fit into Int64 and we are getting an overflow error without being informed. You would need at least 89 bits to store this number, so it could be stored as a Int128 .  As we saw in an earlier chapter, we can use BigInt so    n = big(2)^89-1    will give 618970019642690137449562111 . However, don't throw this at your isPrime function because it will not complete this because we have used a fairly bad algorithm for finding factors or testing for primality. We spend most of the rest of this chapter improving our algorithm to find primes.    Speeding up isPrime   Let's time the isPrime function that you wrote above on a reasonable-sized number. With  isPrime(n::Integer)= length(findAllFactors(n))==2      @btime isPrime(1_000_003)    and the results show that it takes 1.098 ms to complete.  Although this may not seem slow, 1 million is small if you are studying prime numbers and as we saw in the previous section, they get large fast. The reason this is slower is because isPrime relies on the findAllFactors function which checks every every number between 2 and to see if it is a factor. This is very inefficient, so we will try some ways to speed things up.    Speedup #1: Use a For loop  When we wrote findAllFactors above, we used the filter command, however, that may not have been the most efficient. Sometimes writing a for loop is faster. Let's try. First, we know that both 1 and n are already factors, so we don't need to check those so within the for loop, we will test if all numbers between 2 and are factors in the following function.   function findAllFactors2(n::Integer) local factors = [1] for i=2:n-1 if n % i ==0 push!(factors,i) end end push!(factors,n) # n is always a factor of itself end   Although above, we were testing the speed of isPrime , let's compare the speed of findAllFactors versus findAllFactors2 on a reasonably large number. @btime findAllFactors(49_000_000) returns 55.202 ms and @btime findAllFactors2(49_000_000) returns 30.688 about 45% faster. Therefore, this seems like a good move and let's write a new isPrime function based on this.    isPrime2(n::Integer) = length(findAllFactors2(n)) == 2    and if we time it with the same input as above as @btime isPrime2(1_000_003) we get 624.208 μs , which is about 45% faster than isPrime for this number.    Speedup #2: Rewrite findAllFactors to stop earlier  In the function findAllFactors2 we go to to check for a factor. There's actually no reason to do this. For example, consider , the factors are (and you can check this) are . The second largest factor is at most half of the value . Let's consider then the following   function findAllFactors3(n::Integer) local factors = [1] for i=2:n÷2 if n % i ==0 push!(factors,i) end end push!(factors,n) end   where n÷2 is integer division. You will see in an exercise why we don't do n\/2 .  To check the efficiency of this method @btime findAllFactors3(49_000_000) takes 15.312 ms to return the array, which is about 50% faster than findAllFactors2 for the same input. Note that this is precisely half the time because we are checking half of the numbers. Although this example is fast, if it take half the time and this is repeated many times, like many algorithms may include, then this will be quite helpful.  We could then define a new isPrime function to use this instead.    isPrime3(n::Integer) = length(findAllFactors3(n))==2    If we run @btime isPrime3(1_000_003) we get this completing in 312.083 μs which runs in about 50% faster than the isPrime2 function.    Speedup #3: Rewrite findAllFactors to not check all integers as factors  Notice that in both of the cases, we go through of the integers up to or , whereas that isn't necessary because most of the time, factors come in pairs. Consider , We can write the factors in the following way:    1  2  4  5  8  10    200  100  50  40  25  20    and there are pairs of factors and unless the number is a perfect square, they always occur in pairs. For example, when , the factors are    1  2  4  5  10    100  50  25  20    and the factor 10 doesn't have a pair.   function findAllFactors4(n::Integer) local x = round(Int,sqrt(n)) # closest integer to sqrt(n) local factors = [1,n] local j=2 # keep track where to insert elements for k=2:x if n%k==0 # Insert the new factors in the middle of the factors array. # If k^2 is n, just add k, otherwise add the pairs. splice!(factors,j:(j-1),k^2 == n ? [k] : [k,div(n,k)]) j+=1 end end factors end   and notice that if we try to evaluate time this with @btime findAllFactors4(49_000_000) the function finishes in 7.375 μs , more than 1000 times faster than the findAllFactors3 function. Because the loop goes up to , instead of , then for a number like 49 million, you get a huge speed increase.  Since we really want to test the speed of an isPrime function, let's write:    isPrime4(n::Integer) = length(findAllFactors4(n))==2    and now @btime isPrime4(1_000_003) returns 632.396 ns where ns is nanoseconds. Comparing this to the original isPrime , this is about 2000 times faster and about 500 times faster than version 2.    Speedup #4: Don't use findAllFactors at all  If we are only interested with determining if a number is prime or not, we don't really need to calculate all of the factors. Let's start with the findAllFactors4 function, which seems fast, but we will get rid of the array. Consider the following:   function isPrime5(n::Integer) for k=2:floor(Int,sqrt(n)) # integer nearest sqrt(n) if n%k==0 # if k is a factor of n return false end end true end   In short, this function goes through all integers between 2 and . If it finds a factor, it just returns false. If instead, no integers were factors, it returns true. Timing this function with @btime isPrime4(1_000_003) results in finishing in 644.707 ns . This is just a slight speed up from isPrime4 , but a speed up nonetheless.    Speedup #5: Don't do unnecessary calculations  One thing I noticed while writing this function is that the for loops goes through all numbers up to . A quick way to eliminate many of these is to check 2 then all odds between 3 and . This is because if isn't a factor of , then any even cannot be either. Here's a way to do that.   function isPrime6(n::Integer) if n == 1 return false elseif n == 2 return true elseif n%2==0 return false end for k=3:2:floor(Int,sqrt(n)) # odd integers to sqrt(n) if n%k==0 return false end end true end   and checking the time on this with @btime isPrime6(1_000_003) results in a time of 311.029 ns , about twice as fast as isPrime5 , which is expected since it only checks half of the numbers.    Speedup #6: check only primes as possible factors  We can continue the thought of the previous algorithm in that the only factors we need to check are prime numbers.  However, there's a bit of circular reasoning here that we are checking to see if a number is prime and we would use primes to check this, but here goes.  An exercise above asked to generated a list of primes up to some number. The Sieve of Eratosthenes is one that generates a list of primes up to a number in the following way.     Write down all numbers between 2 and .    Start with 2 and cross out all multiples of 2.    The next number greater than 2 not crossed out is 3. Cross out all multiples of 3.    The next number greater than 3 not crossed out is 5.Cross out all multiples of 5.    Continue this process until you reach .    The resulting list are all prime.     See the animation on the wikipedia page linked above for a nice visual.  Here's a Julia version of this algorithm:   function getPrimes(m::Integer) ## return all primes up to n using # the sieve of Eratosthenes local is_prime=trues(m) ## assume all are prime local k=2 while k < sqrt(m) is_prime[2*k:k:m] .= false # all multiples of k are not prime k = nextPrime(k+ (k==2 ? k=1 : k+2)) # find the next prime after k and they will all be odd after k= 2 end findall(is_prime)[2:end] end   and for example, getPrimes(100) returns the array [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]   Now, we can adapt the isPrime code to use only primes in the following way:   function isPrime7(n::Integer) if n==1 return false end # get all primes up to the square root of n for k in getPrimes(floor(Int,sqrt(n))) if n%k==0 return false end end true end   Lastly, let's just test the speed of this function:    @btime isPrime7(1_000_003)    which takes 3.453 μs and is about 10 times slower than isPrime6 . This probably has to do with the fact that the first number of primes must be generated. Below we will test with a larger number to see if this pays off for testing larger primes.     Summary of isPrime  Since this was all a lot to take in, let's summarize all of these functions. We'll stick with n=1_000_000_007 , which is a prime number   Summary of isPrime timing    command  time    @btime isPrime(n)  1.132 s    @btime isPrime2(n)  631.973 ms    @btime isPrime3(n)  315.827 ms    @btime isPrime4(n)  20.167 μs    @btime isPrime5(n)  19.750 μs    @btime isPrime6(n)  9.833 μs    @btime isPrime7(n)  112.959 μs     It appears that isPrime6 is the fastest of the algorithms we developed here. Note that this just checks for a single number, whereas, the values may change as one increases the value of n.    Testing for Primes using the Primes  Load the Primes library (and if you haven't added it yet, do so):    using Primes    The Primes library has the isprime function to test for primality. Let's test a few examples.    @btime isprime(1_000_000_007)    returns the answer in 702.833 ns and this is about ten times faster than our fastest algorithm, isPrime6 . Note that the time is given in ns or nanoseconds and 1000 nanoseconds is 1 s.  Note that the isprime function is quite fast. If we put in , it still finds the answer quite quickly.    @btime isprime(big(2)^89-1)    returns the answer in 9.875 μs . I tried to run isPrime6 on and it ran overnight and didn't finish.   "
},
{
  "id": "ch-number-theory-2",
  "level": "2",
  "url": "ch-number-theory.html#ch-number-theory-2",
  "type": "Objectives",
  "number": "9",
  "title": "",
  "body": "   Introduction to prime numbers and development of related algorithms.    How and why to benchmark functions in algorithmic development.    Incremental development of the isPrime function using benchmarking.    Using the Primes package to find primes.    "
},
{
  "id": "ch-number-theory-4-5",
  "level": "2",
  "url": "ch-number-theory.html#ch-number-theory-4-5",
  "type": "Check Your Understanding",
  "number": "9.1",
  "title": "",
  "body": " Type in the function above and test it on various prime and non-prime (composite) numbers.   Use the function above to write a function isPrime that returns true or false depending on if the input is prime.   The template for the function should be    function isPrime(n::Integer)   end    And recall the definition of prime and use that with the findAllFactors function to determine primeness.   We basically want to know if the factors is length 2, thus we can use the following:    isPrime(n::Integer) = length(findAllFactors(n)) == 2    "
},
{
  "id": "ch-number-theory-5-7",
  "level": "2",
  "url": "ch-number-theory.html#ch-number-theory-5-7",
  "type": "Check Your Understanding",
  "number": "9.2",
  "title": "",
  "body": " Test this function on some numbers that are less than 100 to see if it is working.   Examples may include nextPrime(16) which returns 17 and nextPrime(26) which returns 29    Find the smallest prime less than 1 million.   This is found by entering nextPrime(1_000_000) and returns 1000003 .   Write a function that produces the first n prime numbers and returns those numbers as an array.   The template for this will look like:    function getPrimes(n::Integer)   end    and there are many ways to accomplish this. One includes using filter on the numbers 2:n . Secondly, one might start with the empty array [] and using a while loop, call nextPrime until an index reaches n .   Using the filter method on the numbers 2:n is straightforward in that we can do    filter(isPrime, 2:n)    The while looks is more challenging. We will use an index k and set it to 1 initially and every time through the loop call nextPrime(k) to get the next one. The following function finds the primes:   function getPrimes2(n::Integer) local primes = Int[] local k = 2 while k < n push!(primes, k) k = nextPrime(k) end primes end   "
},
{
  "id": "ch-number-theory-6-2-1",
  "level": "2",
  "url": "ch-number-theory.html#ch-number-theory-6-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "perfect number "
},
{
  "id": "ch-number-theory-7-3-8",
  "level": "2",
  "url": "ch-number-theory.html#ch-number-theory-7-3-8",
  "type": "Check Your Understanding",
  "number": "9.3",
  "title": "",
  "body": "Try running the isHappy code on many positive integers. "
},
{
  "id": "ch-number-theory-7-4-8",
  "level": "2",
  "url": "ch-number-theory.html#ch-number-theory-7-4-8",
  "type": "Check Your Understanding",
  "number": "9.4",
  "title": "",
  "body": " Test the three versions of isHappy presented here using the macro @btime from the package BenchmarkTools to see if there is a difference in speed.   For all of these we use (somewhat arbitrarily) n=1_234 . @btime isHappy(n) returns 901.786 ns , @btime isHappy3(n) returns 890.957 ns and @btime isHappy3 returns 892.196 ns . These are all within 0.5% of each other, so basically identical.  "
},
{
  "id": "ch-number-theory-10-3",
  "level": "2",
  "url": "ch-number-theory.html#ch-number-theory-10-3",
  "type": "Table",
  "number": "9.5",
  "title": "Summary of <code class=\"code-inline tex2jax_ignore\">isPrime<\/code> timing",
  "body": " Summary of isPrime timing    command  time    @btime isPrime(n)  1.132 s    @btime isPrime2(n)  631.973 ms    @btime isPrime3(n)  315.827 ms    @btime isPrime4(n)  20.167 μs    @btime isPrime5(n)  19.750 μs    @btime isPrime6(n)  9.833 μs    @btime isPrime7(n)  112.959 μs    "
},
{
  "id": "ch-algorithm-analysis",
  "level": "1",
  "url": "ch-algorithm-analysis.html",
  "type": "Chapter",
  "number": "10",
  "title": "Algorithm Analysis",
  "body": " Algorithm Analysis     Define the big-O notation and explain how it is used in analyzing algorithms.    Performing big-O analysis on some algorithms.    Using data tools to determine the order of an algorithm by running code for a set of different parameters.      This chapter will be a brief introduction to the analysis of algorithms. As we have already seen in the past couple of chapters, timing algorithms is a decent way to determining how well they run, however sometimes a more in-depth analysis is needed. We will cover what is called big-O notation and analyze a few algorithms here.    Big-O Notation    Consider two functions and , We say that is or ``big-O'' of if for some .    For example, let . This function is because     Generally, if a function is polynomial, the function is where is the degree of polynomial.   For each of the following functions find , that is find :       Hint: recall L'Hopital's rule for derivatives and try to find the largest term of the given function.             Polynomial Evaluation   An example that we will see again in , it that of evaluating a polynomial. If     If we evaluate the polynomial as is counting powers as repeated multiplication, then the number of additions is and the number of multiplication is     This shows that polynomial evaluation is since .    Horner's Form  We can rewrite as     In this case, there are additions and multiplications. So you could say that the total number of operations are where and are constants related to addition and multiplication. Overall, this means that the order of polynomial evaluation using Horner's method is .    Benchmarking Polynomial Evaluation   Let's actually see some actual data in this. First, the polynomial evaluation can be written as   function poly1(coeffs::Vector{T}, x::S) where {T <: Number, S <: Number} local sum = zero(T) function pow(x::T,n::Int) where T <: Number local prod = one(T) for j=1:n prod *=x end prod end for n=1:length(coeffs) sum += coeffs[n]*pow(x,n-1) end sum end   where the where {T <: Number, S <: Number} will be explained in , but this allows any subtype of Number to be taken. Also, we have defined the power to be repeated multiplication using a for loop, since Julia's power function is quite efficient--we want to show the results from above.  To test this, first we will use BigFloat s as the coefficients to slow down the operations a bit, otherwise it is hard to measure the time.  Let's do some testing and we'll need the BenchmarkTools and CairoMakie (for plotting). We also need Random to set the seed and LsqFit to fit the data we'll generate to a curve.  using BenchmarkTools, CairoMakie, Random, LsqFit  CairoMakie.activate!()  Random.seed!(132)     There are a few plots in this section and we will be using a package called Makie to do the plots. We will explore this in detail in , however, copying the code to produce the plots is sufficient for this chapter.   The following will time using the @belapsed macro which returns the amount of time a function takes given in seconds. This is needed because we need to store the result. Note that in the previous chapters we've used the @btime macro which times the function and gives additional information as well as the return value. We are only interested in the amount of time in this section.    time = zeros(351)  r = 1:50:351  for i=r  coeffs = rand(i+1)  time[i] = @belapsed poly1($coeffs,1\/3)  end    which will take quite a bit time. After this runs, if we create a scatter plot with    fig, ax = scatter(r,time[r])       (for accessibility)    Hopefully visually you can see that it appears to be nonlinear and perhaps you can see that it is may be quadratic. We will fit a quadratic to these points by first defining the model as a quadratic:    model(t, p) = @. p[1]+p[2]*t+p[3]*t^2    where broadcasting using @. that was explained in and then fit the data to the model with:    fit = curve_fit(model, r, time[r], [1e-8,1e-8,1e-8])    and note that the output will not be particularly helpful. What we are looking for are the best-fit parameters and these can be found with fit.param and the results are    3-element Vector{Float64}:  6.636565666123923e-7  -3.7652064597589e-8  6.108561075647983e-10    These are all small, however, the important thing to determine is if they are possibly zero. We can use the confidence interval of each is found with confidence_interval(fit, 0.05) which returns    3-element Vector{Tuple{Float64, Float64}}:  (-8.762753517690063e-7, 2.203588484993791e-6)  (-5.8097027280678223e-8, -1.7207101914499782e-8)  (5.549847084532201e-10, 6.667275066763765e-10)    These show the 95%-confidence intervals for the three parameters. We are looking for the largest non-zero term, which is the third one. Since the above fits all three terms, we will redo the fit with only the third term as    model2(t,p) = @. p[1]*t^2    and then fit the data with  fit2 = curve_fit(model2, r, time[r], [1.0])    We can add the curve to the plot above with:  lines!(ax, 0:225,t->fit2.param[1]*t^2)    which is the following plot     (for accessibility)    and although it doesn't look like a perfect fit, it does appear to be quadratic.    Horner's Form  We will compare this to Horner's form, which we can write in Julia as:   function horner(coeffs::Vector{T},x::S) where {T <: Number, S <: Number} local result = coeffs[end] for i=length(coeffs)-1:-1:1 result = x*result+coeffs[i] end result end   and then similar to above, we will time this method for different lengths:   htime = zeros(351) r = 1:50:351 for i=r coeffs = rand(i) htime[i] = @belapsed horner($coeffs,10\/3) end   and plot the results:    scatter(r,htime[r])    which results in     (for accessibility)    and this look much more linear than the previous one. For this model, we'll fit a linear function.    fit3 = curve_fit((t,p) -> p[1].*t, r, htime[r], [1e-8])    and if you're interested in the value of the parameter (slope of the line), fit3.param returns 1.8253874361922209e-9 . Looking at it visually, let's add the plot of the line to the scatter plot above with    lines!(ax, 1:360, t->fit3.params[1]*t)    and this results in the following plot:     (for accessibility)    Overall, these results show that the time taken to evaluate a polynomial using Horner's form, is . This evidence shows that Horner's form of the polynomial is much faster and putting these two scatter plots together with:    fig, ax = scatter(r, time[r])  scatter!(ax, r, htime[r])  fig    and the results are     (for accessibility)        Interpreting big-O results  Typically algorithms grows as some function of , which is a measure of the size of the problem. Determining the order of the algorithm can be tricky although we can use numerics like above to find the timing of algorithms for various sizes of the problem. Then doing some data-fitting, we can often find the order of the algorithm. We'll see another example of this in the next section.  Understanding different orders is helpful and this means understanding how functions grow. Here are a bunch of standard algorithm functions and their plots:   fig = Figure() ax = Axis(fig[1,1]) pl1 = lines!(ax, 1:0.05:10, x->log(x)) pl2 = lines!(ax, 1:0.05:10, x->x) pl3 = lines!(ax, 1:0.05:10, x->x*log(x)) pl4 = lines!(ax, 1:0.05:10, x->x^2) pl5 = lines!(ax, 1:0.05:10, x->x^2*log(x)) axislegend(ax, [pl1,pl2,pl3,pl4,pl5], [\"ln(n)\",\"n\",\"n ln(n)\",\"n^2\",\"n^2 ln(n)\"], position = :lt ) fig   And the result is     (for accessibility)    This would basically show that if there are choices of algorithms, to use an algorithm with a lower order in that for large values of problem size will run faster.    Using Data to determine Algorithm order  Typically, the best way to analyze an algorithm is to determine the number of operations as a function of , however, let's look at this as a data analysis problem. As an example, we'll look at this as the Fast Fourier Transform, discussed in Chapter \\ref{ch:complex}. This is a classic example of improving an algorithm to change the order. For this we need the FFTW package, which you probably need to add and   using FFTW   Let's first build up a set of times similar to above with   times3 = Float64[] sizes3 = [2^n for n=10:18] for size in sizes3 x=rand(size) t = @belapsed fft($x) push!(times3,t) end   which calculates the FFT for sizes 2^10 to 2^18 and stores the results in the variable times . Then, let's plot the results with    scatter(sizes3,times3, legend = false)    which results in the plot     (for accessibility)    Since it appears to be growing more that linearly, let's try the functions t*log(t) and t^2 . Fitting a curve to both of these is    fit_fft = curve_fit((t,p) -> p[1].*t.*log.(t)+p[2].*t.^2,sizes3, times3, [1e-4,1e-4])    and a confidence interval of the parameters are found with confidence_interval(fit_fft) resulting in    2-element Vector{Tuple{Float64, Float64}}:  (6.879894218252294e-10, 7.990430330357398e-10)  (2.557195884568105e-15, 8.361319348915151e-15)    Although both are exclusively positive, the second interval is nearly zero--values near are often actually 0 and just due to roundoff error. Therefore, we will only use the first term in the model or . Trying a new function fit with    fit_fft2 = curve_fit((t,p) -> @. p[1]*t*log(t), sizes3, times3, [1e-4])    The confidence interval of the parameters is found with confidence_interval(fit3) and the results are    1-element Vector{Tuple{Float64, Float64}}: (8.197426904649365e-10, 8.695061786080083e-10)    Lastly, we plot the data and the best fit function found above with    fig, ax = scatter(sizes3, times3)  lines!(ax, 0:10^4:3*10^5, x->fit_fft2.param[1]*x*log(x))  fig      plot!(t->fit3.param[1]*t*log(t),first(sizes3),last(sizes3))    And the resulting plot is:   Find a point on a line that minimizes distance     This shows using some data analysis that the FFT is , which can also be shown use analysis of the algorithm, but requires knowledge of how the algorithm works.   "
},
{
  "id": "ch-algorithm-analysis-2",
  "level": "2",
  "url": "ch-algorithm-analysis.html#ch-algorithm-analysis-2",
  "type": "Objectives",
  "number": "10",
  "title": "",
  "body": "   Define the big-O notation and explain how it is used in analyzing algorithms.    Performing big-O analysis on some algorithms.    Using data tools to determine the order of an algorithm by running code for a set of different parameters.    "
},
{
  "id": "def-big-o",
  "level": "2",
  "url": "ch-algorithm-analysis.html#def-big-o",
  "type": "Definition",
  "number": "10.1",
  "title": "",
  "body": "  Consider two functions and , We say that is or ``big-O'' of if for some .   "
},
{
  "id": "ch-algorithm-analysis-4-6",
  "level": "2",
  "url": "ch-algorithm-analysis.html#ch-algorithm-analysis-4-6",
  "type": "Check Your Understanding",
  "number": "10.2",
  "title": "",
  "body": " For each of the following functions find , that is find :       Hint: recall L'Hopital's rule for derivatives and try to find the largest term of the given function.          "
},
{
  "id": "ch-algorithm-analysis-5-4-2-6",
  "level": "2",
  "url": "ch-algorithm-analysis.html#ch-algorithm-analysis-5-4-2-6",
  "type": "Remark",
  "number": "10.3",
  "title": "",
  "body": " There are a few plots in this section and we will be using a package called Makie to do the plots. We will explore this in detail in , however, copying the code to produce the plots is sufficient for this chapter.  "
},
{
  "id": "fig-poly-eval",
  "level": "2",
  "url": "ch-algorithm-analysis.html#fig-poly-eval",
  "type": "Figure",
  "number": "10.4",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-poly-fit2",
  "level": "2",
  "url": "ch-algorithm-analysis.html#fig-poly-fit2",
  "type": "Figure",
  "number": "10.5",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-poly-fit3",
  "level": "2",
  "url": "ch-algorithm-analysis.html#fig-poly-fit3",
  "type": "Figure",
  "number": "10.6",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-poly-fit4",
  "level": "2",
  "url": "ch-algorithm-analysis.html#fig-poly-fit4",
  "type": "Figure",
  "number": "10.7",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-compare-to-horner",
  "level": "2",
  "url": "ch-algorithm-analysis.html#fig-compare-to-horner",
  "type": "Figure",
  "number": "10.8",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-o-of-n-compare",
  "level": "2",
  "url": "ch-algorithm-analysis.html#fig-o-of-n-compare",
  "type": "Figure",
  "number": "10.9",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-fft",
  "level": "2",
  "url": "ch-algorithm-analysis.html#fig-fft",
  "type": "Figure",
  "number": "10.10",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-algorithm-analysis-7-22",
  "level": "2",
  "url": "ch-algorithm-analysis.html#ch-algorithm-analysis-7-22",
  "type": "Figure",
  "number": "10.11",
  "title": "",
  "body": " Find a point on a line that minimizes distance    "
},
{
  "id": "ch-rootfinding",
  "level": "1",
  "url": "ch-rootfinding.html",
  "type": "Chapter",
  "number": "11",
  "title": "Solving Quadratics and Rootfinding",
  "body": " Solving Quadratics and Rootfinding     Definition of absolute and relative errors.    Definition of a root of a function and the quadratic equation for finding roots of quadratic functions.    Where roundoff errors often occur and how to minimize these in the quadratic formula.    Using Newton's method to find roots.    Using automatic differentiation to simplify Newton's method.    Use the Bisection method to find roots.      Solving an equation is something that is needed throughout scientific computing and is difficult to do in general. For example, if we have an equation like , this can be solved exactly using the quadratic formula, however the relatively simple equation has no analytic solution. In this chapter, we discuss how to find roots of both quadratic functions and general functions, but also use this to discuss both errors in a algorithm as well as round off error, which occurs often when solving problems.    A root of an equation is a number , such that .    For example, if , then both and are roots of the equation.  The definition about saying that a root is a value where and an equation like doesn't fit this form, but recall that the equation can be algebraically manipulated to get to be a root as or .    Absolute and Relative Errors  Consider an algorithm that tries to find the value of . In general, an algorithm won't return the value but a value that is close, therefore there will be some error. The absolute error is and the relative error is   Often, the percent error is helpful as well, which is just the relative error times 100.    Consider an algorithm that returns and the actual answer is . Find both the absolute and relative errors.  The absolute error is and the relative error is or 2%.  We can do this is Julia with    xstar = 0.0150  x = 0.0153  abs(x-xstar)    which returns 0.0002999999999999999 and    abs((x-xstar)\/xstar)    returns 0.019999999999999997     To make thing easier in this chapter, we'll create functions for these:    absErr(x::Real, xstar::Real) = abs(x-xstar)  relErr(x::Real, xstar::Real) = abs((x-xstar)\/xstar)    which now allows us to use absErr(0.153,0.150) and relErr(0.153,0.150) and we get the same results as above.    Rounding Errors and the Quadratic Formula   The following example shows how a well-know formula (the quadratic formula) can lead to incorrect results due to rounding errors.  Remember if you solve , the the quadratic formula finds the solution:   Next, let's consider the quadratic equation     We are going to solve this using the quadratic formula in Julia. To study rounding effects we're going to solve these using both 16-bit and 64-bit floating point numbers. We'll assume that the 64-numbers are the actual answers in determining errors.    Investigating Errors with Code  First, consider the quadratic formula as a Julia function:    function qSol(a::Real, b::Real, c::Real)  d=sqrt(b^2-4*a*c)  (-b+d)\/(2*a), (-b-d)\/(2*a)  end    where we have two values returned as a tuple (note the comma between the values). We can solve the quadratic in with    x64a,x64b = qSol(12.242,42.382,0.0012)    leads to (-2.831413841486606e-5, -3.461987696317393) . Note that since the default floating-point type is Float64 , these are 64-bit results.  To solve this using 16-bit floating-point numbers,    x16a,x16b = qSol(Float16(12.242),Float16(42.382),Float16(0.0012))    leads to (Float16(0.0), Float16(-3.46)) .  Let's assume that the 64-bit answers are correct. Find the absolute and relative errors for the two solutions.  The absolute errors are:    absErr(x16a,x64a) = 2.831413841486606e-5 .     absErr(x16b,x64b) = 0.001050196317392782 .   and the relative errors are:    relErr(x16a,x64a) = 1.0 .     relErr(x16b,x64b)= 0.00030335067871844356 .     The relative error 1 (or 100%) means that the answer is way off. The second answer is quite close though.  Use the quadratic formula to solve using both BigFloat s and 64-bit floats. Assume that the BigFloat versions are exact and find the absolute and relative errors in the 64-bit numbers.    Be skeptical of numerical answers  Even though the example above was manufactured to produce bad results, you never know if a numerical solution is accurate or not. One way to look at the above example is to not use 16-bit floating point numbers. This is a good idea, but assume (like we did above) that 64-bit is the actual answer. There are cases where you will get the wrong answer with 64-bit.    Can we ever be confident of answers?  It's crucial to have a good sense of the problem (whether it be mathematical or a scientific question). Additionally, testing is an important part of the solution process. In , we will spend some time discussing testing of code.     Are We Sunk? Reexamining the Quadratic Formula  The above example shows that even with a well-known formula, there is the potential of generating a large error. From what we've seen so far, we could try to use other data types, like BigFloat to solve this problem, but as we've seen they are slow and we should only use that type when needed.  If we're careful about things, we can rewrite algorithms in certain situations to minimize roundoff. The problem that occurred for the general quadratic equation     is if and when , the formula has , which is basically subtraction. In the case above, and . The difference in these is quite small and that is where the round-off error is introduced.  Let's assume that and let . The roundoff occurs when the value of and are close to each other. (Note: if is negative, you can multiply the entire equation through by to get without changing the answer.) To change the quadratic formula we are going to exchange the addition with a subtraction (however we will not have the catastrophic subtraction error we saw above). \"How can you do that?\" you ask? Here we go...  Start with the quadratic formula for the case:     and there is a similar solution if the root is taken above. Note that we have changed the sign of the term in the top of the standard formula. Basically, this has switched a subtraction (which is prone to roundoff errors) to an addition (which is not prone to roundoff). In Julia, the alternative quadratic formula is:   function qSol2(a::Real,b::Real,c::Real) d=sqrt(b^2-4*a*c) -2*c\/(b+d),(-2*c)\/(b-d) end    Use the new quadratic formula ( qSol2 ) to find the roots of . Do you get the same results as above?   Use the new quadratic formula to solve . Find the absolute and relative errors if we assume that the 64-bit answers are exact and the 16-bit answers are approximate. Compare your results with that of the standard quadratic formula.     Newton's Method   Solving an equation is a very important part of mathematics and other scientific fields. However, finding general solutions to equations is not very easy. Consider a cubic equation like . In the spirit of (but not very simple) the quadratic formula, there is a cubic formula . Much of the wikipedia page spends time solving the cubic with all possibilities. In short, it's not very easy.  In lieu of using such a formula, a more robust approach is to solve it numerically. Let's consider     This cubic actually factors, but finding those factors is quite difficult to do in general. We then look at using Newton's method to solve this. Note the plot below:     (for accessibility)    and the three intersection points between the red curve ( -axis) and the blue line (the function, ) are the three roots.  Newton's method starts with a \"guess\" at the root and then refines it. Let be the guess, then     Let's look at this in Julia for the function above.  f(x)=15x^3-143x^2+226x+280    and we need the derivative so    df(x)=45x^2-286x+226    Let's say that x0=0 and find x1 using Newton's method:    x0 = 0  x1 = x0-f(x0)\/df(x0)    returns -1.238938053097345 . We then use the result and perform another step of Newton's method or    x2 = x1-f(x1)\/df(x1)    this time we get -0.8570123580970569 , seems to be closer looking at the plot above. A few more iterations of this, you should get quite close to -0.8 .    Code for Newton's Method  We are going to go through building a function to do this. First, let's consider the template of the function, which will have an arguments f, df and x0 . Thus a good template is    function newton(f::Function, df::Function, x0::Number)   end    Here are considerations while building the function:     You will need to do the two steps above many times so you will need a loop. Since you don't know how many times you will need to run through the loop use a while loop and your condition should be that the two steps x0 and x1 are apart from each other.    Checking if two floating-point numbers are equal are generally not a good idea, because they have to be equal to all bits, so instead we will run the while loop while the difference in the numbers x0 and x1 are larger than some default (like ).     Here's more a frame of the function:   function newton(f::Function, df::Function, x0::Number) x1 = x0 - f(x0)\/df(x0) while abs(x1-x0) > 1e-6 # while the two numbers are larger than 10^(-6) x0 = x1 x1 = x0 - f(x0)\/df(x0) end x1 end   Using this we can now call this function as    newton(f,df,0)    which returns -0.8000000000000933 .  Just to simplify this, we will define dx as -f(x0)\/df(x0) , which is the distance between successive x values, so we'll use this to determine when to stop the loop:   function newton(f::Function, df::Function, x0::Number) local dx = f(x0)\/df(x0) local x1 = x0 - dx while abs(dx) > 1e-6 dx = f(x1)\/df(x1) x1 -= dx end x1 end   First, we need to define dx first to determine if we need to go into the loop. We just set it to some value to get it started. We have also used the operator -= . Line 6 above or x1 -= dx is shorthand for x1 = x1 - dx   Lastly, note that we have defined a variable x1 , which then is updated within the while loop. You may ask yourself why not just update the value x0 . It is generally good practice to not update the arguments of a function unless you tip off the programmer that you might do this. In Julia, recall that we add a ! to the end of a function name that changes the arguments. If not, there may be unintended consequences resulting in bugs that are hard to track down. We will show examples of this in .    Using Automatic Differentiation  If you have used Computational Algebra Systems like Maple or Mathematica, you know that computers have the ability to differentiate. Julia does not have this capability built-in, although it has some capability of doing some of the feature set of these programs. There is a system called automatic differentiation that will compute the exact derivative to a function at a given point. That is, if you have a function and a number , it will give you . The package is called ForwardDiff and you may need to add it and then    using ForwardDiff    For example, if you define:    g(x) =x^2    to find , type    ForwardDiff.derivative(g,3)    which will return 6 . Try something much more complicated:    ForwardDiff.derivative(x->exp(sin(x^2+pi\/x)),1.0)    which returns 0.2658898634234979 and if you are careful with the derivative (or have access to a Computer Algebra System), see if your answer is correct.    Newton's Method with Automatic Differentiation  With this nice package, let's rewrite Newton's method   function newton(f::Function, x0::Number) local dx = f(x0)\/ForwardDiff.derivative(f,x0) local x1 = x0 - dx while abs(dx) > 1e-6 dx = f(x1)\/ForwardDiff.derivative(f,x1) x1 -= dx end x0 end   And note that if we run this with newton(f,0) we get -0.8000000000000933 the same result as above.   Find the intersection point of the functions and . Hint set the two equations equal and use algebra to write it as a function which is equal to 0.   Use your function above to find all three of the roots of the cubic function, .     Adding an extra stopping condition  One problem that can arise is if you call newton on a function that does not have a root. For example, consider , which is always positive. If you run    newton(x->x^2+1,2)    then you reach an infinite loop. You'll need to interrupt the process.  To prevent this, we need to add a stopping condition if this occurs. One way to do this is to add a counter include in the while loop that the number of steps is small. Here's a possible update to Newton's method:   function newton(f::Function, x0::Number) local dx = f(x0)\/ForwardDiff.derivative(f,x0) local x1 = x0 - dx local steps = 0 while abs(dx) > 1e-6 && steps < 10 dx = f(x1)\/ForwardDiff.derivative(f,x1) x1 -= dx steps += 1 end x1 end   Now if we try:    newton(x->x^2+1,2)    we get 0.001953125 .  Now, this still isn't perfect because when we run it, we only get a single number out. In this case, the value is not a root, but how do you know? We will see in how to develop a new type which stores information about the root and if a solution was reached.     The Bisection Method  In , we saw the bisection method and just presented it as an example of using a while loop. We return to this to further explain the method. If we have a function like and seek to find a root of this Yes, I realize this is an example where we know the answer using algebra, but go with it. . The graph of this on is     (for accessibility)    and note that we are seeking where the curve crosses the -axis. The bisection method requires that we start with an interval that contains the root. In this case, we will use . We know that there is a root of this from the intermediate value theorem which states that a continuous function takes on all values between and , where and are the endpoints of the interval. Since we are seeking a value where , the endpoints must have opposite signs which can be tested by multiplying the values and testing for a negative number or .    Let a and b be an interval such that f(a)*f(b) < 0 . The following uses the bisection method to find a root to within ϵ of the true value .     Test if b-a < ϵ . If so exit the algorithm with the current values of a and b .    Find m=(a+b)\/2 , the midpoint of the current interval.    If f(a)*f(m) < 0 , then the new interval should be or let b=m . Otherwise, the new interval should be so let a=m .    Goto step 1.       As we showed in , this can be written in Julia as   function bisection(f::Function, a::Real, b::Real) local c while (b-a) > 1e-6 c = 0.5*(a+b) # find the midpoint # test if f(a) and f(c) have opposite signs to determine the new interval (a,b) = f(a)*f(c) < 0 ? (a,c) : (c,b) end c end   where we have hard coded ϵ to be 1e-6 . Note also that we have used a tuple to store the interval and have updated the entire interval instead of just one endpoint as the algorithm above states. This is mainly for code clarity. Also, we will update this code to handle other values of ϵ in . Also in that chapter we will test to ensure that the original interval contains the root.  Running the code with x0 = bisect(x -> x^2-2, 1, 2) returns 1.4142141342163086 and absErr(x0, sqrt(2)) returns 5.718432134482754e-7 showing that in fact the error is with .   "
},
{
  "id": "ch-rootfinding-2",
  "level": "2",
  "url": "ch-rootfinding.html#ch-rootfinding-2",
  "type": "Objectives",
  "number": "11",
  "title": "",
  "body": "   Definition of absolute and relative errors.    Definition of a root of a function and the quadratic equation for finding roots of quadratic functions.    Where roundoff errors often occur and how to minimize these in the quadratic formula.    Using Newton's method to find roots.    Using automatic differentiation to simplify Newton's method.    Use the Bisection method to find roots.    "
},
{
  "id": "def-root",
  "level": "2",
  "url": "ch-rootfinding.html#def-root",
  "type": "Definition",
  "number": "11.1",
  "title": "",
  "body": "  A root of an equation is a number , such that .   "
},
{
  "id": "ch-rootfinding-4-2",
  "level": "2",
  "url": "ch-rootfinding.html#ch-rootfinding-4-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "absolute error relative error "
},
{
  "id": "ch-rootfinding-4-3",
  "level": "2",
  "url": "ch-rootfinding.html#ch-rootfinding-4-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "percent error "
},
{
  "id": "ch-rootfinding-4-4",
  "level": "2",
  "url": "ch-rootfinding.html#ch-rootfinding-4-4",
  "type": "Example",
  "number": "11.2",
  "title": "",
  "body": "  Consider an algorithm that returns and the actual answer is . Find both the absolute and relative errors.  The absolute error is and the relative error is or 2%.  We can do this is Julia with    xstar = 0.0150  x = 0.0153  abs(x-xstar)    which returns 0.0002999999999999999 and    abs((x-xstar)\/xstar)    returns 0.019999999999999997    "
},
{
  "id": "ch-rootfinding-5-3-13",
  "level": "2",
  "url": "ch-rootfinding.html#ch-rootfinding-5-3-13",
  "type": "Check Your Understanding",
  "number": "11.3",
  "title": "",
  "body": "Use the quadratic formula to solve using both BigFloat s and 64-bit floats. Assume that the BigFloat versions are exact and find the absolute and relative errors in the 64-bit numbers. "
},
{
  "id": "ch-rootfinding-6-11",
  "level": "2",
  "url": "ch-rootfinding.html#ch-rootfinding-6-11",
  "type": "Check Your Understanding",
  "number": "11.4",
  "title": "",
  "body": " Use the new quadratic formula ( qSol2 ) to find the roots of . Do you get the same results as above?   Use the new quadratic formula to solve . Find the absolute and relative errors if we assume that the 64-bit answers are exact and the 16-bit answers are approximate. Compare your results with that of the standard quadratic formula.  "
},
{
  "id": "fig-rootfinding-cubic",
  "level": "2",
  "url": "ch-rootfinding.html#fig-rootfinding-cubic",
  "type": "Figure",
  "number": "11.5",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "sect-newton-4-2",
  "level": "2",
  "url": "ch-rootfinding.html#sect-newton-4-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "automatic differentiation "
},
{
  "id": "sect-newton-5-5",
  "level": "2",
  "url": "ch-rootfinding.html#sect-newton-5-5",
  "type": "Check Your Understanding",
  "number": "11.6",
  "title": "",
  "body": " Find the intersection point of the functions and . Hint set the two equations equal and use algebra to write it as a function which is equal to 0.   Use your function above to find all three of the roots of the cubic function, .  "
},
{
  "id": "fig-root-xsq",
  "level": "2",
  "url": "ch-rootfinding.html#fig-root-xsq",
  "type": "Figure",
  "number": "11.7",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "alg-bisect",
  "level": "2",
  "url": "ch-rootfinding.html#alg-bisect",
  "type": "Algorithm",
  "number": "11.8",
  "title": "",
  "body": "  Let a and b be an interval such that f(a)*f(b) < 0 . The following uses the bisection method to find a root to within ϵ of the true value .     Test if b-a < ϵ . If so exit the algorithm with the current values of a and b .    Find m=(a+b)\/2 , the midpoint of the current interval.    If f(a)*f(m) < 0 , then the new interval should be or let b=m . Otherwise, the new interval should be so let a=m .    Goto step 1.      "
},
{
  "id": "ch-comp-types",
  "level": "1",
  "url": "ch-comp-types.html",
  "type": "Chapter",
  "number": "12",
  "title": "Creating New Data Types in Julia",
  "body": " Creating New Data Types in Julia     One can create a new user-define data type or struct .    Creation of a Card and Hand data type to model a playing card.    When creating a new data type, use the new command in constructors.    Displaying a Data Type with the show command for clarity.    Developing a Polynomial and Root datatype and applying existing methods like addition and subtraction on a user-defined type.      Although there are many standard Julia data types that are useful for Scientific Computing, we can make new types called a composite data type. We will start with developing a PlayingCard type that simplifies the poker hand simulations that we will see in . We will also look at a Polynomial data type and finally create a Root type that will help with the rootfinding from .    Basics of Julia's Composite Datatype  The composite data type in Julia is called a struct and consists of some number of fields of an existing type. A simple one is    struct Mystruct  num::Integer  str::String  end    which has the two fields num and str . We are using the standard naming convention of a struct in Pascal case, which starts with a capital letter and and other words capitalized. We can create an object Although a Julia struct is not an object in the sense of an object-oriented language, the terminology is pervasive in the Julia community. of type Mystruct by    m = Mystruct(13,\"hello\")    and we can access the fields of the struct with m.num and m.str . They will return 13 and \"hello\" respectively. Also, you can get an array of the names of the fields with fieldnames(Mystruct) . Note that the fieldnames command needs the datatype, not a variable of the datatype. This example is not very realistic, but the rest of the chapter will include more-practical examples.  One cannot change the fields of a struct . If m is defined as above and you try m.str = \"goodbye\" , then Julia will report the error:    setfield!: immutable struct of type Mystruct cannot be changed    This is exactly like trying to redefine a const . As we will see most of the examples in this text are these constant types of struct s, you can make non-constant structs using the mutable keyword. For example:    mutable struct MutableStruct  a::Float64  b::Integer  end    and then define an object such as    s=MutableStruct(1,2)    Then the redefinition s.a=4.5 is allowed. Note: that if you try to do s.b=7.1 , the you will get the error:    InexactError: Int64(7.1)    which happens because you are trying to assign the value 7.1 to an integer, since the field b is an integer.    A Card datatype   In , we will use simulations to determine the probabilities of certain poker hands. Although the calculations can be done with built-in types, the result would be difficult to read and hard to understand. Here, we will create a Card datatype that will help clarify the code by creating a type with a rank (1 to 13 corresponding to Ace, 2, through 10, Jack, Queen, King) and a suit (1 to 4 corresponding to the suits ``spades'', ``hearts'', ``diamonds'', ``clubs''), which we define as the characters arrays:    ranks = ['A','2','3','4','5','6','7','8','9','T','J','Q','K']  suits = ['\\u2660','\\u2661','\\u2662','\\u2663']    where the suits are the unicode characters See the Julia documentation on unicode . for the suits. (Note: ranks and suits are arrays of characters (not strings). This is because they use single quotes.). The following datatype:    struct Card  rank::Integer  suit::Integer  end    will be used to store a Card . Note that the suits and ranks are each integers, where we uses the suits 1, 2, 3, and 4 (which will corresponds to the actual suits) and the ranks will be the integers 1 to 13.  To create a Card , just call the struct like a function with the given rank and suit, like c = Card(3,2) , which will create a card of rank 3 and suit 2 (hearts). To access the fields of the type, we use dot notation. For example c.rank will return 3 and c.suit will return 2 .  Notice that the result of the card is Card(3,2) , which isn't very human friendly-I'd rather see the actual rank and suit. Fortunately, a nice feature of Julia is to override the output using Base.show . For example,    Base.show(io::IO, c::Card) = print(io, \"$(ranks[c.rank])$(suits[c.suit])\")    where the arguments of Base.show should be of type IO and then the datatype. The output from Base.show should call print as above. The result will be the concatenation of the characters corresponding to the rank and suit of the card. Any of the forms in that do string concatenation will work, I'm a fan of string interpolation. Try this out by typing c and you should get 3♡ .  Note: this is different than just a print or println within a function, which is highly discouraged. This function is called whenever a card type is displayed.    Constructors of new data types  When Julia calls Card(3,2) , actually, it executes a special function called a constructor, which creates an instance of the type, which we have called an object. Although Julia creates the basic constructor--that is the one that fills the fields of the type in the order defined, we may want some additional features. For example if we call Card(-10,78) , then Julia returns    BoundsError: attempt to access 13-element Vector{Char} at index [-10]    and we got the error because on Base.show we are trying to access an array outside of it's bounds. We just told Julia to make a new data type with two integers and Card(-10,78) is the new data type with two integers.  We can ensure that that the Cards only take the first argument as numbers between 1 and 13 and the second as between 1 and 4 by the updating the Card datatype as follows:   struct Card rank::Int suit::Int # construct a card based on the rank and suit function Card(r::Int,s::Int) 1 <= r <=13 || throw(ArgumentError(\"The rank must be an integer between 1 and 13.\")) 1 <= s <= 4 || throw(ArgumentError(\"The suit must be an integer between 1 and 4.\")) new(r,s) end end   If you enter the above struct you should see the error:    invalid redefinition of type Card    Recall, from the beginning of this chapter, this is because a struct is fixed, much like if a constant is declared and then it is redefined. We want to replace the first struct with this one, so we will restart the kernel Recall, in Juypter, select restart kernel at the top and if you are using VS Code, the restart button will do the same. You will need to reenter all of the needed cells, like the one with the ranks and suits as well as the one that starts Base.show . In , we will put structs inside a module and not have to restart the kernel as you develop a new datatype.  After restarting the kernel and rerunning the important cells, if we call Card(-10,78) , then we get    ArgumentError: The rank must be an integer between 1 and 13.    which is what we want and should notice that this error is what we said to do when the rank is not between 1 and 13. Although we haven't covered handling errors yet, the throw function will send an error and we have the ability to catch and handle these errors gracefully if we want.  Some other things to note about this new definition of Card      There are still two members of the struct, rank and suit listed on lines 2 and 3.    There is a function defined on lines 5 through 9 now. This is what is called when Card is called with two integers and is called a constructor . Line 6 checks if the rank (for this function is called r ) is between 1 and 13 and similarly on line 7 checks if the suits (called s ) is between 1 and 4. If either of these are outside the bounds an error is thrown. We'll talk specifically about what throw does later in the text.    Inside the the constructor, line 8 is new(r,s) . This assigns the member rank the value r and suit the value s .     We would also like another constructor that will take an integer between 1 and 52 and returns the appropriate card. The following example will do this.   struct Card rank::Int suit::Int # construct a card based on the rank and suit function Card(r::Int,s::Int) 1 <= r <=13 || throw(ArgumentError(\"The rank must be an integer between 1 and 13.\")) 1 <= s <= 4 || throw(ArgumentError(\"The suit must be an integer between 1 and 4.\")) new(r,s) end # construct a card based on the number in a deck function Card(i::Int) 1 <= i <= 52 || throw(ArgumentError(\"The argument must be an integer between 1 and 52\")) mod(i,13)==0 ? new(13,div(i,13)) : new(mod(i,13),div(i,13)+1) end end   And if you get the error that you cannot redefine Card , then again, restart the kernel. The big difference with this definition is a second constructor function on lines 13-16 is another function with name Card . The important parts of this second constructor is     Line 13 defines the input of the constructor. The only input is a single integer.    Line 14 checks that the input i is between 1 and 52. If not an error is thrown.    Line 15 defines the new Card . First, notice that there is a ternary if-then-else . A check is made if i mod 13 is zero. That is, 13, 26, 39 or 52. If that is the case, set the rank to 13 (King) and the rank is i\/13 (using div for integer division). Recall that new is used to set rank and suit of the struct.    If i mod 13 is not zero, then the rank is mod(i,13) . It will be an integer 1 through 12. The suit is div(i,13)+1 , which ensures that suit will be between 1 and 4.      Notice that we have 3 different versions of the Card type. In the first version, only the members were defined. There were no constructors. Often, this is all that is needed for a type\/struct, however, if you need to do some checking on arguments, then you will need to write a constructor or two.  If you do use a constructor, define it as a function with the same name as the type (the case must be the same as well). The last line in constructor function must be the new function that fills the member fields in the same order as listed in the struct. See additional information about constructors in the Julia Documentation      Creating a Hand datatype  As we will see in , a hand is also helpful in playing card games, we will define a hand in the following way:    struct Hand  cards::Vector{Card}  end    which is just an array of cards. (Note: there is nothing here that specifies that the Hand has to be 5 cards, but that could be included by doing some error checking in the constructor). An example hand would be    h1=Hand([Card(2,3),Card(12,1),Card(10,1),Card(10,4),Card(5,2)])    and again, since this looks a bit ugly, we can define a Base.show method for a hand:    Base.show(io::IO,h::Hand) = print(io, \"[$(join(h.cards,\", \"))]\")    Then let's define a card using the following:    h1=Hand([Card(2,3),Card(12,1),Card(10,1),Card(10,4),Card(5,2)])    now h1 should now return [2♢, Q♠, T♠, T♣, 5♡] .  We will return to this in where we will use this datatype to help with simulations.  A note about the Base.show function for the Hand . As with the Base.show for the Card type, the arguments are something of type IO and then something of type Hand . The function then calls print with the second argument a String . The main part of this is the join command which takes an array of strings and joins (recall this from ) them separated by the second argument, \", \" . The rest of this just surrounds them by square brackets.     Polynomials: A parametric data type   Recall that a polynomial is the sum of nonnegative powers of with constant coefficients. That is anything of the form:     and we may want to solve problems with them and it may be helpful to have a data type of this form. We can represent any polynomial by the coefficients. For example, the following will construct a datatype that is a polynomial with integer coefficients As well will see in , a Vector is shorthand or an alias for a 1D array :    struct Polynomial  coeffs::Vector{Int64}  end    We can then represent the polynomial with    p = Polynomial([2,-1,3])    Let's say that we want to construct methods to add, subtract, multiply two polynomials and perform a scalar multiply as well. However, if we want to allow Polynomials with coefficients other than integer coefficients, such as rational or real or complex, then we would need to write a set of functions to do this for each datatype, which is 1) painfully dull, 2) hard to maintain since there are many copies of the same function and 3) unnecessary because Julia has a nice feature called a parametric type.  We could define the Polynomial as    struct Polynomial{T}  coeffs::Vector{T}  end    which has Polynomial that has a type T . This now allows with one definition to have a polynomial of integers, floats, complex and rationals. However, this would also allow us to define a polynomial of strings or Card s, which doesn't make any sense. We can restrict the coefficients to number types with    struct Polynomial{T <: Number}  coeffs::Vector{T}  end    which defines the coefficients to be a Vector of type T and T from the first line is any subtype of Number , which is what the notation <: Number means. Recall that explain the data typing system and how to determine subtypes of a type. If a struct is created in a way like this to depend on a type, it is called a parametric type .  For example, using the above definition of Polynomial , we can define the following    poly1=Polynomial([1, 2, 3])  poly2=Polynomial([1.0, 2.0, 3.0])  poly3=Polynomial([2\/\/3, 3\/\/4, 5\/\/8])  poly4=Polynomial([im, 2+0im, 3-2im, -im])  poly5=Polynomial([n for n=1:6])    and the result of the last will be Polynomial{Int64}([1, 2, 3, 4, 5, 6]) .  The beginning of the output, Polynomial{Int64} explains that it is a type polynomial. The Int64 within the Polynomial type explains what type the coefficients have. If you enter the variable name, like poly3 , then you will see the type of the coefficient (type Rational{Int64} ) for that variable as well.  It would be nice if the result looked like a polynomial. In this case, we can use the Base.show command.    function Base.show(io::IO, p::Polynomial)  print(io, mapreduce(i -> \"$(coeffs[i]) x^$(i-1)\", (str, term) -> str * \" + $term \" , 1:length(coeffs)))  end    Now, if we reevaluate poly5 , then Julia returns 1 x^0 + 2 x^1 + 3 x^2 + 4 x^3 + 5 x^4 + 6 x^5 . The Base.show command is complicated, so let's break this down a bit     The first argument is of type IO . Note that we also call the argument io . It doesn't matter what it is called, but we'll always use io in this book. The second argument is of type Polynomial .    The output as before is a print with first argument io and second argument a string using the reduce function.    Recall from section that the reduce function takes an array and a function and returns a single value. In this case, our array is the integers from 1 to the length of the coeffs field of the struct. The function is the first argument and returns a string representing a term of the polynomial.    The string consists of four parts, $str is the current value of the string. This is basically string concatenation. $((n==1) ? \"\" : \"+\") puts a \"+\" in front of each coefficient except the first one and $(p.coeffs[n]) is the coefficients and x^$(n-1) is the power of x.    The array that is used for the reduce is the UnitStep  1:length(p.coeffs) instead of the coefficients themselves. This allows the powers of x to be generated.    This isn't perfect. For example, if there are negative coefficients, then you'll see a +- for a term. This can be taken care of with another ternary if-then-else . Also, it would be nice to eliminate the x^0 term (because it is just 1 as well as instead of writing x^1 write x , but this is just a little icing).    Note that there are many other ways to write this Base.show for a polynomial. One way would be to use a for loop to go through the polynomials. I used a reduce to show another example of how to use this function in practical way.       Adding Two Polynomials  Another nice thing that we'd like to do is have an add command and use the symbol + for this. However, if we enter poly1+poly2 , then we get the error:    MethodError: no method matching +(::Polynomial{Int64}, ::Polynomial{Float64})  The function `+` exists, but no method is defined for this combination of argument types.    To create a function that adds two polynomials, we first need to do the following:    import Base.+    and then define how to add two polynomials with:    function +(p1::Polynomial{T}, p2::Polynomial{S}) where {T <: Number, S <: Number}  Polynomial(p1.coeffs+p2.coeffs)  end    and then we can rerun the function + above. This is now a function that adds two polynomials. Note that the coefficients do not need to be the same type, so there are two types, T and S available. If we now enter poly1+poly2 , the result is 2.0 x^0 + 4.0 x^1 + 6.0 x^2 .  Note that this now a polynomial with floating point coefficients.   Similar to the function above, write functions that   subtract two polynomials (you'll need to import Base.- )   multiply a polynomial by a constant. (you'll need to import Base.* )   multiply two polynomials. Note: remember to multiply polynomials you need to distribute (aka FOIL), not just multiply the coefficients.     Evaluating the polynomial  Another helpful function is to actually evaluate the polynomial. The basic way to do this is to sum the terms of the polynomial. A possible way to write this is using the reduce function that we saw in .    function eval(poly::Polynomial{T}, x::Number) where T <: Number  reduce((val,i) -> val + poly.coeffs[i]*x^(i-1), 1:length(poly.coeffs))  end    and now if we evaluate poly1 when x=-2 , we enter eval(poly1,-2) and get 9 .  An alternative to this is to use Horner's form of the polynomial that we saw in :    function eval(poly::Polynomial{T}, x::Number) where T <: Number  reduce((val,c) -> x*val+c, reverse(poly.coeffs))  end    We have used reduce for each of these evaluation methods. Let's dive into these a bit more     The definition of the function is identical in both methods. Recall that since Polynomial is a parametric type (that is, it has multiple subtypes) we need to specify the type with T and say that T <: Number .    In the first eval method, the function is the terms themselves, poly.coeffs[i]*x^(i-1) and like the Base.show function above, the array used in 1:length(poly.coeffs) not the coefficients. This allows the use of the powers.    In the section method (Horner's method), again we use reduce however is much simpler. First, the innermost part of the method is a_{n-1} + a_n * x , and this is exactly the function used above, where val is the cumulative value going through the coefficients. Also, note that we needed to reverse the coefficient array because it's important that we go inside out--that is, the last coefficient is used first.    Reduce also has an init option that we didn't use here. This is because initially these are both 0 and that is the default. This differs from the Base.show above, in that initially we needed the empty string to start.        A Rootfinding datatype  The last example of a new data type will be related to finding the root of a function. We explored this in . One major issue with that function is that if Newton's method did not find the root, it wasn't clear if it was a root or just that the algorithm stopped because it reached 10 steps. There was no way that you (the user) knew which case occurred. We will use a struct to store the information about the rootfinding in this section which then conveys what happens.  In , we developed the following function for solving Newton's method:   using ForwardDiff function newton(f::Function, x0::Number) local dx = 1 local x1 = x0 local steps = 0 while abs(dx) > 1e-6 && steps < 10 dx = f(x1)\/ForwardDiff.derivative(f,x1) x1 -= dx steps += 1 end x1 end   Although if the function has a root and the method converges to it, then this method will probably find it, however, just running it, we don't know if it has exceeded the total number of steps (hardcoded as 10 steps in this example) or reached the root.  We are going to define a struct to deliver more information as follows:   struct Root root::Float64 # approximate value of the root x_eps::Float64 # estimate of the error in the x variable f_eps::Float64 # function value at the root f(root) num_steps::Int # number of steps the method used converged::Bool # whether or not the stopping criterion was reached max_steps::Int # the maximum number of steps allowed end   and then return an object of type Root . Thus we will replace the function newton above with   function newton(f::Function, x0::Number) local dx = 1 local x1 = x0 local steps = 0 while abs(dx) > 1e-6 && steps < 10 dx = f(x1)\/ForwardDiff.derivative(f,x1) x1 -= dx steps += 1 end Root(x1, dx, f(x1), steps, steps < 10, 10) end   and note that we store extra information that is returned. Let's run Newton's method on as an example by evaluating   newton(x->x^2-2,1)   returns Root(1.4142135623730951, 1.5947429102833119e-12, 4.440892098500626e-16, 5, true, 10) , which again gives a lot of information, but perhaps not very easy to read since you would need to know each of the fields and what each means. We could then create a Base.show function to help with readability:   function Base.show(io::IO,r::Root) str = r.converged ? \"\"\"The root is approximately x̂ = $(r.root) An estimate for the error is $(r.x_eps) with f(x̂) = $(r.f_eps) which took $(r.num_steps) steps\"\"\" : \"\"\"The root was not found within $(r.max_steps) steps. Currently, the root is approximately x̂ = $(r.root). An estimate for the error is $(r.x_eps) with f(x̂) = $(r.f_eps).\"\"\" print(io,str) end   which will print out different information if it converges or not. Notice also that we have used the string interpolation $( ) explained in , however need to include the parentheses around these variables because we want the field to be looked up. (You can remove the () around one of the variables to see what happens--there will be an error.)  If we now run Newton's method on with newton(x->x^2-2,1) then we get:    The root is approximately x̂ = 1.4142135623730951  An estimate for the error is 1.5947429102833119e-12  with f(x̂) = 4.440892098500626e-16  which took 5 steps    and then if we run it on a function that does not have a root. Recall in , we ran Newton's method on . Since is nonnegative then the function is positive and so never is zero. If we enter newton(x->x^2+1,1.1) then the result is    The root was not found within 10 steps.  Currently, the root is approximately x̂ = 0.030421004027873844.  An estimate for the error is 1.0004626117382218  with f(x̂) = 1.0009254374860639.    And now it's clear that Newton's method did not converge within 10 steps and there is information about the estimated root and it's error.   Adapt the Root struct and the newton function to include the following:   Extend the Root struct to include an array of the x values that save all of the steps of Newton's method. (Recall that you will need to restart the kernel to change the struct ).   Store the x values that Newton's method iterates through and then assign them to the Root datatype. You will need to update the newton method. Before the while loop, set the array equal to the initial point x1 and each time in the while loop perform, push the new value of x1 to the end of the array.   Write a showSteps function that takes in an object of type Root and prints out a table of the x values.    "
},
{
  "id": "ch-comp-types-2",
  "level": "2",
  "url": "ch-comp-types.html#ch-comp-types-2",
  "type": "Objectives",
  "number": "12",
  "title": "",
  "body": "   One can create a new user-define data type or struct .    Creation of a Card and Hand data type to model a playing card.    When creating a new data type, use the new command in constructors.    Displaying a Data Type with the show command for clarity.    Developing a Polynomial and Root datatype and applying existing methods like addition and subtraction on a user-defined type.    "
},
{
  "id": "ch-comp-types-5-3-14",
  "level": "2",
  "url": "ch-comp-types.html#ch-comp-types-5-3-14",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "constructor "
},
{
  "id": "ch-comp-types-5-3-19",
  "level": "2",
  "url": "ch-comp-types.html#ch-comp-types-5-3-19",
  "type": "Remark",
  "number": "12.1",
  "title": "",
  "body": " Notice that we have 3 different versions of the Card type. In the first version, only the members were defined. There were no constructors. Often, this is all that is needed for a type\/struct, however, if you need to do some checking on arguments, then you will need to write a constructor or two.  If you do use a constructor, define it as a function with the same name as the type (the case must be the same as well). The last line in constructor function must be the new function that fills the member fields in the same order as listed in the struct. See additional information about constructors in the Julia Documentation   "
},
{
  "id": "sect-poly-parametric-2-12",
  "level": "2",
  "url": "ch-comp-types.html#sect-poly-parametric-2-12",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "parametric type "
},
{
  "id": "sect-poly-parametric-3-10",
  "level": "2",
  "url": "ch-comp-types.html#sect-poly-parametric-3-10",
  "type": "Check Your Understanding",
  "number": "12.2",
  "title": "",
  "body": " Similar to the function above, write functions that   subtract two polynomials (you'll need to import Base.- )   multiply a polynomial by a constant. (you'll need to import Base.* )   multiply two polynomials. Note: remember to multiply polynomials you need to distribute (aka FOIL), not just multiply the coefficients.  "
},
{
  "id": "ch-comp-types-7-20",
  "level": "2",
  "url": "ch-comp-types.html#ch-comp-types-7-20",
  "type": "Check Your Understanding",
  "number": "12.3",
  "title": "",
  "body": " Adapt the Root struct and the newton function to include the following:   Extend the Root struct to include an array of the x values that save all of the steps of Newton's method. (Recall that you will need to restart the kernel to change the struct ).   Store the x values that Newton's method iterates through and then assign them to the Root datatype. You will need to update the newton method. Before the while loop, set the array equal to the initial point x1 and each time in the while loop perform, push the new value of x1 to the end of the array.   Write a showSteps function that takes in an object of type Root and prints out a table of the x values.  "
},
{
  "id": "ch-plotting-basics",
  "level": "1",
  "url": "ch-plotting-basics.html",
  "type": "Chapter",
  "number": "13",
  "title": "Plotting Basics",
  "body": " Plotting Basics   Plotting is an important aspect of anything scientific or mathematical. The ability to visualize a complex model or data set is often key to understanding it. In Julia, there are two different systems currently that are both used. These are called Makie and the Plots package.  Also, as is common with open systems, like Julia, both Makie and Plots are user grown systems that are evolving separate from each other. Both have advantages and philosophies associated with them. We will cover them each in depth in the next two chapters.    Introduction to Makie  On the official Makie Home Page : Makie is a data visualization ecosystem for the Julia programming language, with high performance and extensibility.   There is definitely a philosophy of making attractive plots in Makie. In fact, there is another website called Beautiful Makie whose purpose is to show off the amazing plots. The following is an example of a combination surface and vector field plot   Example of a Makie Plot   (for accessibility)    I won't post the code here, but it is available at the Beautiful Makie website. However, it is about 20 lines of code, which is quite compact for such a plot.    Introduction to the Plots package   Plots is a packaging system that has some similar ideas to that of Makie. According to the Plots website , the goals with the package are:      Powerful. Do more with less. Complex visualizations become easy.     Intuitive. Start generating plots without reading volumes of documentation. Commands should \"just work.\"     Concise. Less code means fewer mistakes and more efficient development and analysis.     Flexible. Produce your favorite plots from your favorite package, only quicker and simpler.     Consistent. Don't commit to one graphics package. Use the same code and access the strengths of all backends.     Lightweight. Very few dependencies, since backends are loaded and initialized dynamically.     Smart. It's not quite AGI, but Plots should figure out what you want it to do... not just what you tell it.     An example of using Plots is the following Lorenz attractor as an animator. If you return to the Makie Homepage, you'll see a similar example.   Example Animated plot using the Plots package   (for accessibility)      Plotting is Hard  As the title says \"Plotting is hard\". For scientific computing software, often plotting is what takes the most CPU\/GPU cycles. In fact, the team of developers that have been working on Julia have given this issue the acronym TTFP (time to first plot), which is the amount of time from starting julia to getting a plot rendered. Recently a lot of work has been done to reduce this.  When people usually think of plots or visualization, we think of high-level ideas, like function plots, scatter plots, vector field plots, etc. We'd like to give functions or data and some attributes to some plotting routine and then just wait for the results. These routine need to handle a lot of the details, including drawing lines and points on the screen with various fonts and make sure that all of the spacing is correct.    Presenting Results with Visualization, an overview   Before starting with code to create plots, let's remind ourselves of the types of plots that can occur and what they mean.    Scatter Plots  A scatter plot is a plot of points in 2D or 3D in which each point represents a piece of data. Although we will usually think of them in terms of x, y and z axes, the two or three axes can represent anything. The following is the graph of carbon dioxide levels in Hawaii from 1959 to 2023.     (for accessibility)      Function Plots  Mathematically, the graph of a function is the set of all points that satisfy the points or if it is a function of two variables . This is generally what is thought of as a function graph that is often first seen in a Precalculus class, but extends throughout a science fields. The following is a sine curve.     (for accessibility)      Parametric Plots  Additionally, a function plot can be created for a parametric curve defined as for functions and . For example the spiral:     (for accessibility)      Parametric Plots in 3D  Vector Functions in 3D are often represented as parametric functions of the form: where each function gives the , or coordinate at a time . Examples of this are in     (for accessibility)      Surface Plots  Functions of two variables in the form and that the two independent variables are and and the third variable is the height of the function. The set of points that satisfy this equation generally form surfaces in 3D. An example of this is the function which has the surface plot     (for accessibility)      Implicit Curves  An implcit curve is the set of points in which for some constant . The classic example is the circle The following is the circle above plotted implicitly:     (for accessibility)      Contour Plots  Related to plots of an implicit curve is that of a contour plot. Recall from above that a function of two variables can be plotted in 3D, however another way to view these is as a series of implicit curves in the form for some number of constants . For example, the contour plot of     has the contour plot:     (for accessibility)       Plotting Backends  Each of the two plotting environments that we are discussing in this chapter rely on other software to do the plotting. These are known as backends , which are the actual routines to draw the lines, place the glyphs in a font and handling spacing. There is different technology that is used for each backend and you don't need to know the specifics, but you should know that there are different backends and there are strengths and weaknesses of each.  Makie and the Plots package are each high-level wrappers with a consistent interface. That is, say, to perform a function plot, each takes a function, the limits and various attributes of the plot and the backends handle the details. Although we haven't discussed which plotting environment to use, one way to decide is which style of wrappers do you like better.  As this text is agnostic for the plotting environment, once that is chosen, some reading should be done on the backend. Each of the next two chapters covers the backends for Makie and Plots respectively.   "
},
{
  "id": "fig-makie-example",
  "level": "2",
  "url": "ch-plotting-basics.html#fig-makie-example",
  "type": "Figure",
  "number": "13.1",
  "title": "",
  "body": " Example of a Makie Plot   (for accessibility)   "
},
{
  "id": "fig-plots-example",
  "level": "2",
  "url": "ch-plotting-basics.html#fig-plots-example",
  "type": "Figure",
  "number": "13.2",
  "title": "",
  "body": " Example Animated plot using the Plots package   (for accessibility)   "
},
{
  "id": "ch-plotting-basics-6-3-2",
  "level": "2",
  "url": "ch-plotting-basics.html#ch-plotting-basics-6-3-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "scatter plot "
},
{
  "id": "fig-co2-scatter",
  "level": "2",
  "url": "ch-plotting-basics.html#fig-co2-scatter",
  "type": "Figure",
  "number": "13.3",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-sine-curve",
  "level": "2",
  "url": "ch-plotting-basics.html#fig-sine-curve",
  "type": "Figure",
  "number": "13.4",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-spiral-curve",
  "level": "2",
  "url": "ch-plotting-basics.html#fig-spiral-curve",
  "type": "Figure",
  "number": "13.5",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-parametric-3d",
  "level": "2",
  "url": "ch-plotting-basics.html#fig-parametric-3d",
  "type": "Figure",
  "number": "13.6",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-surface",
  "level": "2",
  "url": "ch-plotting-basics.html#fig-surface",
  "type": "Figure",
  "number": "13.7",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-implicit-circle",
  "level": "2",
  "url": "ch-plotting-basics.html#fig-implicit-circle",
  "type": "Figure",
  "number": "13.8",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-contour-ex",
  "level": "2",
  "url": "ch-plotting-basics.html#fig-contour-ex",
  "type": "Figure",
  "number": "13.9",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-plotting-makie",
  "level": "1",
  "url": "ch-plotting-makie.html",
  "type": "Chapter",
  "number": "14",
  "title": "Using Makie for Plots",
  "body": " Using Makie for Plots   As discussed in , one of the main plotting environments for Julia is Makie, a relatively new plotting environment that had a goal to develop a completely Julia-based environment that was designed to \"create publication-quality vector graphics, animated movies and interactive data exploration tools. Most options that are available today lack one or more of the following attributes:\" (cite Makie paper).    Basic Plotting  Before plotting, make sure that you have the packages Makie and CairoMakie installed. The package CairoMakie is the backend package that does the plotting using the common interface (API) in the Makie package. To get started enter    using Makie, CairoMakie  CairoMakie.activate!()  Makie.inline!(true)    and to get a plot, we can use the scatter command and let's first define the arrays:    x=1:10  y=[3.2,-4.5,7.8,4.2,-2.0,5.4,7.8,-2.4,-3.1,3.9]  scatter(x,y)    which results in the plot   Scatter plot of some sample data   Scatter plot of points with x between 1 and 10 and y between -5 and 8.    If instead we wish to make a line plot (connect the points by lines), simply use the lines function as in    lines(x,y)    resulting in   Line plot of some sample data   Line plot of points with x between 1 and 10 and y between -5 and 8.    to create a function plot, we can use either scatter or lines but typically use a line plot. For example    lines(0..2pi, sin)    and if the prescence of sin by itself in the function, one can use lines(0..2pi, x -> sin(x)) instead. The result is   Plot of from 0 to 2 .   Plot of sin(x) from 0 to 2pi.    Typically it would be nice to use units of for the x-axis labels, and we will be able to do that later.  You may have noticed that for the function plot above, the first argument is 0..2pi . We haven't seen this structure before. Entering typeof(0..2pi) results in    ClosedInterval{Float64} (alias for IntervalSets.Interval{:closed, :closed, Float64})    indicating that this structure is part of the IntervalsSets package (that is a dependency of Makie ). This makes plotting functions quite nice.    Figures and Grid Layout in Makie  Before delving into more of the plotting types in Makie, we will first look at layout and axes, a strength of this package and also shows how to build a plot step by step. First, a plot need a Figure container and this can be created with:    fig = Figure()    And upon running this, you will get a blank\/empty Figure. This is not so interesting, but important. There are many things that happen when creating a figure, but most importantly, there is a grid layout that is created. To place items in the grid, typically plots need to occur on axes, so we will place axes in a layout with row\/column indexing. For example    fig = Figure()  ax1 = Axis(fig[1,1], title = \"Axis 1\")  ax2 = Axis(fig[2,1], title = \"Axis 2\")  ax3 = Axis(fig[1,2], title = \"Axis 3\")  ax4 = Axis(fig[2,2], title = \"Axis 4\")  fig    and the output of this is   2 by 2 grid layout of a figure with 4 axes.   A figure with four axes in a 2 by 2 grid, labelled \"Axis 1\", \"Axis 3\", \"Axis 4\" and \"Axis 2\" clockwise from the upper left.    and you should notice many things. We can add a Axis to a plot (or four of them) without any plot within them. We will learn how to add a plot to an axis below. Above, the axes were placed by adding a row and column to the fig (Figure) above. For example, the Axis labeled as Axis 2 is placed in the second row and first column. Also, the default plotting window (limits) for an Axis is between 0 and 10.  If you have multiple plots in the same figure, then generally a simple grid layout will work, however, Makie has the ability to nest axes as well. For example:    fig = Figure()  ax1 = Axis(fig[1,1], title = \"Axis 1\")  ax2 = Axis(fig[2,1][1,1], title = \"Axis 2\")  ax3 = Axis(fig[2,1][1,2], title = \"Axis 3\")  ax4 = Axis(fig[2,1][1,3], title = \"Axis 4\")  fig    will produce the following layout where the 2nd row has nested axes.   A grid layout with one axis on the first row and 3 in the second row.   A grid layout with one axis on the first row and 3 in the second row. The top row axis is labelled \"Axis 1\" and the bottom three are labelled \"Axis 2\", \"Axis 3\" and \"Axis 4\" from left to right.    Notice that to nest axes, we add an additional row\/column specification. For example, fig[2,1][1,2] means first place this in the 2nd row and 1st column of the overall layout and then within that cell, place in the first row, second column.    Axis Options  We saw above how to place an Axis object inside a Figure . Upon creating the Axis , we can give other options. We will cover some of the important ones here, and then refer to the documentation. The first option to an Axis is a title that we saw above. Just pass the title in as a string. Other basic options are the xlabel and ylabel . The following code    fig = Figure()  ax = Axis(fig[1,1], title = \"My Plot\", xlabel = \"x label\", ylabel = \"ylabel\")  fig    results in   An empty plot with values for the title, xlable and ylabel.   An empty plot with title \"My Plot\", xlabel of \"x label\" and ylable as \"y label\".    Setting the limits on the axes is done with the limits option. For example:    fig = Figure() ax = Axis(fig[1,1], limits = (-5,5,0,20)) fig    produces the following   An empty plot with updated limits.   An empty plot with limits in the x-direction from -5 to 5 and in the y-direction from 0 to 20.    where the specification is limits = (xmin, xmax, ymin, ymax) .  There are plenty of other options available for an Axis . See the documentation on Axis for more information. One big this to note is the separation of axis options (anything that isn't a plot) should be done to the Axis option, whereas as we will see below, changes to the plot will go on the individual plotting function.    Adding Plots to Axes  Even though we can do some elaborate layout of axes, we haven't done any plotting on them. In fact, there are two ways to plot via Makie. First, as we saw above, we can use plotting functions like lines or scatter to make plots. This is fine for relatively simple plots or just for a quick plot using defaults. Secondly, we will create Figure s and Axis objects and the add plots to them with commands like lines! or scatter! (note the !). Recall that convention in Julia is if an argument is being modified that the name should end in a ! .  Let's repeat the scatter plot at the top of this chapter. If we do:    y = [3.2,-4.5,7.8,4.2,-2.0,5.4,7.8,-2.4,-3.1,3.9]  fig = Figure()  ax = Axis(fig[1,1], limits = (0,11,-10,10))  scatter!(ax, x, y)  fig    where we have set the limits to make them symmetric above and below the -axis.   A scatter plot with sample data in which the limits have been updated.   A scatter plot with sample data in which the limits are from 0 to 11 in the x-direction and from -10 to 10 in the y-direction.    This is the way to include either multiple function plot or a scatter and function plot on the same axes. Consider the scatter plot from which is the data from CO₂ levels. We can add an exponential function to them as well in the following way. The data is available at this NOAA webpage and should be downloaded and saved in the same directory as your julia notebook. .   fig = Figure() ax = Axis(fig[1,1]) scatter!(ax, co2.year, co2.mean) lines!(ax, 1959..2023,t -> exp(5.735 + 0.00454*(t-1959)), color = :green) fig   resulting in the following.   A scatter plot of CO₂ data and an exponential fit.   (for accessibility)    The exponential was found in a way similar to that of fitting curves in .    Plotting Data   Many of the examples above have involved plotting functions. This section gives some overview of how to think about data. In particular, recall that data is generally either discrete (that is there are either a finite or countable number of possibilities) like categories or numerical data that can be counted or continuous like data that is measured with real numbers (inches of rain, heights of people, etc.) It's important to understand the difference to understand plots.    Plotting Continuous Data  We have already seen examples of plotting continuous data with the CO₂ data above. This data is the mean CO₂ level over each year and although the year seems like a discrete variable, time is actually continuous. Because of this, a scatter plot is a good way to present this data.    Plotting Discrete Data  In contrast, let's look at discrete data. I have done a lot of research recently using sports data and one project involved scoring in the National Basketball Association (NBA). Consider a season and looking at the number of points every team has scored. For the 2023-2024 season, if we consider the home and visiting teams, then here is the first few games:  To plot every score (which is discrete), let's consider a bar plot in which the height of a bar at a given score is the number of games with that score. To generate this, we load in the nba2024.csv file. Note you will need to download\/install CSV and DataFrames .    using CSV, DataFrames  nba_scores = CSV.read(\"nba.csv\", DataFrame)    and this lists about 15 rows of the file. The top of the file looks like:    1319×5 DataFrame 1294 rows omitted  Row DATE HOME_TEAM HOME_SCORE VISITOR_NAME VISITOR_SCORE  Date String31 Int64 String31 Int64  1 2023-10-24 Denver Nuggets 119 Los Angeles Lakers 107  2 2023-10-24 Golden State Warriors 104 Phoenix Suns 108  3 2023-10-25 Orlando Magic 116 Houston Rockets 86    We won't go into what a DataFrame is, but in short it is a common data structure for working with data that comes in columns with common types. These work well with spreadsheets. The details of a DataFrame is presented starting in . To plot the number of home games with a given score (also called the score distribution), we use the counts function in the StatsBase package (so install it) and perform using StatsBase .    home_dist = counts(nba_scores.HOME_SCORE,70:160)    which returns a vector of the number of games with the score 70, 71, ..., 160. We can then plot the results with barplot using    barplot(70:160,home_dist)    which results in the plot     (for accessibility)    Another interesting plot is to place bars side by side for the home and visitor scores. This is a little but possible with the barplot command. We just need to include all of the data together and then including a vector of grouping. The following is the code to do this:    colors = Makie.wong_colors()  barplot(  repeat(70:160,2),  vcat(home_dist,visitor_dist),  dodge = repeat(1:2,inner=91),  color = repeat([:orange, :darkgreen],inner=91)  )    where this is one command but split onto lines for readibility. The 2nd line is the horizontal axis which is just the same as the plot above except that we need to repeat it twice. The third line concatenates vertically ( vcat ) the two distributions. The fourth line explain how to group the data ( dodge is used to include it side by side or stack is to stack it vertically). The color attribute (line 5) sets the color for each bar--again, this is needed to be a repeated vector. The result of this is     (for accessibility)    An easier example of this is with the following code:    colors =Makie.wong_colors()   h = [2, 3, 6, 8, 3, 5, 7, 9]  x = [1, 1, 2, 2, 3, 3, 4, 4]  v = repeat([1,2],4)   barplot(x, h, dodge = v, color = colors[v] )    which results in     (for accessibility)    More examples of plotting data can be found in and other chapters in , which uses larger datasets and investigates how to gain insights into data from visualization.     Contour Plots  As mentioned in , a contour plot is generally used for functions of two variable, like and the plot is curves of constant function value or for various values of . As in the previous chapter, we will plot     and can do this with the following code:    x = y = LinRange(0,pi,101)  fig = contour(x, y, (x, y) -> sin(0.5x^2-0.25y^2+2)*cos(x+y))    which results in the plot:     (for accessibility)    And recall that a contour plot is basically like a topographical map if you have ever used one of those. The concentric circles are either a hill (maximum) or a depression (minimum) and unless we know what function values, we're not sure which is why. To help with this we will add labels to the contours and increase the number of contours used with the levels attribute.    x = y = LinRange(0,pi,101)  contour( x, y, (x, y) -> sin(0.5x^2-0.25y^2+2)*cos(x+y), labels = true, levels = 11)    and this results in     (for accessibility)    and you can see from the values of the contours that there is a minimum near and a maximum near   Another related plot is that of a filled contour plot in which the regions between contours are filled with colors. This is more of a visually nice feature rather than an important distinction over the previous contour plot. A filled contour plot can be created with the contourf plotting command as in this example:    x = y = LinRange(0,pi,101)  contourf( x, y, (x, y) -> sin(0.5x^2-0.25y^2+2)*cos(x+y), labels = true, levels = 11)    resulting in     (for accessibility)    And since the colors play an important role in a filled contour plot, it is helpful to know the function values for a give color and using a colorbar is a way to do this. We can add a colorbar with the following code:    x = y = LinRange(0,pi,101)  fig = Figure()  ax = Axis(fig[1,1])  contourf!(ax, x, y, (x, y) -> sin(0.5x^2-0.25y^2+2)*cos(x+y), levels = 11)  Colorbar(fig[1,2])  fig    where we have used the layout methods described in because we need to specify where the colorbar goes. The result of this is     (for accessibility)      Backends for Makie  As described in , Makie is a set of high level plotting commands. The hard work of drawing lines, circles and regions on the screen is done with a backend and the idea is to be able to switch backends easily without changing the high-level code to produce a plot. Makie has four such options currently: CairoMakie , GLMakie , WGLMakie and RPRMakie and you should have seen the first two appear above in the plotting code.     CairoMakie   CairoMakie uses the Cairo drawing engine underneath and excels at high-quality 2D drawings that are non-interactive. The output in generally either an SVG or PDF and since these are vector-based drawing formats, these will produce high-quality graphs for print (and the screen).    GLMakie  According to the GLMakie documentation page ,   GLMakie is the native, desktop-based backend, and is the most feature-complete. It requires an OpenGL enabled graphics card with OpenGL version 3.3 or higher.   It appears that almost all graphics cards support OpenGL and thus GLMakie should work for nearly all computers.    RPRMakie  According to the RPRMakie page :   Experimental ray tracing backend using AMDs RadeonProRender. While it's created by AMD and tailored to Radeon GPUs, it still works just as well for NVidia and Intel GPUs using OpenCL. It also works on the CPU and even has a hybrid modus to use GPUs and CPUs in tandem to render images.     WGLMakie  According to the WGLMakie page :   WGLMakie is the web-based backend, which is mostly implemented in Julia right now. WGLMakie uses Bonito to generate the HTML and JavaScript for displaying the plots. On the JavaScript side, we use ThreeJS and WebGL to render the plots. Moving more of the implementation to JavaScript is currently the goal and will give us a better JavaScript API, and more interaction without a running Julia server.       "
},
{
  "id": "fig-makie-scatter",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-makie-scatter",
  "type": "Figure",
  "number": "14.1",
  "title": "",
  "body": " Scatter plot of some sample data   Scatter plot of points with x between 1 and 10 and y between -5 and 8.   "
},
{
  "id": "fig-makie-lines",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-makie-lines",
  "type": "Figure",
  "number": "14.2",
  "title": "",
  "body": " Line plot of some sample data   Line plot of points with x between 1 and 10 and y between -5 and 8.   "
},
{
  "id": "fig-makie-function",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-makie-function",
  "type": "Figure",
  "number": "14.3",
  "title": "",
  "body": " Plot of from 0 to 2 .   Plot of sin(x) from 0 to 2pi.   "
},
{
  "id": "fig-makie-layout",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-makie-layout",
  "type": "Figure",
  "number": "14.4",
  "title": "",
  "body": " 2 by 2 grid layout of a figure with 4 axes.   A figure with four axes in a 2 by 2 grid, labelled \"Axis 1\", \"Axis 3\", \"Axis 4\" and \"Axis 2\" clockwise from the upper left.   "
},
{
  "id": "fig-layout-nested",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-layout-nested",
  "type": "Figure",
  "number": "14.5",
  "title": "",
  "body": " A grid layout with one axis on the first row and 3 in the second row.   A grid layout with one axis on the first row and 3 in the second row. The top row axis is labelled \"Axis 1\" and the bottom three are labelled \"Axis 2\", \"Axis 3\" and \"Axis 4\" from left to right.   "
},
{
  "id": "fig-xylabels",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-xylabels",
  "type": "Figure",
  "number": "14.6",
  "title": "",
  "body": " An empty plot with values for the title, xlable and ylabel.   An empty plot with title \"My Plot\", xlabel of \"x label\" and ylable as \"y label\".   "
},
{
  "id": "fig-limits",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-limits",
  "type": "Figure",
  "number": "14.7",
  "title": "",
  "body": " An empty plot with updated limits.   An empty plot with limits in the x-direction from -5 to 5 and in the y-direction from 0 to 20.   "
},
{
  "id": "fig-scatter2",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-scatter2",
  "type": "Figure",
  "number": "14.8",
  "title": "",
  "body": " A scatter plot with sample data in which the limits have been updated.   A scatter plot with sample data in which the limits are from 0 to 11 in the x-direction and from -10 to 10 in the y-direction.   "
},
{
  "id": "fig-co2-fit",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-co2-fit",
  "type": "Figure",
  "number": "14.9",
  "title": "",
  "body": " A scatter plot of CO₂ data and an exponential fit.   (for accessibility)   "
},
{
  "id": "fig-nba-home",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-nba-home",
  "type": "Figure",
  "number": "14.10",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-nba-compare",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-nba-compare",
  "type": "Figure",
  "number": "14.11",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-simple-barplot",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-simple-barplot",
  "type": "Figure",
  "number": "14.12",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-contour-1",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-contour-1",
  "type": "Figure",
  "number": "14.13",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-contour-2",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-contour-2",
  "type": "Figure",
  "number": "14.14",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-contourf-1",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-contourf-1",
  "type": "Figure",
  "number": "14.15",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-contourf-2",
  "level": "2",
  "url": "ch-plotting-makie.html#fig-contourf-2",
  "type": "Figure",
  "number": "14.16",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-plots-package",
  "level": "1",
  "url": "ch-plots-package.html",
  "type": "Chapter",
  "number": "15",
  "title": "The Plots Package",
  "body": " The Plots Package   There is a relatively simple, but powerful plotting package called Plots and don't forget to download it as in . The full documentation is at the Plots.jl website . Recall that once the package is added, enter This function often takes a while to load due to some precompiling. Also, the first time a plot is created, it'll take a while. The julia team knows this is a problem and calls is the TTFP or time to first plot problem.   The Plots package tries to unify the syntax for plotting anything. The basic command for plotting data or functions in 2D is the plot command. The idea call plot on any type of object that can be plotted. The next few examples shows this.    Plotting Functions  For plotting a function, simply call plot on the function:   plot(x->x^2)   produces the following plot: \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/plot01.tex}{plots} \\end{center}  Note: your plot may look a bit different than this one with different fonts. This is mainly due to using a different backend, which is explained below.  If you want to specify the -range, try: plot(x->x^2,-2,2) which generates:  \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/plot01a.tex}{plots} \\end{center}  If we want to plot 2 or more functions on the same axes, pass in an array of functions like:   plot([x->x^2,x->sin(x)],-2,2)   produces the following: \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/plot02.tex}{plots} \\end{center}  We will also see below how to change other aspects of the plot including the legend, title, labels on the axes, etc.    Other Function Plots  Parametric Plots  To do a parametric plot, like the circle defined by , then   plot(t->cos(t),t->sin(t),0,2*pi,legend=false)   where the legend is turned off, since with one curve, it doesn't make much sense. The result is \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/parametric01.tex}{plots} \\end{center}  but notice that this should be a circle, but it looks like an ellipse due to the aspect ratio. If one instead adds the \\verb!aspect_ratio=:equal! option, as in   plot(t->cos(t),t->sin(t),0,2*pi,aspect_ratio=:equal, legend=false) \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/parametric02.tex}{plots} \\end{center}   Implicit Curves  An implicit curve is the set of points such that (or any constant) and a circle is the classic example. The curve below is the set of all points such that . It can be plotted in Julia with the following command.   contour(-1.1:0.01:1.1, -1.1:0.01:1.1, (x,y) -> x^2+y^2, levels=[1], aspect_ratio = :equal, legend = false)   \\begin{center} \\pgfplotsset{scale=0.7} \\IfFileExists{.\/plots\/plots\/impcurve_preamble.tex}{\\input{plots\/plots\/impcurve_preamble.tex}}{NO IMPLICIT CURVE PREAMBLE} \\plot{plots\/plots\/implcurve.tex}{plots} \\end{center}  Note that again, we have used the \\verb!aspect_ratio = :equal! to ensure that the circle looks like a circle. The resulting plot is exactly the same as the circle above.  Here's a more interesting contour plot of the function and following is the implicit curve when .   contour(-10.1:0.1:10.1, -10.1:0.1:10.1, (x,y) -> sin(x+y)-cos(x*y)+1, levels=[0], aspect_ratio = :equal, colorbar_entry = false) \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/implcurve2.tex}{plots} \\end{center}   Contour Plots  We can extend this notion to any function of two variables, say and plot many implicit curves together for different constants. That is plots of the form for multiple values and this is called a contour plot. The following is for which creates 4 concentric circles.   contour(-5.1:0.1:5.1, -5.1:0.1:5.1, (x,y) -> x^2+y^2, levels=[1,4,9,16], aspect_ratio = :equal, colorbar_entry = false) \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/contour1.tex}{plots} \\end{center}   Surface Plots  If we have a function of 2 variables, a surface plot is nice to use. For example, if we have the function and we want to plot it from -3 to 3 in both directions, if we define   f(x,y)=exp(-0.1*(x^2+y^2)) x = y = range(-5, stop = 5, length = 40)   and then plot with surface(x,y, f, legend = false) \\begin{center} \\pgfplotsset{scale=0.7} \\IfFileExists{.\/plots\/plots\/surf_preamble.tex}{\\input{plots\/plots\/surf_preamble.tex}}{} \\plot{plots\/plots\/surf.tex}{plots} \\end{center}   Heat maps  Similar to above, we can make a heat map with   pl = heatmap(x,y, f, st=:heatmap)   which produces \\begin{center} \\pgfplotsset{scale=0.7} \\IfFileExists{.\/plots\/plots\/heat_preamble.tex}{\\input{plots\/plots\/heat_preamble.tex}}{} %\\plot{plots\/plots\/heat.tex}{plots} {\\color{red} This plot isn't working.} \\end{center}     Plotting Data   First, let's start with some random data. Let   x=1:10 y=rand(1:10,10)   then plot(x,y) will produce a scatter plot of the data, like \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/plot03.tex}{plots} \\end{center}  and note that since these are just random points, your plot will look different, but the style should be the same.  If we want to connect all of the points with points instead, type   plot(x,y,seriestype=:scatter)   and the plot will look like: \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/plot04.tex}{plots} \\end{center}  There is a shorthand or different version of this: \\jlv[plots]{scatter(x,y)}, which produces the same plot. If you want both, then type   plot(x,y,seriestype=[:scatter,:line]) \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/plot05.tex}{plots} \\end{center}    Bar plots  A bar plot can be made with the bar command. For example:   bar(x,y)   where x and y were defined above for the scatter plot. The result is \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/bar01.tex}{plots} \\end{center}    Animation  Another nice type of plot under Plots.jl is that of an animation, however you will need to have ffmpeg installed on your machine. If you then do   @gif for a in range(0.5,stop=2,length=16) plot(t->cos(2t),t->sin(a*t),0,2pi,legend=false) end   which saves to a gif that the output will describe this results in:     Other Plots and subplots  This just is the tip of the iceberg for plotting. Take a look at the Plots.jl documentation or do some google-foo with the phrase `Plots.jl' and what you're looking for and good spot for Q & A is a julialang.org discourse site    Use the plotting techniques in this section to plot the following. For each, hide the legend when ther e is only one curve\/set of data and label appropriate if more than one curve\/set of data. Include a title as well.   The function from to    The functions from to .   A scatter plot of the following:   Data for the scatter plot exercise    0 2 3 4 6 9 10  11 13 15 16 18 20    -1 4 3 6 2 0  2 9 5 -2 4 4  6 3      A surface plot of with .   A heat map of with .     Backends of the Plots package   The Plots.jl package actually doesn't do the plotting. It leaves the details to other packages. By default, Plots uses the GR backend although in this text I have used the PGFPlotsX backend which tends to print nicer. There are a number of backends that you may want to try. The standard ones are:     PyPlot (matplotlib): Slow but dependable    GR: Feature-rich and fast, but new    Plotly\/PlotlyJS: Interactive and good for web    PGFPlotsX: Native LaTeX rendering    UnicodePlots: Plots to unicode for situations without graphics capabilities.     To switch the backend, you type the backend name in all lowercase with a set of (). Note: you will need to add and load the package. Here is the plot of on various backends.   gr() plot(x->x^2,-2,2)   gives: \\begin{center} \\includegraphics[width=4in]{plots\/plots\/plot08.png} \\end{center}   using PlotlyJS plotlyjs() plot(x->x^2,-2,2)   results in: \\begin{center} \\includegraphics[width=4in]{plots\/plots\/plot09.png} \\end{center}  and then using PGFPlotsX pgfplotsx() plot(x->x^2,-2,2)   results in: \\begin{center} \\pgfplotsset{scale=0.6} \\plot{plots\/plots\/pgfplotsx.tex}{plots} \\end{center} and finally   using PyPlot pyplot() plot(x->x^2,-2,2)   results in: \\begin{center} \\includegraphics[width=4in]{plots\/plots\/plot11.png} \\end{center}  For additional information on the supported backends, visit the Plots.jl backend documentation     Changing the attributes of the plot  Let's return back to the function plots above (although this works for point\/line plots as well) and change many attributes of the curve. As an example:   plot([x->x^2,sin],-2,2,title=\"Two Curves\",label=[\"x squared\" \"sin(x)\"],xlabel=\"x\",ylabel=\"y\",lw=3)   results in \\begin{center} \\pgfplotsset{scale=0.7} \\plot{plots\/plots\/attrs.tex}{plots} \\end{center}  The format is fairly clear for the changing of the attributes. Note: in this example:     the title changes the title of the plot    the label changes the legend.    the xlabel and ylabel changes the axes labels.    the lw is the line weight.     To avoid duplicating tons of documentation, visit the Plots.jl page on attributes to find all of the information to get the plot the way you want.   Answer the following questions:   Take the scatterplot above (with the random dots) and change the color of the dots to darkgreen, change the markers to diamonds and the size of the points to about twice the default size.   On the function plot, make the line thicker and style to dashed.     "
},
{
  "id": "ch-plots-package-6-3",
  "level": "2",
  "url": "ch-plots-package.html#ch-plots-package-6-3",
  "type": "Check Your Understanding",
  "number": "15.1",
  "title": "",
  "body": " Use the plotting techniques in this section to plot the following. For each, hide the legend when ther e is only one curve\/set of data and label appropriate if more than one curve\/set of data. Include a title as well.   The function from to    The functions from to .   A scatter plot of the following:   Data for the scatter plot exercise    0 2 3 4 6 9 10  11 13 15 16 18 20    -1 4 3 6 2 0  2 9 5 -2 4 4  6 3      A surface plot of with .   A heat map of with .  "
},
{
  "id": "ch-plots-package-7-3-8",
  "level": "2",
  "url": "ch-plots-package.html#ch-plots-package-7-3-8",
  "type": "Check Your Understanding",
  "number": "15.3",
  "title": "",
  "body": " Answer the following questions:   Take the scatterplot above (with the random dots) and change the color of the dots to darkgreen, change the markers to diamonds and the size of the points to about twice the default size.   On the function plot, make the line thicker and style to dashed.  "
},
{
  "id": "ch-makie-adv",
  "level": "1",
  "url": "ch-makie-adv.html",
  "type": "Chapter",
  "number": "16",
  "title": "Advanced Plotting in Makie",
  "body": " Advanced Plotting in Makie   Plotting the Polynomial   MOVE THIS SECTION  Recall that using the Plots package, one can consider plotting the polynomial by creating a function that pulls out the coefficients. However, the Plots package has a related package called RecipesBase that allows one to create a plotting recipe. That is if p is a Polynomial , then we can write plot(p) and it will plot the polynomial. Let's see how and don't forget to add the package and then enter using RecipesBase .  The package RecipesBase includes the macro @recipe and although the documentation is sparse, this page is helpful in the background. The basic idea on a plot recipe is to do the following:    @recipe f(t::TheType,...)  end    where TheType is any datatype (either built-in or user defined). The recipe needs to return some number of vectors of points (depending on if it is 1D, 2D or a 3D plot). A simple version of this for type Polynomial is   @recipe function f(poly::Polynomial,xmin::Number=-2,xmax::Number=2) xpts = LinRange(xmin,xmax,200) ypts = map(x->eval(poly,x),xpts) xpts,ypts end   where line 2 creates an array of x values of length 200, then line 3 creates the y values for each x value. Line 4 returns a tuple of the pairs of points. We can now use this to plot a polynomial and we will need to using Plots to:    plot(poly1)    and since we defaulted the plot range from -2 to 2, we get the following plot: \\begin{center} \\pgfplotsset{scale=0.6} \\plot{plots\/comp-type\/plot01.tex}{poly} \\end{center}  and if we want to specify the plotting range:   plot(poly1,0,4)   we get \\begin{center} \\pgfplotsset{scale=0.6} \\plot{plots\/comp-type\/plot02.tex}{poly} \\end{center}    Changing other parameters  But wait... There's more... One of the fantastic things about using RecipesBase is that we can still use all of the other parameters associated with plot as we normally would. For example:    plot(poly1,0,4,linecolor=:orange,title=\"A quadratic\", lw=2, legend=false)    produces the plot: % \\begin{center} \\pgfplotsset{scale=0.5} \\plot{plots\/comp-type\/plot03.tex}{poly} \\end{center}    Setting Default parameters  Recipes also allow to set default parameters. Let's say that if we want to always plot a polynomial green without a legend that we can put these default parameters in the recipe:   @recipe function f(poly::Polynomial,xmin::Number=-2,xmax::Number=2) legend --> false linecolor --> :green xpts = LinRange(xmin,xmax,200) ypts = map(x->eval(poly,x),xpts) xpts,ypts end   If we have this definition then plot(poly1,0,4) produces the following plot: \\begin{center} \\pgfplotsset{scale=0.5} \\plot{plots\/comp-type\/plot04.tex}{poly} \\end{center}    "
},
{
  "id": "ch-probability-random",
  "level": "1",
  "url": "ch-probability-random.html",
  "type": "Chapter",
  "number": "17",
  "title": "Probability Distributions and Pseudorandom Numbers",
  "body": " Probability Distributions and Pseudorandom Numbers   One big part of scientific computation is the subject of Monte Carlo simulations in which random numbers are used to model some situation. We'll spend the next part of this course covering this subject.  I'm sure you have some sense of what probability is, that is a way to measure the randomness of something or how sure you are that something will happen. This chapter starts with basic definitions of probability and randomness and then covers both discrete and continuous probability distributions and then continue with a firm mathematical description. We will take a pause from coding to build up a bit of probability background.    Basic Defintions  An experiment is something that produces outcomes. The terminology arises from scientific experiments and may produce images of chemistry labs, however, it is more general than that. An experiment may be a chemistry lab with measurements, but could be a drug-effectiveness study with tens of thousands of individuals, and also may include flipping a coin.   Sample Space   The sample space of an experiment is the set of all possible outcomes.    In the example drug study, it may be the possible measurable levels in a blood sample of whatever is being analyzed. In the coin flip it is the set .   Sample Space   The sample space of flipping 3 coins is      Event   An event is a subset of the sample space.     Event   What is the event that you flip 2 heads out of 3 coins.    If we examine the set that has 2 heads out of the set in , then it is the set     It will be important to understand events as sets and will help finding other information.    If the number of elements in a sample space is finite and denoted , then we can find the probability that an event occurs with     where returns the number of elements in the set\/event .    Random Variables  We often will need to know what the probability that an event occurs. Because events correspond to elements of the space, we often examine how every element in the sample space behaves in some way.     A random variable is a function from the sample space to some real number.       Let's consider a six-sided die. The sample space is     Let be the number of dots on each die. Since is a function from the sample space to the integers (subset of the reals), is a random variable.      Let the sample space be that of the 3 coin flips from . Let be the number of in each coin flip.      Consider an experiment in which the amount of rain (in either inches or cm) is measured in your hometown on a given day. The sample space is or nonnegative real numbers. A random variable for this could simply be the amount of rain in the day.      Discrete Random Variables   A set is discrete if it either contains finite number of elements or if the number of elements are infinite, they can be ordered (technically mapped to the natural numbers). This is important because if the sample space is discrete or not will determine how we treat the probabilities. A random variable is discrete if the sample space is discrete. The examples above with the coin flip (either 1 or 3 coins) and the dice are examples of discrete random variables. The random variable in Example \\ref{ex:rain} is not.    If a random variable is discrete, that is, the underlying sample space is discrete, the probability distribution or probability density function or pdf is a function defined by for all , the sample space.    More colloquially, the probability density function gives the probability of every outcome in the sample space.    Consider the six-sided die. If the die is fair then the probability of each die coming up are the same.     We can plot the distribution with    using Plots  bar(1:6, [1\/6 for i=1:6], legend=false)    which results in the plot     (for accessibility)        Find the probability distribution of a 3-coin flip experiment, where is the number of heads. Assume the coin is fair.       We can plot distribution with    using Plots  bar(0:3, [1\/8,3\/8,3\/8,1\/8], legend=false)       (for accessibility)        Properties of a discrete probability distribution  A function let be the domain of a discrete random variable. The function is a probability density function if      for all .            Consider rolling two fair dice and let , the random variable be the sum of the number of dots on the dice. Find the probability density function.    Think about the two dice have different colors, a red die and a green die. Since each die have 6 outcomes, there are different outcomes and here are all the possible rolls (where the first number is the roll on the red die and the second number is the number on the green die).     Now to find , we need to determine the probability of each of sum of the dice. The values of can be any integer 2 through 12 and then the probability is the number of the sum over 36. For example, is because the only way to get a 2 is with the results (1,1). The value of because one can get 3 with a (1,2) or a (2,1). This logic continues for all values from 2 to 12. The values of are     A plot of this distribution is    bar(2:12,[(6-abs(i-7))\/36 for i=2:12], xticks=2:12, legend=false)       (for accessibility)         Continuous Probability   If a random variable is not discrete it is called a continuous random variable and generally occurs if the values it takes on are subsets of the real line. Let's consider a set or all real numbers between 0 and 1. Events are still subsets of the set , however the probability that events occur is the fraction of the set.    The following are examples of continuous random variables:     The amount of rain in Fitchburg on a given day as we saw above.    The length of time a cell phone battery will last until it ``dies.''    The amount of contaminant that a brewery dumps into the Nashua River.         The Calculus of Continuous Probabilities  The probability distribution function or pdf is a function, defined on a set with the following properties:     where the set is generally a real interval or the infinite or semi-infinite line. The first property ensures that probability will always be positive and the second property ensures that probabilities are at most 1 and only 1 with the entire set. Also, if is a continuous pdf, then the probability that a random variable takes on a value in the set is       Cumulative Distribution Functions  Another helpful function of random variables is that of the cumulative distribution function or cdf for a given pdf, . Denote , the cdf, which is defined as     or simply the antiderivative. Graphically, if we have a function as shown below, then represents the area under the curve to the right of the value .   Area under a probability density function.       Also, since is the antiderivative, then the cdf can be used to find the probability.   Let be a cdf where is the given pdf of the random variable . The probability can be found using        Inverse Cumulative Distribution Functions  There are many nice properties of , the cdf. We know:           .     is continuous.     is nondecreasing.     where some of these properties are explored in the exercises. The last 2 properties above result give that the function is one-to-one and therefore has an inverse. The function is called the inverse cumulative distribution function. The section above, showed the importance of evaluating a cdf for probabilities. That is given     evaluating for a given value of . We will see that it is just as important to solve for . This corresponds to the same plot as above:         where given a value of , we are seeking . Since , we also write . The function have the properties:      is increasing    The domain of is .     and in short, this function finds values for given probabilities values.     Standard Continuous Distributions   Uniform Distribution  The example above at the top of the previous section was an example of a uniform distribution with pdf:     It is clear that the property in (\\ref{eq:nonneg}) is satisfied and note that     so the property in is satisfied. Also if the set is defined as above as     then   .  Also, a plot of the distribution is          Find the pdf of a uniform distribution that is a positive constant on and 0 elsewhere. Note, you must find the value of so the pdf satisfies .     The Normal Distribution  Probably No pun intended. the most important continuous distribution is the normal distribution (also known as the bell curve) which is symmetric about some center value and tapers off to zero in both directions. An example is:         The shape of the normal distribution has two important parameters, the mean, , which is the line of symmetry and the standard deviation, which determines how spread out it is. The functional form of the pdf is        Pseudo Random Number Generator   In the next few chapters of the text, we will solving problems with random numbers. Thus far, we talked about flipping coins and rolling dice and we will also see about drawing cards from a shuffled deck. Since each of these is a physical process, we can't directly do them, however, we will simulate them with random numbers, and technically on a computer we will use a pseudorandom number generator.   A pseudo-random number generator is a function or procedure that produces a sequence of numbers that behave like random numbers. Let's examine what this means in terms of the discrete probability with discrete probability space which would generate a simulation of rolling a single fair die. If a pseudo-random number generator produces a sequence from this set then the sequence should have the following property:     If the event for any between 1 and 6, then . And by approximately, as the sequence gets larger, the approximation becomes closer to 1\/6.  Is this enough? No, the sequence     satisfies the above property, but I don't think anyone would consider this random. Another property would be:    If we know the sequence then we can't predict the next number .     This is obviously violated in the sequence above. A little more technical definition of a sequence of pseudo-random numbers Let\\\\ be a random sequence. Typically we mean the following properties need to hold:     any number in the range 1 to 6 is equally likely to occur.    Take random numbers and let be the number of times the number occurs. The fraction should go to 1\/6 in the limit as .    Knowing the sequence does not allow us to predict         Seeds and Pseudorandom Numbers  For pseudorandom numbers, the third condition above is not true. In fact, there is a function that generates the next number in the sequence or there is a function such that , however, it is not evident that there is such a function. Because pseudorandom numbers are generated with a function, it needs a number to determine the next one. This starting number is often chosen using the current date\/time, however, you can set this, called the seed. In julia, we can set the seed with the Random.seed! function.    using Random  Random.seed!(1234)    and any positive integer can be set here. Note: you don't need to set the seed for random numbers. It is useful in the case of writing a book in which you hope that the readers will follow along. In this case, everything should be randomly generated in an identical way.    Using Julia to simulate the rolling of a die  First, the main commands that are built-in to Julia are listed in the Julia Manual for Random Numbers . We can generate 10 random numbers between 1 and 6 using    S=rand(1:6,10)    which returns the array [2, 4, 2, 6, 3, 3, 6, 5, 3, 5] .  Notice that if you rerun the command, you'll get a different sequence of random numbers. We can check that this is doing what we expect by checking the probability that we get a 1 (or any other number).    Coin flips in Julia  We can flip coins by selecting a random boolean. For example, the following will simulate 10 coin flips.    coins=rand(Bool,10)    which returns the array [0, 0, 0, 1, 1, 0, 1, 0, 1, 0] This is a boolean Vector , note the Bool at the beginning. The 1s represent true and 0, false for compactness. Generally, as we did above, we will flip multiple coins and ask questions about the number of heads. We will examine this in the next chapter. If we are interested in unfair coin flips, we can choose randomly from an array where the unfair balance is known. For example,    rand([false,false,false,true,true],10)    gives 10 coin flips or the array [0 ,0 ,0 ,1 ,1 ,1 ,1 ,1 ,0 ,0] as a weighted coin where and .    Floating Point random numbers  For continuous random variable, like the uniform distribution or the Normal distribution, there are some different properties of the pseudo random number generate. Assume that the floating point number is in the range . Then the sequence is random if     The fraction of values within the interval is .    Knowing the sequence does not allow us to predict .     To generate an array of 20 random numbers distributed uniformly on , type    S=rand(20)    which returns    20-element Vector{Float64}:  0.3020595409518265  0.05842018425830109  0.20552381705814504  0.7079246996200363  0.41775698944882156  0.22721762712581473  0.7836312465908486  0.20071380866783706  0.6020380841683062  0.5653680870733934  0.7008893474454004  0.4527965951678993  0.13067526601187207  0.4578870482605456  0.6665192594508963  0.5008741327606322  0.8106990681415074  0.46484850303763725  0.9770123967639948  0.5001612179097075       The Normal Distribution  The normal distribution is the most important continuous distributions. We can investigate it with the Distributions package in julia:    using Distributions    To produce a standard normal (mean of 0, standard deviation of 1),    std_normal = Normal()    which returns Normal{Float64}(μ=0.0, σ=1.0) and notice the mean and standard deviation are what we expect. Other means and standard deviations can be found by adding arguments. We can plot the normal distribution with    using StatsPlots  plot(std_normal)       (for accessibility)    To generate an array of normally distributed values,    random_normals = rand(std_normal,10)    returns    10-element Vector{Float64}:  2.121560382124172  -0.26224077844309135  0.3455010838287982  0.44394906831563774  0.44133351371484625  -1.3397752732187238  0.21507132788419303  0.28927403687088354  -0.6365687810422291  -0.8196796137020412      Other Distributions  Julia has many other distributions available in the Distributions package and the best place to start is at the Distributions package website    "
},
{
  "id": "ch-probability-random-3-2",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-3-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "experiment "
},
{
  "id": "ch-probability-random-3-3",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-3-3",
  "type": "Definition",
  "number": "17.1",
  "title": "Sample Space.",
  "body": " Sample Space   The sample space of an experiment is the set of all possible outcomes.   "
},
{
  "id": "ex-three-coins",
  "level": "2",
  "url": "ch-probability-random.html#ex-three-coins",
  "type": "Example",
  "number": "17.2",
  "title": "Sample Space.",
  "body": " Sample Space   The sample space of flipping 3 coins is    "
},
{
  "id": "ch-probability-random-3-6",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-3-6",
  "type": "Definition",
  "number": "17.3",
  "title": "Event.",
  "body": " Event   An event is a subset of the sample space.   "
},
{
  "id": "ch-probability-random-3-7",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-3-7",
  "type": "Example",
  "number": "17.4",
  "title": "Event.",
  "body": " Event   What is the event that you flip 2 heads out of 3 coins.    If we examine the set that has 2 heads out of the set in , then it is the set     It will be important to understand events as sets and will help finding other information.   "
},
{
  "id": "ch-probability-random-4-3",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-4-3",
  "type": "Definition",
  "number": "17.5",
  "title": ".",
  "body": "   A random variable is a function from the sample space to some real number.   "
},
{
  "id": "ch-probability-random-4-4",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-4-4",
  "type": "Example",
  "number": "17.6",
  "title": ".",
  "body": "   Let's consider a six-sided die. The sample space is     Let be the number of dots on each die. Since is a function from the sample space to the integers (subset of the reals), is a random variable.   "
},
{
  "id": "ch-probability-random-4-5",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-4-5",
  "type": "Example",
  "number": "17.7",
  "title": "",
  "body": "  Let the sample space be that of the 3 coin flips from . Let be the number of in each coin flip.   "
},
{
  "id": "ch-probability-random-4-6",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-4-6",
  "type": "Example",
  "number": "17.8",
  "title": "",
  "body": "  Consider an experiment in which the amount of rain (in either inches or cm) is measured in your hometown on a given day. The sample space is or nonnegative real numbers. A random variable for this could simply be the amount of rain in the day.   "
},
{
  "id": "ch-probability-random-5-2-1",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-5-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "discrete discrete "
},
{
  "id": "ch-probability-random-5-2-2",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-5-2-2",
  "type": "Definition",
  "number": "17.9",
  "title": "",
  "body": "  If a random variable is discrete, that is, the underlying sample space is discrete, the probability distribution or probability density function or pdf is a function defined by for all , the sample space.   "
},
{
  "id": "ch-probability-random-5-2-4",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-5-2-4",
  "type": "Example",
  "number": "17.10",
  "title": "",
  "body": "  Consider the six-sided die. If the die is fair then the probability of each die coming up are the same.     We can plot the distribution with    using Plots  bar(1:6, [1\/6 for i=1:6], legend=false)    which results in the plot     (for accessibility)     "
},
{
  "id": "ch-probability-random-5-2-5",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-5-2-5",
  "type": "Example",
  "number": "17.12",
  "title": "",
  "body": "  Find the probability distribution of a 3-coin flip experiment, where is the number of heads. Assume the coin is fair.       We can plot distribution with    using Plots  bar(0:3, [1\/8,3\/8,3\/8,1\/8], legend=false)       (for accessibility)     "
},
{
  "id": "ch-probability-random-5-3-4",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-5-3-4",
  "type": "Example",
  "number": "17.14",
  "title": "",
  "body": "  Consider rolling two fair dice and let , the random variable be the sum of the number of dots on the dice. Find the probability density function.    Think about the two dice have different colors, a red die and a green die. Since each die have 6 outcomes, there are different outcomes and here are all the possible rolls (where the first number is the roll on the red die and the second number is the number on the green die).     Now to find , we need to determine the probability of each of sum of the dice. The values of can be any integer 2 through 12 and then the probability is the number of the sum over 36. For example, is because the only way to get a 2 is with the results (1,1). The value of because one can get 3 with a (1,2) or a (2,1). This logic continues for all values from 2 to 12. The values of are     A plot of this distribution is    bar(2:12,[(6-abs(i-7))\/36 for i=2:12], xticks=2:12, legend=false)       (for accessibility)     "
},
{
  "id": "ch-probability-random-6-2-1",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-6-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "continuous random variable "
},
{
  "id": "ch-probability-random-6-2-2",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-6-2-2",
  "type": "Example",
  "number": "17.16",
  "title": "",
  "body": "  The following are examples of continuous random variables:     The amount of rain in Fitchburg on a given day as we saw above.    The length of time a cell phone battery will last until it ``dies.''    The amount of contaminant that a brewery dumps into the Nashua River.      "
},
{
  "id": "ch-probability-random-6-3-2",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-6-3-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "pdf "
},
{
  "id": "ch-probability-random-6-4-2",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-6-4-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "cumulative distribution function "
},
{
  "id": "fig-pdf",
  "level": "2",
  "url": "ch-probability-random.html#fig-pdf",
  "type": "Figure",
  "number": "17.17",
  "title": "",
  "body": " Area under a probability density function.      "
},
{
  "id": "ch-probability-random-6-4-7",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-6-4-7",
  "type": "Remark",
  "number": "17.18",
  "title": "",
  "body": " Let be a cdf where is the given pdf of the random variable . The probability can be found using     "
},
{
  "id": "fig-pdf-2",
  "level": "2",
  "url": "ch-probability-random.html#fig-pdf-2",
  "type": "Figure",
  "number": "17.19",
  "title": "",
  "body": "      "
},
{
  "id": "fig-uniform",
  "level": "2",
  "url": "ch-probability-random.html#fig-uniform",
  "type": "Figure",
  "number": "17.20",
  "title": "",
  "body": "      "
},
{
  "id": "ch-probability-random-7-2-12",
  "level": "2",
  "url": "ch-probability-random.html#ch-probability-random-7-2-12",
  "type": "Check Your Understanding",
  "number": "17.21",
  "title": "",
  "body": " Find the pdf of a uniform distribution that is a positive constant on and 0 elsewhere. Note, you must find the value of so the pdf satisfies .  "
},
{
  "id": "fig-normal",
  "level": "2",
  "url": "ch-probability-random.html#fig-normal",
  "type": "Figure",
  "number": "17.22",
  "title": "",
  "body": "      "
},
{
  "id": "fig-std-normal",
  "level": "2",
  "url": "ch-probability-random.html#fig-std-normal",
  "type": "Figure",
  "number": "17.23",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-prob-models",
  "level": "1",
  "url": "ch-prob-models.html",
  "type": "Chapter",
  "number": "18",
  "title": "Using Random Numbers and Probability Models",
  "body": " Using Random Numbers and Probability Models   To understand basic probability, often problems are examined that use combinatorics or counting techniques to solve them. Consider    A round table has 7 chairs around it. Mary and her friend Alisha and 5 other people are given seats at the table in a random manner. What is the probability that Mary and Alisha sit next to each other?    Although it is an good skill to solve problems like these using counting techniques, we examine some ways to use simulation to find the solution in this chapter.  Before getting started, we will set the seed so the random numbers that appear here will match those if you, the reader, run these same commands  using Random  Random.seed!(1234)      Flipping Coins   Recall as we showed in , we can generate 100 coin flips by    coins = rand(Bool,100)    (Note: the result looks like an array of 0s and 1s, but look at the type, Vector{Bool} , which says it is a vector or 1-dimensional boolean array.)  We can determine the number of heads (when the result is 1), by sum(coins) which is 58 .    Flipping multiple coins  Another simple example is to flip multiple coins and generally count the number of heads or tails seen. Consider flipping 3-coins--perhaps a penny, nickel and dime--and counting the number of heads. We then do that 3-coin flip a larger number of times.  We can do this with  coins3 = rand(Bool,100,3)    and the top 10 lines of this is:    100×3 Matrix{Bool}:  1 1 0  0 0 1  1 0 0  0 1 1  0 1 1  0 1 0  1 0 1  0 0 1  1 0 0  0 0 0    Each row contains the coin flips. Each 1 represents a head and 0 is a tail. If we are interested in the sum of the number of heads, we can do this with the mapslices functions seen in .    num_heads = mapslices(sum,coins3;dims=[2])    The first few elements of the array is [2; 1; 1; 2; 2; 1; 1; 0 ...] We can plot the results of this with the function    using Plots  histogram(num_heads,nbins=4, legend=false)    and the result is     (for accessibility)    This plot is quite easy to generate, but a bit confusing. What does the bar between 0 and 1 mean. This is mainly because the histogram function is more useful for continuous data than discrete data. We'll recreate this plot piece by piece and get the results we want. First, start with the StatsBase package (and you may need to add the package) and then load it with    using StatsBase    and then the counts function ( Read the online documentation ) can be used:    dice_count = counts(num_heads,0:3)    returns a vector of how many of number of heads fall into each number. The result is the vector [8 39 43 10] .  and a nicer way to plot the histogram is  bar(0:3,dice_count\/sum(dice_count),legend=false)       (for accessibility)    which generates an approximate probability distribution for flipping 3 coins and s umming the number of heads. Compare this with the plot of the distribution in which uses the definition of probability.  And to compare the simulation with the probability density function that we found in , we will plot a side-by-side comparison of the two with the following. Note that the function groupedbar is part of the StatsPlots package:    using StatsPlots  groupedbar(0:3,hcat(dice_count\/sum(dice_count), [1\/8,3\/8,3\/8,1\/8]), label=[\"simulation\" \"pdf\"])       (for accessibility)    A couple of things to note:   In the groupedbar function, the 0:3 is the horizontal range and the vertical range has two pieces (because of the hcat function). The first is the random data (switched to a fraction) and the second is the distribution of the number of heads out of 3 coin flips.    It is important in the label that the two labels are string separated by a space and not a comma. (See what happens if you put a comma there.)        Rolling Dice  A relatively-simple example is that of rolling dice. As we saw in , if we have a fair, six-sided die, the the probability of any of the numbers coming up is 1\/6. We can simulate that using random numbers in the following way:    S100 = rand(1:6,100)    generated 100 numbers taken from the set . Running this command Don't forget that when running code with random numbers, you won't get the exact same results, but the spirit should be the same. results in a vector of length 100 with random numbers between 1 and 6.  The principal of the Law of Large Numbers is that as a experiment is repeated, as the number of times increases, the distribution of results tends toward the underlying distribution. If we determine if this is true, as the number of time we roll a die increases, the probability of any one number appearing gets closer to 1\/6. For example, to test this, try  p = count(a->a==3,rand(1:6,1_000))  and then evaluating p\/1_000 results in 0.190 , which is reasonably close to 1\/6.   Trying increasing the number of random numbers used in the above example. You should notice that as that number gets larger, the resulting probability gets closer to 1\/6.   What does  p = count(a -> a % 2 == 0, rand(1:6,1000))    measure in the sense of a rolling a fair 6-sided die? Does the result make sense?     Rolling 2 dice  How do we handle the rolling of two dice? Here's an array with each row having 2 dice. This would be a simulation of rolling 10,000 pairs of dice.   dice2=rand(1:6,10_000,2)   and then to find the sum of the dice:   dsum = mapslices(sum,dice2;dims=[2])   which sums along the rows. This is 10,000 rolls of 2 dice with the sum recorded. First, to get an idea of the distribution of the dice sums, let's plot the histogram (but use the bar command):    bar(2:12,counts(dsum,2:12)\/sum(dsum), legend=false, xticks=2:12)    where xticks gives the tick marks on the x-axis. The plot generated is     (for accessibility)     Use the dsum variable above, to estimate the probability that you     roll a 7.    roll a 10 or greater.    roll an even number.      Plot the simulated dice rolls with the pdf from .     Other Probability Models   Let's return to the problem that problem at the beginning of this section. We will solve this problem using the random modeling in this chapter.  First let's first store the names of the people at the take as an array    table_names = [\"Alisha\", \"Mary\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\"]    where we use generic names for the other 5 people. Although variable name usually don't matter what they are called, names cannot be used. There are many function and variable names that cannot be used. This is one example. We will take random permutations of this array below and the determine if Alisha and Mary are next to each other.  Before we find a random permutation, let's write a function that takes an array of names and returns true if they are next to each other and false if not.   function nextToEachOther(names::Vector{String}) # return true or false end   Here's a way to think about this:     Find the position in the array where Alisha is sitting.    Find the position in the array where Mary is sitting.    Determine if the two numbers are next to each other. Don't forget that this could include positions 1 and 7.     The following is a relatively simple function is   function nextToEachOther(names::Vector{String}) a = findfirst(name -> name==\"Alisha\",names) m = findfirst(name -> name==\"Mary\",names) abs(a-m) == 1 || abs(a-m) == length(names)-1 end   where the findfirst function returns the index of the array where the function is true (that is where the two friends are sitting). To test this:    nextToEachOther([\"Alisha\", \"Mary\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\"])    returns true .    nextToEachOther([\"Alisha\", \"p1\", \"Mary\", \"p2\", \"p3\", \"p4\", \"p5\"])    returns false .    nextToEachOther([\"Alisha\",\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"Mary\"])    returns true .    Random Permutations  We now return to the problem to study the probability. The shuffle command in the Random package The Random package is a built-in package and doesn't need to be added, but just enter using Random takes any array and shuffles (permutes) the contents in a random manner. For example:    shuffle(table_names)    returns [\"p3\" \"Alisha\" \"Mary\" \"p5\" \"p2\" \"p4\" \"p1\"] , then we can test if they are sitting next to each other. The follow repeats this a large number of times:   function numTimes(trials::Integer) s = 0 # keeps track of how many times they sit next to each other for i=1:trials if nextToEachOther(shuffle(table_names)) s += 1 end end s\/trials end   and then the fraction of times is found with numTimes(10_000) resulting in 0.3303 .  The true value of the probability can be found in the following way. Mary sits in one of the seven chairs. Alisha has a equal chance of sitting in one of the remaining 6 chairs. Two of the chairs are next two Mary, so the probability is 2\/6 or 1\/3. The result we see above is close to this value.     Calculating using pseudo random numbers   You probably know the first handful of digits of and recall that probably the first place that you saw this was with circles. But how do we know what the digits of actually are. There are a number of ways to find the digits of and in fact, presents some interesting ways of calculating it.  Here we will present two ways to calculate using random numbers.    Buffon's Needle Experiment  In the 18th Century, Georges-Louis Leclerc, Comte de Buffon considered the following problem. On a floor (or table), draw lines that are parallel and units apart. Toss needles of length onto the floor and count the number that cross one of the lines. The following diagram is helpful:         A probability analysis shows that the probability that any needle crosses a line is:     if .  So theoretically, one could sit and toss needles onto a floor to determine the value of by counting the number that cross the lines and those that don't. This would be tedious and possibly prone to error as the number of needles rises.  More details on this experiment is given on the wikipedia page     Circle in the Square  The Buffon Needle experiment is fascinating in many ways but there is a much easier way to generate results in a computer simulation. This is called the Circle in the Square approach.  Consider a square given by , which is just the first unit in both and in the first quadrant. We generate a number of random points (technically they are uniformly distributed). Consider    pts=rand(100,2)  scatter(pts[:,1],pts[:,2], aspect_ratio=:equal, legend=false)       (for accessibility)    If we draw a circular arc and then count the number of points within the arc:    scatter(pts[:,1],pts[:,2], aspect_ratio=:equal, legend=false)  plot!(cos,sin,0,pi\/2)       (for accessibility)    The fraction of points should be about the fraction of the area within the arc or . (Note: the plot! function plots on top of the current plot instead of making a new one. It also performs a parametric plot--see --of the circle.)  We can calculate this value by first using the mapslices function on each row to calculate the distance  dist=mapslices(pt->sqrt(pt[1]^2+pt[2]^2),pts;dims=[2])    and then count the number of the points within the circle or the distance is less than 1.    numpts = count(d -> d < 1, dist)    and the results is 77 . Since the fraction of the points is an estimate for , then we can say that     so in this case the estimate is 3.08 . Clearly this is a terrible estimate of , but increasing the number of points should improve it.  Instead of just repeating the same code with a different number of points, we will create a function that estimates based on the number of points originally.   function calcPi(total_points::Integer) pts=rand(total_points,2) dist=mapslices(pt -> pt[1]^2+pt[2]^2, pts; dims=[2]) 4*count(d -> d < 1,dist)\/total_points end   and we haven't included the square root in the distance calculation because all we are trying to determine is which points are within the unit circle. This uses the square distance, so the result is the same.  Let's run it with 10,000 points using the command:   approx_pi = calcPi(10_000)   and we get the result 3.1632    for , and find the relative error of the estimate using your function and using the built-in value pi .   Recall that earlier in the book, we determine that creating an array is one of the slower parts of code. In this case, it is not needed. Rewrite the calcPi function to not generate a matrix of total_points rows.   Write a for loop and inside the loop generate a single point and determine whether or not it is in the circle. Time this version and compare to the calcPi above.     "
},
{
  "id": "fig-coins3-sim",
  "level": "2",
  "url": "ch-prob-models.html#fig-coins3-sim",
  "type": "Figure",
  "number": "18.1",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-coins3-sim-improved",
  "level": "2",
  "url": "ch-prob-models.html#fig-coins3-sim-improved",
  "type": "Figure",
  "number": "18.2",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-coins3-compare",
  "level": "2",
  "url": "ch-prob-models.html#fig-coins3-compare",
  "type": "Figure",
  "number": "18.3",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-prob-models-4-6",
  "level": "2",
  "url": "ch-prob-models.html#ch-prob-models-4-6",
  "type": "Check Your Understanding",
  "number": "18.4",
  "title": "",
  "body": " Trying increasing the number of random numbers used in the above example. You should notice that as that number gets larger, the resulting probability gets closer to 1\/6.   What does  p = count(a -> a % 2 == 0, rand(1:6,1000))    measure in the sense of a rolling a fair 6-sided die? Does the result make sense?  "
},
{
  "id": "fig-dice2",
  "level": "2",
  "url": "ch-prob-models.html#fig-dice2",
  "type": "Figure",
  "number": "18.5",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-prob-models-5-10",
  "level": "2",
  "url": "ch-prob-models.html#ch-prob-models-5-10",
  "type": "Check Your Understanding",
  "number": "18.6",
  "title": "",
  "body": " Use the dsum variable above, to estimate the probability that you     roll a 7.    roll a 10 or greater.    roll an even number.      Plot the simulated dice rolls with the pdf from .  "
},
{
  "id": "fig-buffon",
  "level": "2",
  "url": "ch-prob-models.html#fig-buffon",
  "type": "Figure",
  "number": "18.7",
  "title": "",
  "body": "      "
},
{
  "id": "fig-circle100",
  "level": "2",
  "url": "ch-prob-models.html#fig-circle100",
  "type": "Figure",
  "number": "18.8",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-circle100a",
  "level": "2",
  "url": "ch-prob-models.html#fig-circle100a",
  "type": "Figure",
  "number": "18.9",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "sect-calc-pi-prob-4-22",
  "level": "2",
  "url": "ch-prob-models.html#sect-calc-pi-prob-4-22",
  "type": "Check Your Understanding",
  "number": "18.10",
  "title": "",
  "body": " for , and find the relative error of the estimate using your function and using the built-in value pi .   Recall that earlier in the book, we determine that creating an array is one of the slower parts of code. In this case, it is not needed. Rewrite the calcPi function to not generate a matrix of total_points rows.   Write a for loop and inside the loop generate a single point and determine whether or not it is in the circle. Time this version and compare to the calcPi above.  "
},
{
  "id": "ch-poker",
  "level": "1",
  "url": "ch-poker.html",
  "type": "Chapter",
  "number": "19",
  "title": "Simulating Poker Hands",
  "body": " Simulating Poker Hands   This chapter will analyze poker hands using the idea of the last two chapters. If you are unfamiliar with poker or the hands of poker, here's a quick synopsis and the Wikipedia page on Poker Hands is quite helpful. And recall from that a card has both a rank (Ace, 2--10, Jack, Queen, King) and a suit (hearts, diamonds, clubs and spades).  In this chapter, we are only concerned with 5 cards with no jokers and just determining if a hand satisfies one of the following:      Royal Flush: the ranks of the cards are 10, J, Q, K, A and all cards have the same suit.     Straight Flush: the ranks are sequential and all cards have the same suit. We will allow Ace to be both high (as in a Royal Flush) and low, like, A, 2, 3, 4, 5.     Flush: All cards have the same suit. We will exclude straight flushes, but ace can be high or low.     Straight: The ranks of the 5 cards are sequential. Again, we will exclude straight flushes.     Four of a kind: four of the cards have the same rank     Full House: two cards have the same rank, the other three cards have the same rank. The suit doesn't matter.     Three of a kind: three of the cards have the same rank. The other two cards do not have the same rank. The suit of the cards doesn't matter and also, make sure that the other two cards are not a pair or that would be a full house.     Two pairs: Two cards have the same rank. Two of the remaining cards have the same rank, but different than the first two pair. The 5th card does not make it a full house.     One pair: two cards have the same rank. The remaining cards do not make it a different type of hand (full house, three of a kind, etc.)     No pair or nothing: the cards don't form any other hand. This is also called High Card , in that if comparing hands, the highest card in the hand is important.       A user-defined package   In , we will create a module, but it is helpful for the topics in this chapter to use that module. Download PlayingCards.jl from ???. This module contains the Card and Hand types we developed in .  This is a module\/package, which like other packages, need to be loaded with either the using or import keyword. Since this is just a file in the current directory, we first run the file and then load it    include(\"PlayingCards.jl\")  using .PlayingCards    where the . represents a local (current directory) module. Note that when running a module that has been added (downloaded), no . is needed before its name.  Once we have the function written, we should test it on a few known and unknown full house hands. Try testing:    fh1 = Hand([Card(4,1),Card(4,3),Card(4,4),Card(7,1),Card(7,2)])  fh2 = Hand([Card(4,1),Card(4,3),Card(7,4),Card(7,1),Card(7,2)])  fh3 = Hand([Card(2,1),Card(4,3),Card(4,4),Card(7,1),Card(7,2)])    As entering these, you will see The first 2 are full house hands and the last is not.    Writing a Full House function  To use simulation, we will need to write a function that will determine if a hand is a full house. First of all, a function template for this will look like:    function isFullHouse(h::Hand)   end    and this should return true if h is a full house and false if not.  We are using the naming convention that if the function returns a boolean then start with is or has .  Here's some other things to think about:     Recall that the individual cards are stored in the cards field of the Hand struct. So within the function, we can access the cards with h.cards and this is an array of Card s.    We can access the individual cards using array notation, so the first card in the hand is h.cards[1] .    Recall that the rank of a card is with the rank field and the suit is in the suit field. So the rank of the 3rd card could be accessed with h.cards[3].rank .     Now before just diving into this function, if we try to determine all the possible ways to have a full house that's a lot. That is, if the full house has sevens and threes, the sevens could be in the first card, fourth card and fifth card. But there are many other combinations. The order of the cards doesn't matter (and often if you are playing a game with cards in that you can see your hand, you move them around), so we will first sort the cards to help us.  Within the function, if we call    local r = sort(map(c -> c.rank, h.cards))    This will result in a sorted array of the ranks of each of the cards in your hand. If we have the hand fh1 above, the r array will be [4 4 4 7 7] .  We have now reduced the problem, to a much more manageable set of options. First, if there is a full house on a hand, there are two possibilities: 1) the first three ranks are equal and the last two ranks are equal or 2) the first two ranks are equal and the last three ranks are equal.  We could put this in code, however, there's even a bit easier way. For any full house, the first two cards are equal and the last two are equal. Then either the 2nd and 3rd card or 3rd and 4th cards' ranks are equal, but not both. We can write this in the following way:   function isFullHouse(h::Hand) local r=sort(map(c -> c.rank,h.cards)) r[2]==r[1] && r[5]==r[4] && r[2] != r[4] && (r[3]==r[2] || r[4]==r[3]) end   Let's test this function on these three hands with:    isFullHouse(fh1),isFullHouse(fh2),isFullHouse(fh3)    which returns (true, true, false) indicating that the first two are full houses and the last is not.     Simulating Poker Hands   Now that we have a function to test if a hand is a full house, we want to perform a Monte Carlo simulation on a large number of poker hands and test if this gives the result we want. An easier way to do this is to develop a function that tests many different hands. In general, testing each is called a trial, so we'll have following which passes in a function that takes a hand and a number of trials and returns the fraction of times that hand satisfies that function. First, here's the runTrial function.   using Random function runTrials(f::Function, trials::Integer) local deck=collect(1:52) # creates the array [1,2,3,...,52] local num_hands=0 for i=1:trials shuffle!(deck) h = Hand(map(Card,deck[1:5])) # creates a hand of the first five cards of the shuffled deck if(f(h)) num_hands+=1 end end num_hands\/trials end   Here's a few ideas about this function:     The argument of the function includes a function. We will pass the isFullHouse function into the runTrial function.    Line 3 creates an array from 1 to 52. We will use this to create a hand later.    The variable num_hands will store how many hands will result in passed in function being true.    The function shuffle! shuffles the array called deck in line 6. Recall that any julia function with a ! modifies the function arguments, so this modifies the deck array instead.    Line 7 creates a hand from the first five values of the array in deck . This uses the constructor for a card based on an integer between 1 and 52.     If we run this with the command:    runTrials(isFullHouse,1_000_000)    This returns 0.001408 , which means that the probability of drawing a full house is 0.1408%.    Results of the simulation  Is the result of this simulation accurate? Similar to some of the counting techniques that we saw in , we can determine the probability of a full house by counting all poker hands that are full houses and dividing by the total number of poker hands. This is explained in the Wikipedia site for Poker Probabilities . Looking at full house line in the table, the probability of a full house in 0.1441\\%, so this isn't bad. If we increased the number of hands, we would expect to get closer to the true answer.  Run the full house simulation for 10 million hands (and 100 million hands if it doesn't take too long) and determine the probability of a full house. Did you get a better result?     Probabilities of Other Hands   Ultimately, it would be nice to have functions that determine if a hand is any of the ones listed at the top. We will cover two others, two pair and a flush, however the hardest part of doing this is making sure that functions aren't double counted. For example, if we have an isFlush function, then we need to make sure that straight flushes and royal flushes aren't counted. Within the isFlush function, we could call isRoyalFlush and isStraightFlush however, it's easy to get into a circular call if either of these call isFlush .    Helping Functions for the Poker Hands  To help out with this problem, we will first create two functions isOneSuit , which tests if all cards have the same suit and hasRun to test if a hand has a run of five cards. Each of the functions we've discussed will then call them without getting into a circular problem.  The first function is fairly straightforward with:   function isOneSuit(h::Hand) local s = map(c -> c.suit,h.cards) s[1]==s[2]==s[3]==s[4]==s[5] end   Notice that first, if we are testing all suits are equal, there is no reason to sort like we did in the previous two functions. Also, the line 3 of the function is a shortcut for  s[1]==s[2] && s[2]==s[3] && s[3]==s[4] && s[4]==s[5]    which would work fine as well, but the above is clear and shorter to write.  Similarly, the following will test for a run:   function hasRun(h::Hand) local r = sort(map(c->c.rank,h.cards)) r[2]==r[1]+1 && r[3]==r[2]+1 && r[4]==r[3]+1 && r[5]==r[4]+1 || r[1]==1 && r[2]==10 && r[3]==11 && r[4]==12 && r[5]==13 ## ace high run end   The 2nd line of the function tests a run by checking if each element of the array is one more than the previous one.   Test the two functions we just wrote to make sure that they work.   Test isOneSuit by creating two hands that is only one suit and two hands that are multiple suits. Make sure the function returns the correct answer.   Test HasRun by creating two hands that has a run and two hands that don't. Make sure the function returns the correct answer.     Building a Royal Flush function  Now that we have a isOneSuit and an hasRun functions, we can more easily build the following functions: isRoyalFlush , isStraightFlush and isStraight   We'll start with checking for a royal flush. Simply we need to check if it is one of suit and has a run where it is an ace-high run. The following will do this:   function isRoyalFlush(h::Hand) local r = sort(map(c -> c.rank,h.cards)) r[1]==1 && r[2]==10 && r[3]==11 && r[4]==12 && r[5]==13 && isOneSuit(h) end   Even though we could call the hasRun function, since we are only looking for an ace-high run, we copy the rank information over and then test additionally if it is one suit. Because there are so few royal flushes, we need to do many trials to detect. If we enter    runTrials(isRoyalFlush,10_000_000)    then we get 7.0e-7 , which is the floating point version of which is close to the actual probability.   Write isStraightFlush and isStraight functions. In order to eliminate other hands:   Write the isStraightFlush function first, by 1) checking if it has a run, 2) checking that is is one one suit and 3) checking that it is not a royal flush. This can be done in one compound boolean statement.   Write the isStraight function by 1) checking it has a run 2) checking it is not a royal flush 3) checking it is not a straight flush. Again, this can be done in one compound boolean statement.     Building a Two Pair function  Similar to the full house function, we will pull out the ranks of the hand since that is all that matters and sort the results. The we have three possibilities:     The first and second card ranks and 3rd and 4th card ranks are equal.    The first and second card ranks and 4th and 5th card ranks are equal.    The second and third card ranks and 4th and 5th card ranks are equal.     We can build a compound boolean statement with ors between these. The following is a possibility:   function isTwoPair(h::Hand) local r = sort(map(c -> c.rank,h.cards)) (r[1]==r[2] && r[3] == r[4]) || (r[1]==r[2] && r[4] == r[5]) || (r[2]==r[3] && r[4] == r[5]) end   and note that we have split the statement over the last three lines just for readability. If we run this with    two_pair = runTrials(isTwoPair,1_000_000)    the result is 0.049242 . Looking at the results from the Wikipedia Poker Probability page, which says that the probability is 4.7539\\%, this looks high. You could try to run this again or with higher number of trials, but there's another reason this could be high.  Since the results are larger than expected, we are probability counting other hands that we shouldn't. It seems that the other hands we are counting could include 4 of a kind and full house. The best way to handle this would to eventually build up all of the various types of hands. Inside the isTwoPair function we could then test for these three and return false if any are true.   function isTwoPair(h::Hand) local r = sort(map(c -> c.rank,h.cards)) ! isFullHouse(h) && # ! isFourOfAKind(h) ## remove the # at the beginning of the line if you have a isFourOfAKind function ( (r[1]==r[2] && r[3] == r[4]) || (r[1]==r[2] && r[4] == r[5]) || (r[2]==r[3] && r[4] == r[5]) ) end   Write an isFourOfAKind function, test it and then update the isTwoPair function to exclude any four of a kind hands from being counted.     Summary of Simulation  Take this chapter as an example of how to use simulation to solve problems. In short, if there is any randomization that occurs in a problem, using techniques as shown here might be a way to solve them.   "
},
{
  "id": "ch-poker-4-3-3",
  "level": "2",
  "url": "ch-poker.html#ch-poker-4-3-3",
  "type": "Check Your Understanding",
  "number": "19.1",
  "title": "",
  "body": "Run the full house simulation for 10 million hands (and 100 million hands if it doesn't take too long) and determine the probability of a full house. Did you get a better result? "
},
{
  "id": "ch-poker-5-3-10",
  "level": "2",
  "url": "ch-poker.html#ch-poker-5-3-10",
  "type": "Check Your Understanding",
  "number": "19.2",
  "title": "",
  "body": " Test the two functions we just wrote to make sure that they work.   Test isOneSuit by creating two hands that is only one suit and two hands that are multiple suits. Make sure the function returns the correct answer.   Test HasRun by creating two hands that has a run and two hands that don't. Make sure the function returns the correct answer.  "
},
{
  "id": "ch-poker-5-4-8",
  "level": "2",
  "url": "ch-poker.html#ch-poker-5-4-8",
  "type": "Check Your Understanding",
  "number": "19.3",
  "title": "",
  "body": " Write isStraightFlush and isStraight functions. In order to eliminate other hands:   Write the isStraightFlush function first, by 1) checking if it has a run, 2) checking that is is one one suit and 3) checking that it is not a royal flush. This can be done in one compound boolean statement.   Write the isStraight function by 1) checking it has a run 2) checking it is not a royal flush 3) checking it is not a straight flush. Again, this can be done in one compound boolean statement.  "
},
{
  "id": "ch-poker-5-5-11",
  "level": "2",
  "url": "ch-poker.html#ch-poker-5-5-11",
  "type": "Check Your Understanding",
  "number": "19.4",
  "title": "",
  "body": "Write an isFourOfAKind function, test it and then update the isTwoPair function to exclude any four of a kind hands from being counted. "
},
{
  "id": "ch-adv-functions",
  "level": "1",
  "url": "ch-adv-functions.html",
  "type": "Chapter",
  "number": "20",
  "title": "Advanced Function Features of Julia",
  "body": " Advanced Function Features of Julia   This chapter covers a bit more on functions in julia. These feature allow the ability to write code that easier to use, read and debug. We will perform error checking for arguments to ensure that only valid arguments are considered. Additionally, to make functions more robust, we'll use option arguments and keyword arguments.    Testing Arguments  Let's return to the factorial function that we saw in :    fact(n::Integer) = n==0 ? 1 : n*fact(n-1)    We saw before that if we call this with a non-integer number like 3.2 that we will get an error, but what if we include a negative number? If you run fact(-5) you will see ??????.    StackOverflowError:    Stacktrace:  [1] fact(n::Int64) (repeats 2 times)  @ Main ~\/code\/sci-comp-book\/julia-output\/adv-functions.ipynb:1    This occurs because when a negative number is put into the fact function that since is not 0, it computes n*fact(n-1) which will evaluate fact again at a more negative number. Subsequent calls to fact with more negative numbers would never end except that recursive functions are evaluated on what is called the stack and there is a maximum number of items that can be put on the stack and thus this error occurs. We can alert the user to an invalid argument with the following:   function fact(n::Integer) n>=0 || throw(ArgumentError(\"The argument must be a nonnegative integer.\")) n==0 ? 1 : n*fact(n-1) end   The first line of this evaluates n >= 0 . If that is false, the statement after the || is evaluated and an error is thrown. Alternatively, if you enter a positive number for n , then the first line n>=0 evaluates as true and then shortcircuits, which means as soon as the first part of the compound or statement hits true, it stops evaluating.  Using this newer version of fact , if we call fact(-5) , we get    ArgumentError: The argument must be a nonnegative integer.    which is a more helpful error.  In , the findAllFactors function doesn't make any sense if the number is less than 1. Add a line to the function that throws an appropriate error.    Optional arguments  Let's return to Newton's method, which we wrote for this section, we will consider the code from , not that from , which introduces the Root struct. We will comment on this later this chapter. before as   using ForwardDiff function newton(f::Function, x0::Number) local x1 = x0 local dx = f(x1)\/ForwardDiff.derivative(f, x1) local steps = 0 while abs(dx) > 1e-6 && steps < 10 x1 -= dx dx = f(x1)\/ForwardDiff.derivative(f, x1) steps += 1 end x1 end   Notice that we hard-coded the stopping criteria and the max number of steps. This is not good practice and will use a default value as an optional argument .  Let's define the tolerance ( tol ) and the maximum number of steps ( max_steps ) in the following way:   function newton(f::Function, x0::Number, tol = 1e-6, max_steps = 10) local x1 = x0 local dx = f(x1)\/ForwardDiff.derivative(f, x1) local steps = 0 while abs(dx) > tol && steps < max_steps x1 -= dx dx = f(x1)\/ForwardDiff.derivative(f, x1) steps += 1 end x1 end   You may notice that we didn't give the new arguments types. This wasn't an error, but julia will interpret the type from the default value. In this case, tol will be a Float64 and max_steps will be an Int64 .  Note that when entering this, it says there are 3 methods with the name newton . This is because julia will build three different function signatures. One with 2 arguments (and both tol and max_steps use the default values), one with 3 arguments (and max_steps using it's default value) and one with all 4 arguments. Also remember that 1e-6 means , which is the default tolerance.  This seems more robust in that we can now call Newton's method with different values of tolerance and steps. So:    newton(x -> x^2-5,2)    returns 2.236067977915804 . But if we use a lower tolerance:    newton(x -> x^2-5,2,1e-3)    returns 2.236111111111111 , which is slightly different than before. Probably the number of steps of Newton was a bit different.  If we want to change the number of steps, however, we need to include the tolerance as well like:    newton(x -> x^2-5,2,1e-6,5)    which results in 2.236111111111111 . We will see later an alternative way to handle these parameters, called keyword parameters which requires names of parameters, not the order, which is helpful as the number of arguments\/parameters for a function gets large.  This is quite an improvement, however, the arguments tol and max_steps optional parameters should both be positive, so we will add checks on these as   function newton(f::Function, x0::Number,tol=1e-6,max_steps=10) tol > 0 || throw(ArgumentError(\"The parameter tol must be positive\")) max_steps > 0 || throw(ArgumentError(\"The parameter max_steps must be positive\")) local dx = f(x0)\/ForwardDiff.derivative(f,x0) local steps = 0 while abs(dx) > tol && steps < max_steps x0 -= dx dx = f(x0)\/ForwardDiff.derivative(f,x0) steps += 1 end x0 end   and including negative numbers for either of these two now throws an error.   Complete the following:   Recall that a root of is the square root of 10. Use the function above to find with a tolerance of .   Find the absolute and relative error. Use sqrt(10) as the actual value and the result from the newton function as the Hint: recall this from .   Put in arguments for the tolerance and maximum number of steps that will throw an error. Check that this actually occurs.     Handling Special Cases  As we saw in ,    f(x)=x^2+1  root=newton(f,2)    returns 2.4008803928468465 , but if we evaluate the function at the root, with f(root) the result is 6.764226660756428 , which is definitely not 0 (or very close), so this doesn't appear to be a root. Recall this occurred because the function doesn't have a root. If we temporarily print out the values of x1 within the loop, we'll see that the x values bounce all around and then just stops. In the Newton method, add the line @show x1 just after the line with the while statement. Rerun the function then and try root=newton(f,2) again. It's not clear, but what happens here is that the max number of steps is reached, but you are not alerted.  So to make this more clear, before the last line of the function, let's include    steps < max_steps || throw(ErrorException(\"The maximum number of steps: $max_steps was reached without convergence\"))    and then rerunning newton(x -> x^2+1,2) gives the error The maximum number of steps: 10 was reached without convergence which explains to the user that a root was not reached.  You, the astute reader, probably noticed that we had an alternative way to handle this case in , in which we created a struct called Root to handle all of the information from Newton's method. Either using the Root structure of the method of throwing an exception like above is fine as you may need to know how you will use this code.    Keyword Arguments   Although optional arguments are quite helpful, there are two situations that they can be annoying.     If you want to change one optional argument without the others, we may not be able to. In the Newton's method example, if we want to change max_steps , which is the 4th argument without changing the 3rd argument, we can't just put in the value of max_step .    For more complex functions, there may be a lot of possible parameters, most of which could be optional. The order of the arguments are important, and if you mix them up, you may either get an error or get unexpected results.     Using keyword arguments can solving both of these problems and We can rewrite newton's method as   function newton(f::Function, x0::Number; tol=1e-6, max_steps=10) tol > 0 || throw(ArgumentError(\"The parameter tol much be positive\")) max_steps > 0 || throw(ArgumentError(\"The parameter max_steps much be positive\")) local x1 = x0 local xstep = f(x0)\/ForwardDiff.derivative(f,x0) local steps = 0 while abs(xstep)>tol && steps<max_steps x0 = x0 - xstep xstep = f(x0)\/ForwardDiff.derivative(f,x0) steps += 1 end local error = \"The maximum number of steps: $max_steps was reached without convergence\" steps < max_steps || throw(ErrorException(error)) x0 end   and it is important to note that there is a semicolon separating the arguments from the keyword arguments.  Now we can use this more easily. The function call    newton(x -> x^2-2,1,tol=1e-3)    results in 1.4142156862745099 and if we only want to change the number of max_steps is    newton(x -> x^2-2,100,max_steps=20)    results in 1.41421356237384 .    Keyword Arguments for complex functions  The main place that we have used keywords in this text is in the Plots package. All of the ways to adjust a plot is with keywords. There are perhaps about 100 keyword arguments to adjust for a plot and since each one of them has a default value, you only need to enter the ones that you want to change.  This was just a quick introduction to this and for further information, look at the julia documentation on keyword arguments .   In , we'll see the trapezoid rule , which is used for numerical integration or area under a curve. The technique subdivides the interval into equal pieces and approximates the area under the curve with the area of a trapezoid. In julia this is   function trapRule(f::Function,a::Number,b::Number) local h = (b-a)\/10 0.5*h*sum(map(f,a:h:b-h)+map(f,a+h:h:b)) end   where . We can estimate the area under the curve on the interval by entering    trapRule(x -> x^3,0,4)    and the result is 64.64000000000001 .   Change the arguments a and b to be optional arguments with the default values of 0 and 1 respectively.   Rewrite the code above to make a keyword argument of the number of subdivisions (10) and set the initial value to 10.   Check that the argument a is less than b and that n is greater than 1.   Find a better estimate for the area under on using 100 and 1000 subdivisions.      Parametric Methods  Let's look at writing a function that finds the maximum of some number of real values. There is a built-in function for this, but going through this will illustrate a point.  If we want to find the maximum of two reals, then    findMax(x::Real,y::Real) = x > y ? x : y    and if we want any number of reals then as we saw in , we can use variable arguments (varargs) like:   function findMax(nums::Real...) local max = -Inf for num in nums if num > max max = num end end max end   Another findMax function that would be helpful is in an array of Real s (mainly because we will need to do something different for Complex arrays). This will look a lot like the one above:   function findMax(arr::Vector{Real}) local max = -Inf for num in arr if num > max max = num end end max end   Testing it with the array x=collect(1:10) using findMax(x) we get the error:    MethodError: no method matching findMax(::Vector{Int64})  The function `findMax` exists, but no method is defined for this combination of argument types.    and this is because even though x is of type Vector{Int64} that doesn't fit the signature Vector{Real} .  One way to get around this is to write a function for each number type we may want to find the max of ( Int128 , Int64 , ..., BigInt , Float64 , Float32 , Float16 ) and all of the flavors of Rational but if you notice every function will be nearly identical and this would be painful and a lot of code copying. Also, this is a nightmare for maintenance, in that if there was a bug in one it would need to be tracked down in each one.  Instead, we will use something in julia called a parametric function which allows us to write a single function that works on a set of different types. To do this with the findMax function, we will write:   function findMax(arr::Vector{T}) where T <: Real local max = -Inf for num in arr if num > max max = num end end max end   and the expression where T <: Real is used as any type T that is a subset of the Real numbers (including integers, floats and rational) and then findMax(x) returns 10 . Also if we have   findMax(collect(1.0:10.0))   returns 10.0 and   findMax(collect(big(1):big(10)))   returns 10 (as a BigInt ).   Create a findProduct method that is parametric. The template (signature) for this function should be    function findProduct(arr::Vector{T}) where T <: Real   end    by using a for loop. Start with the line:    local sum = one(T)    which creates the sum variable as the number 1 with type T , so depending on the data type the array is, it will have the appropriate product data type.  Try the function with each of the following    arr1=collect(1:10)     arr2=collect(big(1):big(10))     arr3=collect(3.0:4.0:56.0)     arr4=collect(1:1\/\/3:7\/\/3)      Function Arguments  As described in the Julia documentation on functions , arguments follow what is called \"pass-by-sharing\", which means that values are not copied when they are passed to functions. Instead, the argument is a local variable that is passed the value when the function is called. Consider    function g(x::Number)  2*x  end    and if we make a function call like g(4) , then within the function x is a variable that is given the value 4 . We can update the variable. For example.    function g(x::Number)  x *= 2  x += 7  x  end    where recall that the *= and += updates the value on the left. When called as    x=4  g(4)    it returns 15 and the value of x remains as 4 . This is because the x within the function is now a local function that starts with the value 4.  You may recall some functions seem to update the value of its arguments. For example,    A = [4,5,2,3,1]  sort!(A)  A    returns the sorted array [1,2,3,4,5] . So how does this work, you may ask? Let's write our own function that may do this.    function change3!(A::Vector{T}) where T <: Number  A[3] *= 2  end    which takes a vector of numbers and double the 3rd element of the vector. We used the convention in julia that if the arguments are changed we append a ! to the name. If we enter    A = [1,2,3,4]  change3!(A)    which returns 6 (recall that since the last line of the function is the double of the 3rd element, we get 6). And if we type A to view it again, we get the vector [1,2,6,4] indicating that indeed the vector A has been updated.  The reason that A is updated with this function whereas the x above is not is the way that array variables differ from scalar variables (like numbers and strings). The assignment A=[1,2,3,4] , means that A is a reference to the array instead of the array itself. This is similar to other languages, although some (like C and C++) use the term pointer instead. Thus, when you call change3!(A) the variable A within the function takes on the reference to the original function. Thus, when values are updated within the function, then the array is actually updated. When x is updated in the function above, one can think that this is a copy of the passed in value, which doesn't leave the function.   "
},
{
  "id": "ch-adv-functions-3-12",
  "level": "2",
  "url": "ch-adv-functions.html#ch-adv-functions-3-12",
  "type": "Check Your Understanding",
  "number": "20.1",
  "title": "",
  "body": "In , the findAllFactors function doesn't make any sense if the number is less than 1. Add a line to the function that throws an appropriate error. "
},
{
  "id": "ch-adv-functions-4-20",
  "level": "2",
  "url": "ch-adv-functions.html#ch-adv-functions-4-20",
  "type": "Check Your Understanding",
  "number": "20.2",
  "title": "",
  "body": " Complete the following:   Recall that a root of is the square root of 10. Use the function above to find with a tolerance of .   Find the absolute and relative error. Use sqrt(10) as the actual value and the result from the newton function as the Hint: recall this from .   Put in arguments for the tolerance and maximum number of steps that will throw an error. Check that this actually occurs.  "
},
{
  "id": "ch-adv-functions-6-3-4",
  "level": "2",
  "url": "ch-adv-functions.html#ch-adv-functions-6-3-4",
  "type": "Check Your Understanding",
  "number": "20.3",
  "title": "",
  "body": " In , we'll see the trapezoid rule , which is used for numerical integration or area under a curve. The technique subdivides the interval into equal pieces and approximates the area under the curve with the area of a trapezoid. In julia this is   function trapRule(f::Function,a::Number,b::Number) local h = (b-a)\/10 0.5*h*sum(map(f,a:h:b-h)+map(f,a+h:h:b)) end   where . We can estimate the area under the curve on the interval by entering    trapRule(x -> x^3,0,4)    and the result is 64.64000000000001 .   Change the arguments a and b to be optional arguments with the default values of 0 and 1 respectively.   Rewrite the code above to make a keyword argument of the number of subdivisions (10) and set the initial value to 10.   Check that the argument a is less than b and that n is greater than 1.   Find a better estimate for the area under on using 100 and 1000 subdivisions.  "
},
{
  "id": "sect-parametric-methods-20",
  "level": "2",
  "url": "ch-adv-functions.html#sect-parametric-methods-20",
  "type": "Check Your Understanding",
  "number": "20.4",
  "title": "",
  "body": " Create a findProduct method that is parametric. The template (signature) for this function should be    function findProduct(arr::Vector{T}) where T <: Real   end    by using a for loop. Start with the line:    local sum = one(T)    which creates the sum variable as the number 1 with type T , so depending on the data type the array is, it will have the appropriate product data type.  Try the function with each of the following    arr1=collect(1:10)     arr2=collect(big(1):big(10))     arr3=collect(3.0:4.0:56.0)     arr4=collect(1:1\/\/3:7\/\/3)   "
},
{
  "id": "ch-adv-functions-8-16",
  "level": "2",
  "url": "ch-adv-functions.html#ch-adv-functions-8-16",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "pointer "
},
{
  "id": "ch-collections",
  "level": "1",
  "url": "ch-collections.html",
  "type": "Chapter",
  "number": "21",
  "title": "Collections, Sets and Dictionaries",
  "body": " Collections, Sets and Dictionaries     Learn that many previously-learned data structures like arrays, can be thought of more abstractly.    Create a Set, a Julia type that is similar to a mathematical set, which is a collection of things without an order to them.    Create a Dictionary, which is a collection of key\/value pairs and tasks to perform on them.    Create a user-defined collection by specifying an iterator, which explains how to construct the collection.      In , we introduced an array, which is a set of things (integers, floats, string or other) with an order to it. Julia has the notion of a collection, which is an abstract notion of a collection. In this chapter, we will examine the abstract collection as well as discuss concrete versions, some of which we have seen previously and introduce Sets and Dictionaries an important collection types.    Abstract Collection and Iteration  A collection is an ordered set of things. The concrete objects we have seen so far in this text include arrays, tuples and ranges. Any collection has the following functions applied to it     isempty  A boolean function that determines if a collection is empty. isempty([1,2,3]) returns false and isempty(3:2) returns true because 3:2 is a range and since the second number is smaller than the first, there are no elements in it.    empty!  This function takes a collection and removes all elements of the collection. If A=[1,2,3,4] then applying empty!(A) results in A being the empty array [] .    length  A function that returns the number of elements in the collection. As we've seen before length([1,2,3]) returns 3, but note also (1,2,3,4) returns 4 . length(1:2:11) returns 6.  Note that a 2D array (Matrix) is also a collection and if C=[1,2; 3, 4; 5, 6] is the 3 by 2 matrix, then length(C) returns 6 , the total number of elements in the Matrix. This applies also to higher dimensional arrays.     One can access all of the elements of a collection by iterating over the elements. One simple way of doing this is with a for loop and we have seen this in . For example    for i=1:4  @show i  end    will print out (show) all of the elements in the range 1:4 . Recall also, we can use a for loop over an array like    for i in [5, 9, 10, 2]  @show i  end    will show each of the elements in the array.    Sets  A mathematical set is a collect of things without an order. For example, mathematically, a set is generally written as and there are important functions like union and intersection that is used. If and , then and . Also the sets and are the same in that order of the elements is not important.  Julia has a Set is a collection that behaves the same way. If    A=Set([1,2,3])  B=Set([3,2,1])    then first notice that the order of the element may be switched around on output, but if we check for equality with A==B , then the result is true If we did [1,2,3]==[3,2,1] on arrays, the result is false   Julia also has the functions union and intersection that work on Sets , but also any iterators. union(Set([1,2,3]),Set([3,4,5])) returns Set([1,2,3,4,5]) , but union([3,4,8],3:7) returns [3,4,8,5,6,7] and notice that in this case the order is kept.   Sets don't need to be sets of integers. A set of a string produces the characters. For example, Set(\"hello\") returns    Set{Char} with 4 elements:  'h'  'l'  'e'  'o'    and notice that is it the set of characters in the work \"hello\" and \"l\" is not repeated.  Another function is the boolean version of in or ϵ that will return true if a element is in the set, false otherwise. For example if A=Set([1,3,5,7,9]) , then 7 ϵ A returns true . There is also a not-in operator, ∉ which can be enters as \\notin TAB and if we do 4 ∉ A , the result is true .  There are other functions that can be used with sets include set difference and testing for subsets. See the Julia documentation on sets for more information.    Dictionaries  In Julia, a Dictionary is more general version of a named tuple and are sets of key\/value pairs. The main difference is that a Dict is mutable and there are many methods that update a Dict . To create a Dict , pass key\/value pairs using \"fat arrow\" notation like:    d = Dict(\"a\"=>1, \"b\"=>2, \"c\" => 3)    or alternatively, an array of tuples as key\/value pairs:    s = Dict([(\"bart\", 10), (\"lisa\", 8), (\"maggie\", 1)])    An getter\/accessor is similar to that of an array. d[\"a\"] will return 1 , the value of the key correpsonding to \"a\" . And one can set a value in the same way. d[\"a\"] = 10 will update the value associated with the key \"a\" to be 10.   push! and pop! work with Dict s in a similar manner to those as arrays. For example,    push!(s, \"homer\" => 45)    now returns the Dictionary with this entry added. Unlike an array, pop! requires both the Dict and a key which will be returns and removed.    pop!(s, \"maggie\")    returns 1 the value that corresponds to the \"maggie\" entry and if s is entered, then it no longer contains this entry.  The method keys returns an array of the keys in the Dictionary. Since \"maggie\" is no longer there keys(s) returns [\"lisa\", \"homer\", \"bart\"] . The order of the keys may differ from what you see here. It returns an iterator, but probably better thought of as a set.  The method values returns an array of the values in the Dictionary in the same order as that of the keys. When running values(s) , we get [8,45,10] .  As mentioned above, a dictionary is a more flexible version of a named tuple. Another example is that Dictionaries can be nested. Consider creating a dictionary which stores contact information for a person.   homer = Dict( \"first_name\" => \"Homer\", \"last_name\" => \"Simpson\", \"phones\" => [ \"home\" => \"987-555-1234\", \"cell\" => \"987-555-1212\" ], \"home_address\" => Dict( \"street\" => \"742 Evergreen Terrace\", \"city\" => \"Springfield\" ), \"work_address\" => Dict( \"street\" => \"10 Power Plant Lane\", \"city\" => \"Springfield\" ) )   and as you can see, the keys are all strings, but the corresponding values differ. There are two strings, an array (of strings) and two Dict s. Although this is more complex, we can still access things in a similar way. For example homer[\"work_address\"][\"street\"] will return \"10 Power Plant Lane\" .  There are other methods that we can use with Dictionaries and the Julia documentation on dictionaries is a good source. Additionally in , we will examine how to interact with a webserver that returns JSON strings which are parsed as dictionaries. This is a common format on the internet and we will see how to handle such things in Julia.    User-created collections  Although we have seen many built-in collections and there are plenty of other examples in Julia packages, it should be no surprise to note that we can create a collection. Mainly, there are some key functions that need to be implemented on the collection. Let's just show this with an example.  In , we looked at Fibonacci numbers as examples of recursive functions and how to implement them efficiently. We will create a type Fibonacci using a struct like in in the following manner:   struct Fibonnacci n::Integer function Fibonnacci(n) n >= 0 || throw(ArgumentError(\"This must be called with a positive integer\")) new(n) end end   where a constructor has been used to check that only positive integers are used. As is, this is just a struct with a single field called n . To make this an interator we need to implement some of the functions associated with an iterator. We will first implement the functions isempty and length and define them as    Base.isempty(f::Fibonnacci) = f.n == 0  Base.length(f::Fibonnacci) = f.n    and as can be seen that if we create a Fibonacci with 0 elements that it is empty and has length 0. It can be tested with isempty(Fibonacci(0)) which returns true and length(Fibonacci(10)) returns 10.  This doesn't see to do anything related to the fibonacci numbers, but by defining the iterator function we can get the functionality that we desire. If   function Base.iterate(f::Fibonnacci, state = 1) if state > f.n return nothing end local (x,y) = (1,1) for i = 1:state-1 x,y = (y, x+y) end (x, state + 1) end   where the arguments of the iterate function is a object of the type in question and a variable state which acts like an index. The function should return nothing if the iteration is done and otherwise, return a tuple with the next value and increment the index\/state. Note in our case above, we have used the faster (non recurvise) version of fibonacci in .  There are many ways that iterate can be used. For example in a for loop like    for i in Fibonnacci(10)  @show i  end    will produce the first 10 fibonacci numbers. Also, collect(Fibonacci(10)) will create an array of length 10 with the Fibonacci numbers.   "
},
{
  "id": "ch-collections-2",
  "level": "2",
  "url": "ch-collections.html#ch-collections-2",
  "type": "Objectives",
  "number": "21",
  "title": "",
  "body": "   Learn that many previously-learned data structures like arrays, can be thought of more abstractly.    Create a Set, a Julia type that is similar to a mathematical set, which is a collection of things without an order to them.    Create a Dictionary, which is a collection of key\/value pairs and tasks to perform on them.    Create a user-defined collection by specifying an iterator, which explains how to construct the collection.    "
},
{
  "id": "ch-modules",
  "level": "1",
  "url": "ch-modules.html",
  "type": "Chapter",
  "number": "22",
  "title": "Creating Modules and using Unit Tests",
  "body": " Creating Modules and using Unit Tests   Throughout this text, we have added and loaded packages or modules. These were generally official ones. In this section, we will now learn how to write our own module. We will learn how to do this by creating a PlayingCards module with all of the types and functions associated with it from as well as the rootfinding functions and structs of . As needed, you should review the material in those chapters.    The Revise  Although this isn't necessary, the Revise package makes developing a module much easier. You should add and the load it with    using Revise    This will allow changes to a module updated automatically. You can use this with either the REPL or a Jupyter notebook.    Creating a Module  To begin with, let's look at a module template:    module PlayingCards  ## definitions of types and functions  end    As you can see above, a module has a name (in this case PlayingCards ) and ends with the keyword end . We will next put a number of types and functions inside the module, but in order for someone loading the module, you need to export anything to be used. We have used the naming convention of capital letters (often called Pascal case) for a Module name.  We will take all of the structs, constructors and functions associated with playing cards that we developed earlier and place them in the module.   module PlayingCards import Base.show export Card, Hand, isFullHouse ranks = ['A','2','3','4','5','6','7','8','9','T','J','Q','K'] suits = ['\\u2660','\\u2661','\\u2662','\\u2663'] struct Card rank::Int suit::Int # construct a card based on the rank and suit function Card(r::Int,s::Int) 1 <= r <=13 || throw(ArgumentError(\"The rank must be an integer between 1 and 13.\")) 1 <= s <= 4 || throw(ArgumentError(\"The suit must be an integer between 1 and 4.\")) new(r,s) end # construct a card based on the number in a deck function Card(i::Int) 1 <= i <= 52 || throw(ArgumentError(\"The argument must be an integer between 1 and 52\")) i%13==0 ? new(13,div(i,13)) : new(i%13,div(i,13)+1) end # construct a card based on a string representation of the card function Card(str::String) length(str)==2 || throw(ArgumentError(\"The string should only be 2 characters\")) local r = findfirst(a->a==str[1],ranks) r != nothing && 1 <= r <= 13 || throw(ArgumentError(string(\"The first character should be one of \",join(ranks,\",\")))) local s=findfirst(a->a==str[2],suits) s != nothing && 1<= s <= 4 || throw(ArgumentError(string(\"The second character should be one of \",join(suits,\",\")))) new(r,s) end end struct Hand cards::Array{Card,1} # constructors Hand(cards::Array{Card,1}) = new(cards) Hand(cards::Array{String,1}) = new(map(Card,cards)) Hand(s::String) = new(map(Card,map(String,split(s,',')))) end function Base.show(io::IO, c::Card) print(io,string(ranks[c.rank],suits[c.suit])) end function Base.show(io::IO, h::Hand) print(io,string(\"[\",join(map(c->string(ranks[c.rank],suits[c.suit]),h.cards),\",\")),\"]\") end function isFullHouse(h::Hand) local cranks=sort(map(c->c.rank,h.cards)) cranks[2]==cranks[1] && cranks[5]==cranks[4] && (cranks[3]==cranks[2] || cranks[4]==cranks[3]) && cranks[2] != cranks[4] end end #module PlayingCards   Open a new text file in jupyter and copy-paste the above module into the empty file. It will need to be called PlayingCards.jl and should be in the same directory as the file you're working on. Note: in Jupyter, it is important to have the .jl suffix on the filename so the coloring\/formatting is correct for the file.  To load this module, we will do:    includet(\"PlayingCards.jl\")  using .PlayingCards    where the includet function is in the Revise package. It includes the file and the t stands for tracking. What will happen if you update anything in the file and then make any call to those that are in the package, you will get the new revised code without restarting the kernel or reloading the package.  Here are some things to note about the module:   Line 3: import Base.show will import the show command from Base , and will be needed to develop good format for cards and hands.    Line 5: export Card, Hand, isFullHouse says what will be available if the module is loaded.    Staring on Line 10, the Card struct is defined as we saw in . We have added an additional constructor starting at line 28, that creates a card based on a string.    Staring on Line 39, the Hand struct is defined as we saw in . This one is a bit different in that chapter because we have added to additional constructors.    the functions Base.show functions for both Card and Hand are defined on lines 48 and 52. The command Base.show is automatically loaded, so these didn't need to be exported.    the isFullHouse functions is defined starting on line 56.     Once you have saved and successfully loaded the module, let's test it a bit. First let's build some of the hands that we did in :    fh1 = Hand([Card(4,1),Card(4,3),Card(4,4),Card(7,1),Card(7,2)])  fh2 = Hand([Card(4,1),Card(4,3),Card(7,4),Card(7,1),Card(7,2)])  fh3 = Hand([Card(2,1),Card(4,3),Card(4,4),Card(7,1),Card(7,2)])    and the last hand should look like [2♠,4♢,4♣,7♠,7♡] .   Add the isOneSuit , hasRun , royalFlush , isTwoPair and runTrials functions from to the module.   Add the royalFlush , isTwoPair and runTrials functions to be exported (top of the module).   Create a hand that is a Royal Flush poker hand and one that is not.   Create a hand that is a Two Pair poker hand and one that is not.   Test that the runTrials function is working by testing the functions.     Unit Tests  Writing a module is important, but making sure it does what it is supposed to is just as important. At first, when you start writing code, you typically make sure there are no bugs, but after time, code changes and you're not sure that the code still works. The notion of a unit test is a set of tests to determine if you get out from the code what you expect. This is a language-independent idea and should be created once you write any level of substantial code.  To run a test in Julia, first import the Test package:    using Test    To do a test, we'll use the @test macro and it's a good idea to check out the Julia documentation on Test . For this module, let's first test that the constructor is working using the isa function.    @test isa(Card(1,4),Card)    should return Test Passed . Recall also that we can pass in an integer between 1 and 52, so    @test isa(Card(24),Card)    should also return Test Passed . If we try to create a card that is not valid, then we won't get a Test Passed. For example:    @test isa(Card(78),Card)    will return Error During Test . A better way to test for this is using the @test_throws method to test if an error is thrown:    @test_throws ArgumentError Card(78)    returns Test Passed .  Here's another nice test that will check if the two different ways to create Cards are the same. For this we will need a way to test if two Cards are equal. Add the following to the Playing Cards module.   function isequal(x::Card,y::Card) x.rank==y.rank && x.suit==y.suit end   and test if two cards are the same with    @test isequal(Card(2,3),Card(28))    and this returns Test Passed .   Write a test that the isFullHouse method is working. To do this:   Create a hand that is a full house, called h1 . Run @test isFullHouse(h1) .   Create another hand called h2 that is a full house and test it.   Create a third hand called h3 that is not a full house and test it. To get the test to return passed, perform @test !isFullHouse(h3) .     Creating a test suite   Often in a set of tests, there are mulitple tests that go together. For example, if we just want to test that the construction of Cards are working, we can create a test set in the following:    @testset \"Legal Card Constructor\" begin  @test isa(Card(1,3),Card)  @test isa(Card(45),Card)  @test isa(Card(\"3\\u2660\"),Card)  end    where all three methods to construct a card are used and all should work. If you run this, you should get:    Test Summary: | Pass Total Time  Legal Card Constructor | 3 3 0.2s    which just shows that we passed all of the tests. If one of them doesn't pass, you will get information about the one that wasn't passed. Try changing one of the tests above to get an illegal card.    Putting all tests in a file  The Playing Card test file is a better way to run a set of tests. To use this, download the file, put it in the current directory of jupyter and then run it with:    include(\"test-playing-cards.jl\")    and you should see the following results:    Test Summary: | Pass Total Time  Legal Card Constructor | 4 4 0.0s  Test Summary: | Pass Total Time  Illegal Cards throws exceptions | 5 5 0.0s  Test Summary: | Pass Total Time  Legal Hand Constructor | 3 3 0.0s  Test Summary: | Pass Total Time  Illegal Hand throws exceptions | 5 5 0.0s  Test Summary: | Pass Total Time  Card Tests | 3 3 0.0s  Test Summary: | Pass Total Time  Full House | 2 2 0.0s    indicating that all tests passed.   Create a test set with at least 3 hands to test for Royal Flush.   Create a test set with at least 3 hands to test for Two Pair.   Add these test sets to the test-playing-cards.jl file.      Modules and Unit Tests  Once you have enough code to write a module, the first thing should be to start writing unit tests to make sure it is correct. In fact, good programming practice is to write the API (Application Programming Interface), which is just the function signatures with no function bodies, then the test cases before any working code is written.  In any case, once you have unit tests working, you should write and revise any code and after any changes are made, rerun any unit tests.    A Rootfinding Module   We now develop a rootfinding module based on what we've developed in , and . We will pull a few of the structs and functions in as:   module Rootfinding using ForwardDiff import Base.show export Root, newton struct Root root::Float64 # approximate value of the root x_eps::Float64 # estimate of the error in the x variable f_eps::Float64 # function value at the root f(root) num_steps::Int # number of steps the method used converged::Bool # whether or not the stopping criterion was reached max_steps::Int # the maximum number of steps allowed end function Base.show(io::IO,r::Root) str = r.converged ? \"\"\"The root is approximately x̂ = $(r.root) An estimate for the error is $(r.x_eps) with f(x̂) = $(r.f_eps) which took $(r.num_steps) steps\"\"\" : \"\"\"The root was not found within $(r.max_steps) steps. Currently, the root is approximately x̂ = $(r.root). An estimate for the error is $(r.x_eps) with f(x̂) = $(r.f_eps).\"\"\" print(io,str) end function newton(f::Function, x0::Number; tol=1e-6, max_steps=10) tol > 0 || throw(ArgumentError(\"The parameter tol much be positive\")) max_steps > 0 || throw(ArgumentError(\"The parameter max_steps much be positive\")) local x1 = x0 local dx = f(x1)\/ForwardDiff.derivative(f,x1) local steps = 0 while abs(dx)>tol && steps<max_steps x1 -= dx dx = f(x1)\/ForwardDiff.derivative(f,x1) steps += 1 end Root(x1,dx,f(x1),steps,steps<max_steps,max_steps) end end # module Rootfinding   Recall that once this is saved then enter:    include(\"Rootfinding.jl\")  using .Rootfinding    and now we can use these functions:    root = newton(x -> x^2-5,1)    returns    The root is approximately x̂ = 2.2360688956433634  An estimate for the error is 9.18143385206549e-7  with f(x̂) = 4.106063730802134e-6  which took 4 steps      A Test Suite for Rootfinding  One of the themes of the text is knowing when computational algorithms succeed and fail. We have seen throughout a few chapters now that Newton's method fails for functions without roots. It is important to check how well it is working.  In an exercise in , you were asked to try to find . We will do this formally now with a test. Recall, if you haven't yet, enter using Test .  If we want to test Newton's method, we need to choose a function that has a root that we know. You may think that since has a root at , we can test that. Let's try.  A simple test may be    val = newton(x -> x^2-2,1)  @test val.root == sqrt(2)    which results in Test Failed .  The problem occurs when checking equality between two floating-point numbers. You can see in the error the two values and although they are identical for about 10 digits, they are not exactly the same. In order for any pairs of numbers to be equal, all bits must be the same and that is hard to achieve with floating points.  Instead, we will test for approximate equality.    val = newton(x -> x^2-2,1)  @test abs(val.root-sqrt(2)) < 1e-6    which returns Test Passed   Alternatively, we can use the nice approximate test of  @test val.root≈sqrt(2)    where the ≈ symbol can be entered with typing \\approx then hitting TAB.  We also want to make sure that it returns appropriately when there is no root. We'll return to the function and look for a root. We will build up a test set to test a number of things:    @testset \"function with no root\" begin  val = newton(x -> x^2+1,2)  @test !val.converged  @test val.num_steps == val.max_steps  end    returns    Test Summary: | Pass Total Time  function with no root | 2 2 0.0s      "
},
{
  "id": "ch-modules-4-15",
  "level": "2",
  "url": "ch-modules.html#ch-modules-4-15",
  "type": "Check Your Understanding",
  "number": "22.1",
  "title": "",
  "body": " Add the isOneSuit , hasRun , royalFlush , isTwoPair and runTrials functions from to the module.   Add the royalFlush , isTwoPair and runTrials functions to be exported (top of the module).   Create a hand that is a Royal Flush poker hand and one that is not.   Create a hand that is a Two Pair poker hand and one that is not.   Test that the runTrials function is working by testing the functions.  "
},
{
  "id": "sect-unit-tests-19",
  "level": "2",
  "url": "ch-modules.html#sect-unit-tests-19",
  "type": "Check Your Understanding",
  "number": "22.2",
  "title": "",
  "body": " Write a test that the isFullHouse method is working. To do this:   Create a hand that is a full house, called h1 . Run @test isFullHouse(h1) .   Create another hand called h2 that is a full house and test it.   Create a third hand called h3 that is not a full house and test it. To get the test to return passed, perform @test !isFullHouse(h3) .  "
},
{
  "id": "ch-modules-6-3-7",
  "level": "2",
  "url": "ch-modules.html#ch-modules-6-3-7",
  "type": "Check Your Understanding",
  "number": "22.3",
  "title": "",
  "body": " Create a test set with at least 3 hands to test for Royal Flush.   Create a test set with at least 3 hands to test for Two Pair.   Add these test sets to the test-playing-cards.jl file.  "
},
{
  "id": "ch-parallel",
  "level": "1",
  "url": "ch-parallel.html",
  "type": "Chapter",
  "number": "23",
  "title": "Parallel Computing",
  "body": " Parallel Computing   Briefly, parallel computing is a method of running code on multiple processors (or multiple cores of the same processor) at the same time. In general, this is a difficult task depending on where data is stored and retrieved. The Julia Documentation on parallel computing is a good place to start.  Let's start with something relatively simple. Consider the following code:   function countHeads(n::Int) c::Int = 0 for i=1:n c += rand(Bool) end c end   which mimics flipping a coin n times. We can simulate flipping 2 billion coins and finding the fraction that is heads by the following:    @time countHeads(2*10^9)\/(2*10^9)    which returns 0.5000087195 in 2.548122 seconds . And remember that since we are using random numbers that if you run this code you will get different results, but the number should be close to the expected value of 0.5.     Running parallel code   We now wish to take advantage of the fact that today's processors often have multiple cores and multiple threading. There are some helpful things in the Distributed package:    using Distributed    Unless you specify otherwise, Julia will startup only using 1 core. You can see this with nprocs() , which will return 1 as the number of cores used. Let's say that we wish to run it simultaneously on 2 cores (even if we know we have more) If we type    addproc(1)    this would then allow julia up to 2 ``processors''. There are a couple of ways to now run code. The first gives us more control, while the second allows for some easy code writing. Checking with nprocs() now shows that there are 2 cores available.    Assigning code to workers  First, we need to make sure that the function countHeads is available to each core of the machine. To do this, we will start the function with the @everywhere macro:   @everywhere function countHeads(n::Int) c::Int = 0 for i=1:n c += rand(Bool) end c end   Any function that you will need on multiple cores will need to be prefaced with the macro @everywhere . After this, we can now send code to different cores. Type:    a= @spawn countHeads(10^9)  b= @spawn countHeads(10^9)    and you should notice that it doesn't return the number of heads as expected and it goes almost instanteously. Don't worry right now about the type of object that is returned.  Even though it returns quickly, code is already running and you can see this with your machine's process manager (Activity Monitor on MacOS). To get the results, we type    fetch(a)+fetch(b)    and it will return the number of heads flipped. To test the timing, put all three of these in a block:    a= @spawn countHeads(10^9)  b= @spawn countHeads(10^9)  @time fetch(a)+fetch(b)    and the results show that it took 2.469003 seconds .  This is perhaps a bit disappointing in that if we use two cores, then might expect half of the time. It's not quite that simple in that there is some overhead for using multiple cores. However, if you use more cores like the exercise below, you'll probably get better results and for longer processes, it will pay off.  Perform the following tasks:    Add two more cores to julia with the addprocs command.    Rerun the block of code @everywhere function countHeads code above.    Create 4 spawning lines. Call them a, b, c and d and use 5*10^8 for each.    Time the sum of the four.    Note: if you truly have 4 cores, then you will see a further halving of the time. If not, you will probably only see the same results.        Managing Processes   Julia has a few commands that allow us to manage how many processes are used. These include addprocs seen above, but also procs and rmprocs . We will see these in action in this section.    The procs command  Entering procs() shows all of the current processes running in the kernel. If you did the exercise above, you should see 4 and may look like:    4-element Vector{Int64}:  1  2  3  4    which shows that there are 4 cores available and the have the numbers 1 through 4.    Adding all of the cores  Since most computers have multiple cores, this is helpful, but what about adding all of the cores? If we just call    addprocs()    then it adds everything available. You will get an array of the workers.    Removing cores  Although if you are trying to run code as quickly as possible you probably want as many cores as possible, you may need to reduce the number of cores used. We can do this with the rmprocs command. Pass in the number of the process that you want to remove.  If you have 4 processes numbered 1 through 4 currently, and want to return to just 1 process, then rmprocs(2,3,4) will return to the single core.     Parallel for loops  First, use the rmprocs command as shown above to return to a single core.  One issue with what we did above is that we have to think about spawning to individual processors or cores. That is fairly annoying. Fortunately, another helpful feature of julia is that of a parallel for loop. Try the following code:   @time let nheads = @distributed (+) for i = 1:2*10^10 Int(rand(Bool)) end end   and the results took 24.830175 seconds . Note that we are doing 10 times as many coin flips as the beginning of the chapter, so you should see this taking about 10 times longer.  Add 3 cores with addprocs(3) and rerun the code above. When running, I got the results in 9.434582 seconds . This is about twice as fast. If you were expecting (or hoping) for 4 times as fast, recall that there is overhead for handling parallel code. This machine has 8 core, so doing addprocs() added another 4 cores and rerunning, I got the results in 5.423481 seconds which is about 5 times faster than running without parallel code.  So what is going on with this? The @distributed macro runs a for loop on all available cores, splitting the range across the cores. The (+) says to add the results. Any reducer function (see for general reduce function) can be used.    Writing a parallel card simulator   For this, we need to reload the PlayingCard module:    include(\"PlayingCards.jl\")  using .PlayingCards, Random    (or you may need to put in a different path to your module)  If we have the following code to simulate a large number of hands:   function countHands(trials::Int,f::Function) local deck=map(Card,1:52) local num_hands=0 for i=1:trials shuffle!(deck) h = Hand(deck[1:5]) if(f(h)) num_hands+=1 end end num_hands end   And let's just check to make sure it works:    @time countHands(10_000_000,isFullHouse)    which returns the result in 4.305718 seconds .  We now wish to write a distributed version of this in which we will replace the for loop with a distributed for loop. First, the module needs to be loaded for all cores by the core below, but first restart the kernel to avoid errors that occur when rerunning the same code.    using Distributed  @everywhere include(\"PlayingCards.jl\")  @everywhere using .PlayingCards, Random    and then the following will be the parallel version of the hand count function:   @everywhere function paraCountHands(trials::Integer,f::Function) local deck=map(Card,1:52) function checkHand(f::Function) ## shuffle the deck then check the hand. shuffle!(deck) f(Hand(deck[1:5])) end @distributed (+) for i = 1:trials Int(checkHand(f)) end end   Add 3 cores with the command addprocs(3) and then rerun the code above with   @time fh = paraCountHands(10_000_000,isFullHouse)   returns \\printpythontex[verbatim] which cuts the time by about quarter.    parallelizing the ....  What goes here?     A Parallel Map Function    @everywhere function countHeads(n::Int) c::Int = 0 for i=1:n c += rand(Bool) end c end   In , we saw the map function, which is the standard way if you have an array and need to do the same thing to each element of the array, returning the result. If the function that is applied to each element of the array is costly and you have multiple processors\/cores to work with, doing this in parallel can be helpful.  We demonstrate how to do this with just the coin flip right now using the pmap function. We first make an array of length 12 (although this isn't an important number):   num_coins = 1_000_000_000*ones(Int64,12)   so each element is 1 billion. We wish to run the coin flipper on each element of the array. Don't forget that the countHeads function must be declared everywhere. The following runs the function:   @time pmap(countHeads,num_coins)   and the resulting time is: \\printpythontex[verbatim]  In comparison, if we run the regular map function:   @time map(countHeads,num_coins)   the result is \\printpythontex[verb]. Again, this is about 4 times slower.    When to use pmap  It seems like the pmap function should always be used if it speeds up calculations. However, note that in this example, the size of the array was small but the function on each element took a relatively long time. If we have an array with millions of elements, though, the pmap function may actually be slower.     Shared arrays  The last example shows that we may have to do something on an array. For simplicity, let's say we have a fairly large array:   arr = rand(1:100,100_000_000);   A common thing to do is to smooth an array (and is often done to images) by a windowed mean, which means that every element is replaced by a mean of the points around it in some window. We first define a windowed mean by the following function:   function windowMean(arr::Vector{T},i::Integer,width::Integer) where T <: Real window = max(1,i-width):min(i+width,length(arr)) sum(arr[window])\/(last(window)-first(window)+1) end   which first determine a window (being careful with the first and end of the array) and then just calculating the mean.  Then if we have a new array of zeros:   smoothed_array = zeros(Float64,length(arr))   we fill the new array with the windowed mean:   @time let for i=1:length(arr) smoothed_array[i]=windowMean(arr,i,100) end end   will fill the array with the smoothed version in about 43 seconds.  Note: the astute reader is probably thinking that using map to do this is the right way to go, however, we can't use map in this instance because the window\\_mean function doesn't just use a single number (from an array), it uses the entire array.  A natural way to speed this is is to send this to individual processor\/cores and work on this in pieces. One problem with this is that we would have to send the entire array to each worker and that is expensive. Since a 64-bit integer is 8 bytes, the array of 100 million is about 800 Mb of memory and that is reasonable expensive to pass around. Instead, we are going to use a shared array in the package SharedArrays and you will need to add this.   using SharedArrays    "
},
{
  "id": "ch-parallel-3-3-13",
  "level": "2",
  "url": "ch-parallel.html#ch-parallel-3-3-13",
  "type": "Check Your Understanding",
  "number": "23.1",
  "title": "",
  "body": "Perform the following tasks:    Add two more cores to julia with the addprocs command.    Rerun the block of code @everywhere function countHeads code above.    Create 4 spawning lines. Call them a, b, c and d and use 5*10^8 for each.    Time the sum of the four.    Note: if you truly have 4 cores, then you will see a further halving of the time. If not, you will probably only see the same results.    "
},
{
  "id": "ch-regexp",
  "level": "1",
  "url": "ch-regexp.html",
  "type": "Chapter",
  "number": "24",
  "title": "Regular Expressions",
  "body": " Regular Expressions   Regular Expressions are useful for parsing strings. From a scientific computing standpoint, we will use them to take a string and typically pull out numbers and other syntax. There will be two places that we will use regular expression. 1) to determine if a string matches some pattern and 2) extract information out of a string. Often the first step will need to be done for the latter step.  As with much of this text, although the examples here will be done using Julia, regular expressions are ubiquitous and every language has support for them. In general they all use the same syntax for the regular expressions.    Simple Pattern Matching   Let's start with some examples of pattern matching. If we want to determine if a string matches a pattern, we can use the exact string. For example, let's see if a string matches \"cat\" . We can do this with the occursin function like:    occursin(\"cat\",\"cat\")    which will return true . Of course, we don't need to use occursin to test that two strings are equal,    \"cat\"==\"cat\"    will do this. The occursin command will just determine if there is the first string somewhere inside the second string. So occursin(\"cat\", \"scatter\") will return true , but occursin(\"cat\", \"cottage\") will return false .  We haven't used a regular expression yet. In Julia, we can make a regular expression by prepending a string with an r . For example, let's say that we want to a string to start with the string \"cat\" . We can do this with    occursin(r\"^cat\", \"catalog\")    which returns true , however occursin(r\"^cat\", \"scatter\") will return false . The ^ at the beginning of the regular expression indicates that the following characters must start the string. Before going on, note that regular expressions are strings that are interpreted in a particular way. With this example, we have seen that there are two types of characters, special characters like ^ and regular characters , like the letters of the latin alphabet. The special characters have a meaning associated with them and regular characters do not have anything special.  Another special character is the $ which means to match the end of the string. So occursin(r\"cat$\", \"tigercat\") will return true, whereas occursin(r\"cat$\", \"catalog\") will return false .    Optional matches  Typically we want more flexibility with regular expressions. For example, instead of matching \"cat\" , what if we want to match \"cat\" , \"cot\" or \"cut\" ? We can do this with a option group which is a set of [] . For example a regular expression r\"c[aou]t\" will match \"cat\" , \"cot\" or \"cut\" such as    map(s -> occursin(r\"c[auo]t\", s), [\"cat\", \"cot\", \"cut\"])    returns true (as a boolean vector) for all three matches. Note: this will also match \"scatter\" , \"cotangent\" and \"cutlery\" .  If we want a range of values, we can use a - within the [] , which is known as a character class in the world of regular expressions. For example, finding words that start with the lower case letters a through f , we can use the regular expression r\"^[a-f]\" . A test for this would be    occursin(r\"^[a-f]\",\"apple\")  occursin(r\"^[a-f]\",\"catalog\")    both return true . Now to confuse things, ^ can be used within the [] for a not in. Let's say we don't what a string to start with a through f . Entering    occursin(r\"^[^a-f]\",\"apple\")  occursin(r\"^[^a-f]\",\"zebra\")    the first returns false while the second returns true .  If we want any character matched, we use a . . For example, if the the regular expression r\"c.t\" can be used    occursin(r\"c.t\",\"catalog\")  occursin(r\"c.t\",\"yacht\")  occursin(r\"c.t\",\"tact\")    the first 2 return true and the last is false.   Write a regular expression that tests for four-letter words that have \"oo\" or \"ee\" in the middle like fool or seen . Test on these words as well as ones that aren't four letters and don't have the double \"o\" or \"e\".     Digits and alphabetic characters  Using the technique in the previous section, we can match a digit with the regular expression r\"[0-9]\" . For example,    occursin(r\"^[0-9]\",\"1234\")    returns true . However since matching digits is a common occurrence, \\d can be used to match digits. Therefore,    occursin(r\"^\\d\",\"1234\")    returns true as well. To match alphabetic characters, there are a couple of options. If you are looking for precisely the 26 lowercase latin characters then [a-z] is the best way to do this. However, there are many characters (such as letters with accents) or unicode characters that are alphabetic and there is a [[:alpha:]] . Some examples are:    occursin(r\"^[a-z],[\"apple\", \"zebra\", \"1234\"])    returns true for the first two and false for the third. To use the broader [:alpha:] class of characters, as an example    map(s -> occursin(r\"^[[:alpha:]]\",s) , [\"apple\", \"ωγ\", \"1234\"])    returns true for the first two and false for the third one. Note that typically it is used within a [] block as well since it is a set of optional characters.  Lastly, another helpful special character is that of a word character, \\w . This will match an alphabetic character, a digit or an underscore _ . An example is    map(s -> occursin(r\"\\w\\w\\w\", s), [\"r2c\", \"ww_c\", \"i a\"])    which returns true, true and false. The last one because the 2nd character is a space.  White space is also something to detect. Although, it can be used with occursin , a more practical way to use this is with split , which takes a string and splits it. We saw this in , but in that section only specific strings were allowed. For example,    split(\"The dog jumps over the log\", r\"\\s\")    where some of the spaces are tabs and others are a space character. This returns the array    [\"The\", \"dog\", \"jumps\", \"over\", \"the\", \"log\"]    Another example would be    split(\"1.0,2.0,3.0;4.5,7.9;-10\", r\"[,;]\")    which returns [1.0, 2.0, 3.0, 4.5, 7.9, -10] and recall that the regular expression is basically , or ; .   Write a regular expression to match five-letter words (which may be useful for solving Wordle). Start first with the lower-case latin characters and then allow other characters like the greek letters. Test against 4, 5 and 6 letter words that should and should not match.     Quantifiers  We often want to know if a character is repeated some number of times. For example, if we want to check that c is repeated three times, we can use r\"ccc\" , however, we can also write this as r\"c{3}\" , which is actually longer, but sometimes easier to read. If we want to test if there are between 2 and 4 consecutive c s, then we can use r\"c{2,4}\" . As an example, consider:    map(s -> occursin(r\"^c{2,4}$\",s),[\"c\",\"cc\",\"ccc\",\"cccc\",\"ccccc\"])    which returns [false, true, true, true, false] and note that the regular expression includes a ^ and $ indicating that it needs to match at the beginning and end. If we want to say it matches 3 or more times, we can use r\"c{3,}\" as in    map(s -> occursin(r\"^c{3,}$\",s),[\"c\",\"cc\",\"ccc\",\"cccc\",\"ccccc\"])    which returns [false, false, true, true, true] and if we want a maximum of 3, use r\"c{,3} as in    map(s -> occursin(r\"^c{0,3}$\",s),[\"c\",\"cc\",\"ccc\",\"cccc\",\"ccccc\"])    which returns [true, true, true, false, false] . There are two quantifiers that are used more than any other: matching 0 or more times and 1 or more times. Because of this, these have special characters * and + . For example to match 0 or more c , then we use r\"c*\" . For example,    map(s -> occursin(r\"^c*a\",s),[\"a\",\"ca\",\"cca\",\"ccca\",\"cccca\"])    will match zero or more c at the beginning of the string. All five of the above match. In contrast if we use r\"^c+a\" , then    map(s -> occursin(r\"^c+a\",s),[\"a\",\"ca\",\"cca\",\"ccca\",\"cccca\"])    then the first one does not match, but the others do. The last example of this is the regular expression .* , which matches any character 0 or more times. At first glance this doesn't seem useful   Rewrite the regular expression finds four-letter words that you did above in to use quantifiers.      Matching integers and decimals  Examples below will parse integers and decimals from a string and we'll use regular expressions to do this work. As we saw above, to match a digit, we will use \\d and if we want more than one decimal, we can follow that with the + . For a positive integer, the regular expression can match with r\"\\d+\" . For example,    occursin(r\"\\d+\",\"1234\")    returns true . If we want to include a + or - sign with the integer, we can use a [+-]? in front of the number. Therefore,    int_re = r\"^[+-]?\\d+$\"  map(s-> occursin(int_re,s),[\"1234\", \"+1234\", \"-1234\"])    which returns true for all three (as a boolean vector). Note: below, we'll do a better job with testing these.  To match a decimal, we can start with the integer match and tack on a decimal point ( \\. , where it needs to be escaped) as well as additional decimals. A reasonably robust decimal regular expression is:    dec_re = r\"^[-+]?\\d+\\.\\d*$\"    There's a few things to note here:     The front of this regular expression is the same as the integer version: [+-]?\\d+ .    The remaining part of the regular expression ( \\.\\d* ) is for the decimal point and any trailing digits. The decimal point is escaped because . matches any character. The result matches any number (0 or more) of digits.     Here's a small number of tests for this:    map(s -> occursin(dec_re, s),[\"-1.3\", \"-1.\", \"14.0343\", \"14\", \"-15\"])    and the first three return true. The last two do not since they are missing decimal points. Lastly, if we want this to match either of the integer or decimal number (which we will do below), we'll take the decimal point and training digits as a group and make it optional. That is,    int_or_dec_re = r\"^[-+]?\\d+(\\.\\d*)?\"$\"    and we'll test it with the previous test or    map(s -> occursin(int_or_dec_re, s),[\"-1.3\", \"-1.\", \"14.0343\", \"14\", \"-15\"])    which returns all true.   Recall that floating point numbers that are written in scientific notation like 1.234e-4 which represents . Update the regular expression above to handle these type of numbers, recalling that the front is just a decimal, so you can just handle the e-4 above. Make this part optional.     Matching and Capture Groups  Generally, it is desirable to pull out a substring from a string and regular expression are good at this. For example, we may want to pass along a string and pull out an integer or decimal for parsing to a Int or Float .  Let's say that we have a string \"(14,-34)\" that we wish to parse as a point in the plane. We will start with a pair of integers. Since we want to capture both numbers, we will surround these by ( ) . Define    pt_re = r\"^\\(([+-]?\\d+),([+-]?\\d+)\\)$\"    where the parentheses at the beginning and end need to be escaped at \\( and \\) . If we then test for matching with    occursin(pt_re,\"(14,-17)\")    which returns true . This is nice that if say it matches, but we would like to determine the substrings for the two points. We can do this with the match function like    m = match(pt_re, \"(14,-17)\")    which returns    RegexMatch(\"(14,-17)\", 1=\"14\", 2=\"-17\")    which is an object (struct) that captures information about the match. The first argument is the string that matches the regular expression, which is the full string. The next two are the two capture groups. We can access these with m1[1] and m1[2] .  Update the regular expression above to handle a point of two integers or floating point numbers. Test your regular expression with the match command.    Replacing substrings with regular expressions.  Above, we used regular expressions in three ways. occursin , which returns true or false if there is a substring within or regular expression that matches a larger string. Secondly, we used the match function to extract parts of a string. Lastly, we used a regular expression to split a string into an array of other strings. In this section, we will see a couple of other ways regular expressions can be used.  Replacing strings with another string is quite helpful. A simple non-regex versions is the following:    replace(\"Alice like cookies. Also, Alice doesn't like carrots.\", \"Alice\" => \"Ben\")    which returns    \"Ben like cookies. Also, Ben doesn't like carrots.\"    Replace is more powerful that just simple string. We can use a regular expression as well. Consider    replace(\"Is there a doctor in the house? There is.\", r\"[Ii]s\" => \"are\")    which returns    \"are there a doctor in the house? There are.\"    And lastly, we can use capture groups as well. Consider the following:    replace(\"Are the kids still in the pond? Are the adults sitting on the beach?\", \"Are\" => \"Is\", r\"\\s(\\w+)s\\s\" => s\" \\1 \")    returns \"Is the kid still in the pond? Is the adult sitting on the beach?\" . First, notice that we have multiple replacements. Also, on the replacements, we have a regular expression with a capture group (with parentheses) and we have a substitution string s\" \\1 \" which starts with an s . Note that the substitution string has a \\1 , which will be the matched capture group. This allow us to replace both adults and kids .    Parsing a Polynomial   We now turn to an example of parsing a string to interpret as a polynomial. A goal will be to add a constructor to our Polynomial module that will take a string and if it can be written as a polynomial, to parse it and store it as a polynomial. For example, here are some examples    5x-10  3x^2-7x+11  -5.6x^11+7.349x^5+x    Although we hope to eventually do general polynomials, let's start with a linear function, like the top one above. Also for simplicity, we'll assume that the coefficients are integers and that the variable is x . To start, let's build a regular expression that will start with an integer (to be captured) followed by an x followed by another integer (to be captured). The following will do this    lin = r\"([+-]?\\d+)x([+-]\\d+)\"    A few things to note about this     Although we typically don't append a + to a positive integer, but it is a valid way to write one, so so the [+-] handles this.    The [+-] doesn't need to be there (we assume it is positive if missing), so we append a ? on this.    The \\d+ matches any length sequence of digits, so this is the integer without the sign.    The sign and the digits are surrounded by () , so this is our first capture group. This will be parsed as our first coefficient.    The second capture group is the same as the first except that the sign is not optional.       Testing the regular expression  Clearly the regular expression should be tested. We will use the tools from the Test package that was explained in . To start with we'll make a testset for linear functions using   @testset \"Linear Functions\" begin @test match(lin, \"5x-10\") !== nothing @test match(lin, \"-5x-10\") !== nothing @test match(lin, \"5x+10\") !== nothing @test match(lin, \"-5x+10\") !== nothing end   Right now, we just want to make sure that four strings above match the regular expression for linear relationships. Note that this seems to take care of all linear functions (with integer coefficients) in that either of the coefficients can be positive or negative. Running this you will see that all test pass. However, did we capture all linear relationships? A couple stand out to me after thinking a bit. \"5x\" itself is a linear function as is 5*x+10 and if we add these to the tests, they will fail.  Since we want to include the * character as optional between the coefficient and the x and also the constant coefficient, we will append a ? to each of these as    lin = r\"([-+]?\\d+)\\*?x([-+]?\\d+)?\"    noting that * is a special character so needs to be escaped as \\* . Now the test set:    @testset \"Linear Functions\" begin  @test match(lin, \"5x-10\") !== nothing  @test match(lin, \"-5x-10\") !== nothing  @test match(lin, \"5x+10\") !== nothing  @test match(lin, \"-5x+10\") !== nothing  @test match(lin, \"5x\") !== nothing  @test match(lin, \"5*x-10\") !== nothing  end    will pass for all the tests.    Linear Functions with decimal coefficients  As we saw above, we have a regular expression to handle decimal coefficients. This is    dec = r\"^([-+]?\\d+(\\.\\d*)?)$\"    We can update our linear function to include decimals for the coefficients by replacing the integer coefficient regular expression with that of the one above.    lin_dec = r\"([-+]?\\d+(\\.\\d*)?)\\*?x([-+]?\\d+(\\.\\d*)?)?\"    the above set of sets can be updated to use this instead. (Try it!) and also include a new set of tests with decimal coefficients:    @testset \"Linear Functions with decimal coefficients\" begin  @test match(lin_dec, \"5.0x-10.5\") !== nothing  @test match(lin_dec, \"-5.9x-10.2\") !== nothing  @test match(lin_dec, \"5.3x+10.4\") !== nothing  @test match(lin_dec, \"-5.25x+10.8\") !== nothing  @test match(lin_dec, \"5.x\") !== nothing  @test match(lin_dec, \"5.3*x-10.55\") !== nothing  end      Splitting a Polynomial into terms  With the success of parsing a linear function, we could next generate a quadratic polynomial, however, we would like to parse a general polynomial and since a term could have any power (that is, the degree of the polynomial could be any positive integer), this isn't practical to generate this way.  Instead, we will split up the polynomial into terms. For an example, let's start with which we will write as the string 4x^3-2x^2+6 . To split the polynomial, there is a split function that we can split on either a + or - , however that sign is not saved. Instead, the following will do what we want:   function splitPoly(p::String) local terms = String[] # if the first character is a +\/-, start the index at 2 local ind1 = occursin(r\"^[+-]\",p) ? 2 : 1 while true ind2 = findnext(r\"[+-]\", p, ind1) if ind2 == nothing # Push the last term onto the term stack. push!(terms, string(SubString(p, ind1-1))) break end # The first time through the loop, the substring calculation is different. push!(terms, string(SubString(p,(ind1 == 1 ? 1 : ind1 -1):first(ind2)-1))) ind1 = first(ind2)+1 end terms end   And since this is relatively large, let's walk through the steps:     Line 2: terms stores the terms as an array of strings. This will act like a stack.    Line 4: the variable ind1 will be the first index of the array substring. Later in the function, we will pull out from the polynomial string between ind1 and ind2 (or adjusted a bit). If the polynomial string has a sign, then we start the index at 2, otherwise at 1.    Line 6: in general, while true is a surefire way to get an infinite loop since there is no stopping condition. However, the if statement starting on line 8 will check if we're done and break out of the loop.    Line 7: this determines the second index which will extract the substring from the polynomial string. Note that result of this is a UnitRange .    Line 8: if there is no match for a +\/-, the result of ind2 is nothing     Line 10: As the comment says, we are at the end of the string, and push the last terms onto the terms array. When SubString is called with only one index, it takes the end of the string. Also, we covert the SubString to a String with the string command.    Line 14: For a match on a +\/-, we push the proper substring onto the terms array. If ind1 is 1, we need to adjust the string (beginning of the string). Also, note that since ind2 is a UnitRange , we take the first value of the range.    Line 15: take ind1 to be the next character after ind2 before repeating the loop.     Let's check with the string 4x^3-2x+6 that this works. Calling    splitPoly(\"4x^3-2+6\")    returns    3-element Vector{String}:  \"4x^3\"  \"-2x\"  \"+6\"    which appears to work well. (Note: later, we will do some testing after converting to Polynomial objects.)    Parsing Polynomial Terms  The next step is to parse the individual terms of the polynomial. For this, we will use a a regular expression to handle this. For first step, let's assume that the constant out front is an integer. The following will parse these terms:    poly_re = r\"^([+-]?\\d+)(x(\\^(\\d+))?)?$\"    And let's test this on the 4x^3 term with    m1 = match(poly_re, \"4x^3\")    which returns    RegexMatch(\"4x^3\", 1=\"4\", 2=\"x^3\", 3=\"^3\", 4=\"3\")    and you should notice that m[1] will be the coefficient and m[4] will be the power. If we test the next term with    m2 = match(poly_re, \"-2x\")    this returns    RegexMatch(\"-2x\", 1=\"-2\", 2=\"x\", 3=nothing, 4=nothing)    and you should notice that again m2[1] is the coefficient and since m2[4] is nothing that this is a linear term. And finally,    m3 = match(poly_re, \"+6\")    returns    RegexMatch(\"+6\", 1=\"+6\", 2=nothing, 3=nothing, 4=nothing)    and there is no match for the last 3 capture groups, so this is just a constant term.  Although this looks good, thinking a bit ahead, if we have a polynomial term like -x^2 , this will not parse this. Try    match(poly_re, \"-x^2\")    returns nothing. We will tweak the regular expression above to allow a + or - with no number in front of the x term.    poly_re = r\"^([+-]?)(\\d+)?(x(\\^(\\d+))?)?$\"    and now rerunning the line above results in    RegexMatch(\"-x^2\", 1=\"-\", 2=nothing, 3=\"x^2\", 4=\"^2\", 5=\"2\")    which shows that it matches. Note that these are different than the matches above--there are 5 capture groups now. It is noted that the 2nd group matched nothing because there was no numerical coefficient before the x^2 term.    "
},
{
  "id": "ch-regexp-3-2-8",
  "level": "2",
  "url": "ch-regexp.html#ch-regexp-3-2-8",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "special characters regular characters "
},
{
  "id": "ch-regexp-3-3-13",
  "level": "2",
  "url": "ch-regexp.html#ch-regexp-3-3-13",
  "type": "Check Your Understanding",
  "number": "24.1",
  "title": "",
  "body": " Write a regular expression that tests for four-letter words that have \"oo\" or \"ee\" in the middle like fool or seen . Test on these words as well as ones that aren't four letters and don't have the double \"o\" or \"e\".  "
},
{
  "id": "exer-four-letter",
  "level": "2",
  "url": "ch-regexp.html#exer-four-letter",
  "type": "Check Your Understanding",
  "number": "24.2",
  "title": "",
  "body": " Write a regular expression to match five-letter words (which may be useful for solving Wordle). Start first with the lower-case latin characters and then allow other characters like the greek letters. Test against 4, 5 and 6 letter words that should and should not match.  "
},
{
  "id": "ch-regexp-3-5-13",
  "level": "2",
  "url": "ch-regexp.html#ch-regexp-3-5-13",
  "type": "Check Your Understanding",
  "number": "24.3",
  "title": "",
  "body": " Rewrite the regular expression finds four-letter words that you did above in to use quantifiers.  "
},
{
  "id": "ch-regexp-4-18",
  "level": "2",
  "url": "ch-regexp.html#ch-regexp-4-18",
  "type": "Check Your Understanding",
  "number": "24.4",
  "title": "",
  "body": " Recall that floating point numbers that are written in scientific notation like 1.234e-4 which represents . Update the regular expression above to handle these type of numbers, recalling that the front is just a decimal, so you can just handle the e-4 above. Make this part optional.  "
},
{
  "id": "ch-regexp-5-12",
  "level": "2",
  "url": "ch-regexp.html#ch-regexp-5-12",
  "type": "Check Your Understanding",
  "number": "24.5",
  "title": "",
  "body": "Update the regular expression above to handle a point of two integers or floating point numbers. Test your regular expression with the match command. "
},
{
  "id": "ch-data",
  "level": "1",
  "url": "ch-data.html",
  "type": "Chapter",
  "number": "25",
  "title": "Introduction to Data Analysis",
  "body": " Introduction to Data Analysis   Data is ubiquitous these days and being able to analyze it is crucial. In this section, we will first load a dataset that is available as a Julia package, plot the data and do some basic analysis of DataFrame s. Then, data will be loaded from a file. In addition, a package will be used to string together operation on dataframes.    Data from the RDatasets package  The statistical software\/language called R has many built-in and loadable datasets. A julia package called RDatasets has many of these datasets and additionally we will use the StatsPlots package. You will probably need to add these packages before    using RDatasets, StatsPlots    The datasets are subdivided into package and you can see the entire list of the packages with    RDatasets.packages()    The top of this output looks like:    34×2 DataFrame 9 rows omitted  Row Package Title  String15 String  1 COUNT Functions, data and code for count data.  2 Ecdat Data sets for econometrics  3 HSAUR A Handbook of Statistical Analyses Using R (1st Edition)  4 HistData Data sets from the history of statistics and data visualization    Each of these is a package and a listing of all of the datasets in given package can be found with    RDatasets.datasets(\"datasets\")    as an example. The top of this looks like:    50×5 DataFrame 25 rows omitted  Row Package Dataset Title Rows Columns  String15 String31 String Int64 Int64  1 datasets BOD Biochemical Oxygen Demand 6 2  2 datasets CO2 Carbon Dioxide Uptake in Grass Plants 84 5  3 datasets Formaldehyde Determination of Formaldehyde 6 2  4 datasets HairEyeColor Hair and Eye Color of Statistics Students 32 4  5 datasets InsectSprays Effectiveness of Insect Sprays 72 2  6 datasets LifeCycleSavings Intercountry Life-Cycle Savings Data 50 6  7 datasets Loblolly Growth of Loblolly pine trees 84 4    Each row in this table is now a dataset with given number of rows\/column. We can load the dataset with the dataset function and it is not exported from the module, so must be called as the full path. For example, we can load the classsic iris dataset from this to view:    iris=RDatasets.dataset(\"datasets\",\"iris\")    The top of the dataset returns as:    150×5 DataFrame 125 rows omitted  Row SepalLength SepalWidth PetalLength PetalWidth Species  Float64 Float64 Float64 Float64 Cat…  1 5.1 3.5 1.4 0.2 setosa  2 4.9 3.0 1.4 0.2 setosa  3 4.7 3.2 1.3 0.2 setosa  4 4.6 3.1 1.5 0.2 setosa  5 5.0 3.6 1.4 0.2 setosa  6 5.4 3.9 1.7 0.4 setosa    The first line of the output of the dataset shows the size (number of rows and then number of columns). The second line is the column names, the third line is the datatype for each column. The first column is row number (not part of the dataset). The last column is a categorical datatype and more will be said about this later.    Dataframes   In some ways, a DataFrame is like a 2D array in terms of accessing parts of the array, but in many ways it is very different. Notice that the columns of the iris  DataFrame are different types, but it is important that each column has a fixed data type. This data type is always at the top of the column.  This is very different than a 2D array in that the entire array must have the same type. Julia has the ability to have an array of Any and then anything can go there, but anytime julia doesn't know a data type, it slows down calculations tremendously. A better way to think of a DataFrame is that of a collection of Vectors (1D arrays), where each array (column) has a name.  We can access the DataFrame using some of the syntax from arrays. For example, iris[2,3] will return the element in the 2nd row and 3rd column. Many of the array accessing methods from also work.  There are other nice features though as typically we want to do things on columns. For example: iris[!,:PetalLength] returns a 1D Array (of Float64 ). The ! in the first slot means to use all rows. If we want the 11th through the 20th row of the SepalWidth column, enter    iris[11:20,:SepalWidth]    which returns    10-element Vector{Float64}:  3.7  3.4  3.0  3.0  4.0  4.4  3.9  3.5  3.8  3.8    A perhaps-confusing result of using a DataFrame in a Jupyter notebook, is that there is a limit on the number of columns and rows shown. There is a fixed number of rows (25) shown at the top and bottom of the data frame. To change this (and often I think it shows too many rows), set the DATAFRAMES_ROWS variable in the following way:    ENV[\"DATAFRAMES_ROWS\"] = 10    You may also see at the top of the output for a DataFrame that it may say that some of the columns are hidden. The default number of columns is 100 and in most environments, generally you can scroll left and right to see all of the columns. To change the number of columns, set the DATAFRAMES_COLUMNS , like above. (I haven't had a dataset with more than this number of columns.)    Constructing a DataFrame  Although nearly always, you will use a DataFrame by loading in a dataset, a DataFrame can be created by specifying the columns. Consider:    data = DataFrame(  A = 1:2:13,  B = [\"M\", \"F\", \"F\", \"M\", \"X\", \"F\", \"M\"],  C = [3.0, 2.5, pi, -2.3, 1\/3, 56, 100],  D = [(-1)^n\/\/n for n=1:7]  )    which will create a DataFrame with column names A, B and C and Julia interprets the data types of each column. Note: this can all be put on a single line, but for readibility, the 4 columns are place on separate rows. The result of this is    7×4 DataFrame  Row A B C D  Int64 String Float64 Rational…  1 1 M 3.0 -1\/\/1  2 3 F 2.5 1\/\/2  3 5 F 3.14159 -1\/\/3  4 7 M -2.3 1\/\/4  5 9 X 0.333333 -1\/\/5  6 11 F 56.0 1\/\/6  7 13 M 100.0 -1\/\/7    There's a number of helpful functions associated with DataFrames:      size(df) : similar to an array, returns the number of rows and columns.     names(df) : Names of the columns as an array     describe(df) : summary of basic statistics of each column of the dataframe.     first(df,n) and last(df,n) : prints the top and bottom rows of the dataframe.       Plotting with StatsPlots  We can do a scatter plot of the first two columns in the following manner:    scatter(iris[!,:SepalLength],iris[!,:SepalWidth], legend=false)    and the resulting plot is     (for accessibility)    There are some nice features using the package StatsPlots . For example, the following will produce the same plot:    @df iris scatter(:SepalLength,:SepalWidth, legend = false)    where the @df macro says to use the DataFrame iris and then any column information is interpreted to be of that DataFrame.  Recall above that there was a Categorical datatype in the column Species . The following scatter plot delineates the species with different colors:    @df iris scatter(:SepalLength,:SepalWidth,group=:Species)    and this results in     (for accessibility)      Basic Statistics  As mentioned above, we can find summary statistics of a DataFrame with the describe function. For example, describe(iris) returns    5×7 DataFrame  Row variable mean min median max nmissing eltype  Symbol Union… Any Union… Any Int64 DataType  1 SepalLength 5.84333 4.3 5.8 7.9 0 Float64  2 SepalWidth 3.05733 2.0 3.0 4.4 0 Float64  3 PetalLength 3.758 1.0 4.35 6.9 0 Float64  4 PetalWidth 1.19933 0.1 1.3 2.5 0 Float64  5 Species setosa virginica 0 CategoricalValue{String, UInt8}    Note that the output of describe is itself a DataFrame. For numerical data, the mean, min, median and max are clear but for Categorical data, only the min and max are listed with the min and max sorted categories only listed.  You can also call functions like mean or std directly if you have loaded the Statistics package (which you may have to add) with the command using Statistics . Now, we can find the mean and standard deviation of columns with    mean(iris[!,:SepalLength]),std(iris[!,:SepalLength])    will compute both and return: (5.843333333333334, 0.828066127977863)   The Statistics package also has the functions to compute the variance, weighted means, median and quartiles. The julia documentation on this package has more information.  For another example that we will also use below, consider this DataFrame:   simpsons = DataFrame( id = 1:2:13, name = [\"Homer\", \"Marge\", \"Lisa\", \"Bart\", \"Maggie\", \"Apu\", \"Moe\"], age = [45, 42, 8, 10, 1, 38, 59], salary = [50000, 25000, 10000, missing, missing, 45000, 3000], favorite_food = [\"pork chops\", \"casserole\", \"salad\", \"hamburger\", missing, \"saag paneer\", \"peanuts\"] )   if we enter describe(simpsons) , we get the following results:    5×7 DataFrame  Row variable mean min median max nmissing eltype  Symbol Union… Any Union… Any Int64 Type  1 id 7.0 1 7.0 13 0 Int64  2 name Apu Moe 0 String  3 age 29.0 1 38.0 59 0 Int64  4 salary 26600.0 3000 25000.0 50000 2 Union{Missing, Int64}  5 favorite_food casserole salad 1 Union{Missing, String}    There are some new things that occur here. First of all, we have missing data that we added to this DataFrame explicitly. Since this is true, the column nmissing which reports the number of missing elements in the column is not zero for the salary and favorite_food columns. Also, the eltype short for element type, is a Union type meaning that element in the column are either of Missing type (explained below) or of another type (either Int64 or String ).     The pipe command   Although this isn't exclusive to data analysis, piping to commands is common, so we address it here. First, let's look at a non data example.  Consider a complicated nested example, like:    sqrt(sin(big(2.0)))    which returns 0.9535708819095105398718705441330078869495314128723191646104050462287315327622005 .  In standard parsing rules, we work inside to the outside, which can get complicated. Often, it's easier to start with the value 2.0 and apply each of the functions as the expression is worked through. In many computing environments, including Julia, this is possible with the pipe |> to rewrite the order of operations. The above example can be written:    2.0 |> big |> sin |> sqrt    and this returns the same result.  This expression can be thought of as starting with 2.0, then piping to the big function, then to the sin function, then to the sqrt function. This can also be thought of as Reverse Polish Notation or postfix notation and once understood, it is quite helpful in tackling complex tasks.  As an example, recall that to remove an element from an array, we can use the deleteat function. Without pipes we would write this as    deleteat!([1,2,3,4,5],3)    and this returns [1, 2, 4, 5]   To use this starting with the array [1,2,3,4,5] we could do    [1,2,3,4,5] |> arr -> deleteat!(arr,3)    and this returns the same array. We could extend this further in that    1:5 |> collect |> arr -> deleteat!(arr,3)    which again returns the same. Note that since the collect function take only one argument, you don't need to use the anonymous function syntax, however, deleteat needs two arguments, so it does require the anonymous function syntax.  Lastly, inside of a jupyter cell, we can generally write this as    1:5 |>  collect |>  arr -> deleteat!(arr,3)    where this is often clearer in that each step is on a separate line and does a separate thing.    Using the Chain package  The Chain package simplifies some of these steps up. First, make sure that the package is added and then loaded with using Chain . Overall, a number of steps are done to an initial piece of data. Above, we saw an array, in the next chapter we will see this with a DataFrame. The general structure is    @chain data begin  # functions applied to data in order  end    and the functions that are applied are written on separate lines without the |> . For example, the removal of an item from an array can be written:    @chain 1:5 begin  collect  deleteat!(3)  end    Hopefully, you can see that this syntax is cleaner and in many ways easier to read. Remember that using @chain results in the previous line always been applied to the function on the current line, so the collect line is really collect(1:10) , what happens with the third line? Since deleteat! requires two arguments, @chain automatically puts the result above into the first slot of the function. We'll see below if we need to do something different.  For another example, let's say we want to do the following. Start with the vector [1,2,3,4,5,6,7,8,9,10] , then   square each element    keep all even numbers    find the mean.     Basically each of these steps will be on a separate line within a @chain block.    @chain 1:10 begin  map(x -> x^2, _)  mean  end    A few things to notice here. First, instead of starting with the integer vector of numbers between 1 and 10, we use the UnitRange of 1:10 . This is just for simplicity. Secondly, you'll notice that there is an underscore character _ in the second line. This means that the result of the previous line should be put where the _ is. And since the array (or the Unit Range) needs to be in the second slot of the map function, we need to use the underscore.     Missing Data   For the example above with the simpsons dataset, there were missing values. Although this set was manufactured, real datasets often have missing values that one needs to deal with. Julia has a standard data type called Missing and it has a single value of that data called missing (notice the different capitalization for both). The julia Documentation on Missing Data is a good place to read up on details of this.  There is some interesting properties of the value missing . For example    missing + 6    returns missing and pretty much any operation on a missing value returns missing because the idea is that if you don't know the value, how can calculate with it. Another example is    mean([1,missing,3,4,5])    also returns missing .    Missing Data in a Dataset  Let's revisit the dataset called simpsons from the previous section. Notice that there are a number of missing values have been put in. We'll notice something different about the data types. If we look at the salary column:    typeof(simpsons[!,:salary])    we see that the type is Vector{Union{Missing, Int64}} which means that the type of elements in the array are Union{Missing,Int64 } which is julia's way of saying that the type can be either Missing or Int64 .  Now, let's get down to some analyzing of the data. Let's find the average salary in the dataset with    mean(simpsons[!,:salary])    which returns missing , which makes sense from the above discussion that nearly every operation with missing returns missing.  Instead, we may want to ignore the missing values, so we can use the skipmissing function.    ages = skipmissing(simpsons[!,:salary])    we get skipmissing(Union{Missing, Int64}[50000, 25000, 10000, missing, missing, 45000, 3000]) which seems quite complicated in that we get another array, however, if we    mean(salary)    then it finds the mean of the non-missing values and returns 26600.0 .  We will run into missing values in the next few chapters where we use actual datasets and it is very common to have missing data in such datasets.     Loading Data from a CSV File  As we will see in and , data will be located in a file instead of typed in directly. In this section, we will look at how to load the data from a CSV (comma separated value) file, the most common format for data that has the form in which each row represents a different value with columns representing variables.  We will use the CSV package to load files. Recall that you will need to add and load it (with using CSV ) before being able to use it.  Consider the file simple.csv . Download this and move it into the same directory where your ipynb file is. We will load it with    simple = CSV.read(\"simple.csv\", DataFrame)    and the result is    6×5 DataFrame  Row Name Age Sex Shoe Size Pay Rate  String15 Int64 String1 Float64 Float64  1 Alice 18 F 6.5 15.5  2 Barry 24 M 12.0 18.25  3 Charlize 45 X 8.0 22.5  4 Doreen 72 F 7.5 24.5  5 Edgar 64 M 10.0 33.0  6 Francine 16 F 9.0 18.75      And you should notice a few different things about this. First, for the two string datatypes, they are String15 and String1 . The number refers to the length of the string used. This is mainly for efficiency of storage. Secondly, the column names (top line) have two that have spaces in them. Although we can deal with this, we will have to refer to name like :\"Shoe Size\" . We can reload the file with the normalizenames keyword argument as follows:    CSV.read(\"simple.csv\", DataFrame, normalizenames = true)    and the names will replace the space with an underscore _ .  Another nice option that we will see in is that of reading in missing data. Often a file will use a character or string to denote that the value is missing. We can use the missingstring option to tell the CSV.read command to covert a string, like \"NA\" to missing .  There are many other options to reading in a CSV file and you may need these. The documentation for the CSV pacakage is quite good with many examples.    Loading Data from an Excel File  Another common file format for data is that of a Microsoft Excel file (also known as a xlsx file). This is generally not a good format for data for two main reasons. First, it is a proprietary format--although a lot of different software can read and write this format. Secondly, these files can contain spreadsheet functions, so it can contain more than data.  We will use the XLSX package and take a look at the documentation . Don't forget to download it and load it. The simple dataset is also stored as an excel file.  Because excel files have sheets, there is generally extra steps involved into loading the data. Starting with    xf = XLSX.readxlsx(\"simple.xlsx\")    and this returns    XLSXFile(\"simple.xlsx\") containing 1 Worksheet  sheetname size range  -------------------------------------------------  Sheet1 7x5 A1:E7    Note that this shows that there is only one sheet within the file. It is called Sheet1 and the cells where the data is is listed as well. Since we typically want to load data into a DataFrame, we can do that with    df = DataFrame(XLSX.readtable(\"simple.xlsx\", \"Sheet1\"))    and this will return:    6×5 DataFrame  Row Name Age Sex Shoe Size Pay Rate  Any Any Any Any Any  1 Alice 18 F 6.5 15.5  2 Barry 24 M 12.0 18.25  3 Charlize 45 X 8.0 22.5  4 Doreen 72 F 7.5 24.5  5 Edgar 64 M 10.0 33.0  6 Francine 16 F 9.0 18.75      There are a couple of issues with this DataFrame. First, the data types are all Any and recall if performance is important, one main idea in Julia is that DataTypes should be set when possible. The XLSX.readtable function has the option infer_eltypes=true that attempts to determine the type, however, if we reload the file with    df = DataFrame(XLSX.readtable(\"simple.xlsx\", \"Sheet1\", infer_eltypes=true))    then notice that that this fixed the first three columns, however, the second two are still Any type. (I think this probably happened because some of the numbers are integers, while others are floats and it isn't smart enough to just make everything a float). We can fix this by converting the last two columns to the proper type. The following lines will do this:    df[!,:\"Shoe Size\"] = convert.(Float64, df[!,:\"Shoe Size\"])  df[!,:\"Pay Rate\"] = convert.(Float64, df[!,:\"Pay Rate\"])    where because these two columns have spaces in the names, we need to put double quotes around the names. Also, let's fix this problem with:    rename!(df, :\"Shoe Size\" => :Shoe_Size, :\"Pay Rate\" => :Pay_Rate)    where notice that we have used the rename! with the ! to replace the existing Dataframe. The result of this should show that the column names have changed.   "
},
{
  "id": "fig-example-scatter",
  "level": "2",
  "url": "ch-data.html#fig-example-scatter",
  "type": "Figure",
  "number": "25.1",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-group-scatter",
  "level": "2",
  "url": "ch-data.html#fig-group-scatter",
  "type": "Figure",
  "number": "25.2",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-manipulating-data",
  "level": "1",
  "url": "ch-manipulating-data.html",
  "type": "Chapter",
  "number": "26",
  "title": "Manipulating DataFrames",
  "body": " Manipulating DataFrames   A typically workflow with a dataframe is to start with some data, manipulate the data, perform some calculations, perhaps plot the result. In this section, we will see how to perform calculations (as known as transforming the dataset) as well as a very standard split-transform-combine operations, which takes a dataset, splits it into multiple sets based on some characteristics, transform the smaller sets and then combine the results.    Subsets of DataFrames   The typical subsets of a DataFrame are either limiting the columns or the rows in some sense. Let's return to the very simple DataFrame from the previous chapter.    data = DataFrame(  A = 1:2:13,  B = [\"M\", \"F\", \"F\", \"M\", \"X\", \"F\", \"M\"],  C = [3.0, 2.5, pi, -2.3, 1\/3, 56, 100],  D = [(-1)^n\/\/n for n=1:7]  )      Subsets of Columns  We can select only the columns A and D in the following way:   data[:,[:A,:D]]   which returns    7×2 DataFrame  Row A D  Int64 Rational…  1 1 -1\/\/1  2 3 1\/\/2  3 5 -1\/\/3  4 7 1\/\/4  5 9 -1\/\/5  6 11 1\/\/6  7 13 -1\/\/7    Alternatively, we can (and generally will) use the select command, which is in the DataFrames package. The follow gives the same results as above.    select(data, :A, :D)    Lastly, we are going to typically put all of these command in a @chain block, like the following:    @chain data begin  select(:A, :D)  end    which also produces the same result. For this example, this is overkill because it is just a single command on the variable data and using @chain generally only pays off when you apply many commands together.  The Not and Between functions are helpful as well for select columns. For example,    @chain data begin  select(Not(:B))  end    returns the columns A, C and D . The command    @chain data begin  select(Between(:B,:D))  end    returns the last 3 columns of the DataFrame. There are other ways of subsetting by columns including passing in a Regular Expression, which can also be helpful.     Filtering (or Subsetting) Rows  A common method with DataFrames is to filter the rows by some condition. If you want to return the first few rows, the last few rows or a sequence of them, we can use the same technique from . For example, if we only want the first three rows, use data[1:3,:] and if we only want rows 5 to the end, use data[5:end,:] . If we want the odd rows, then data[1:2:end,:] .  The first and last commands from the DataFrames package is also helpful. The first 3 rows can be found with first(data, 3) and similarly, the last 4 rows can be returned with last(data, 4) . Use of these is nice within a @chain block in that the previous technique is a bit more difficult.  There is a filter The syntax of the filter command is similar to that for vectors and not the same as the rest of the other functions in Dataframes, so subset is preferred. With effort, however, filter can be used with DataFrames. however, we will use the subset function instead. We'll take a look at a number of examples of this within a @chian block. To begin with, the following returns all rows where values in the A column is less than 10.    @chain data begin  subset(:A => a-> a .< 10)  end    and this returns    5×4 DataFrame  Row A B C D  Int64 String Float64 Rational…  1 1 M 3.0 -1\/\/1  2 3 F 2.5 1\/\/2  3 5 F 3.14159 -1\/\/3  4 7 M -2.3 1\/\/4  5 9 X 0.333333 -1\/\/5    There is a lot packed into this command. First of all, notice that we want to subset on the A column so we use :A => the rest of this is a function and we use an anonymous function that returns a boolean. Actually, it is a vector of booleans. Recall that select a column of a DataFrame is a vector and select expects a boolean vector to do the filtering. This is which there is a .< instead of a < . Remove the . and you'll see that there is an error.  For our next example, we select all rows where column B equals \"F\". This can be accomplished with    @chain data begin  subset(:B => b-> b .== \"F\")  end    which returns    5×4 DataFrame  Row A B C D  Int64 String Float64 Rational…  1 3 F 2.5 1\/\/2  2 5 F 3.14159 -1\/\/3  3 11 F 56.0 1\/\/6    We can also subset by combinations of columns. For the next example, we'll find where the product of columns C and D are greater than 2. We do this with    @chain data begin  subset([:C, :D] => (c, d) -> c .* d .> 2)  end    which returns    5×4 DataFrame  Row A B C D  Int64 String Float64 Rational…  1 11 F 56.0 1\/\/6    The broadcasting notation can be a bit tricky although nearly always one can write a . in front of operators or append a . to the end of function names. See for more details. Recall that the macro @. will take an expression and vectorize (or broadcast it). Entering    @chain data begin  subset([:C, :D] => (c, d) -> @. c * d > 2)  end    Returns the same result as above. Also, in the DataFrames package, there is a function called ByRow that will perform a row-by-row version of a function which is often needed. The following    @chain data begin  subset([:C, :D] => ByRow((c, d) -> c * d > 2))  end    also returns the same DataFrame.  Using the iris dataset, find all setosa irises (look at the Species column) with SepalWidth larger than 4. How many are there in the dataset?    Transforming DataFrames  Another important technique needed with DataFrames is that of a transformation. In general, this means that a new column is created that is a function of one or more columns. There are two commands using DataFrames that transform dataframes, select and transform . The first is used to create a new DataFrame with generally only one or more transformed columns. The transform method includes the original dataframe with the extra columns defined as the transformation. We'll see the difference here.  If we generate a new DataFrame which is just the square of the A column as    @chain data begin  select(:A => a -> a.^2)  end    and this returns    7×1 DataFrame  Row A_function  Int64  1 1  2 9  3 25  4 49  5 81  6 121  7 169    Notice that the only column in the resulting DataFrame is the new column and it has the column name formed by appending _function to the column name. We can give the column a better name setting this with the fat arrow => such as    @chain data begin  select(:A => (a -> a.^2) => :Asq)  end    and now the column has the name Asq . Note that the parentheses around the anonymous function is needed due to order of operations. Remove them to see the effect.  In contrast if we use the transform method, then the original matrix is preserved and the new columns is added at the end.    @chain data begin  transform(:A => (a -> a.^2) => :Asq)  end    results in    7×5 DataFrame  Row A B C D Asq  Int64 String Float64 Rational… Int64  1 1 M 3.0 -1\/\/1 1  2 3 F 2.5 1\/\/2 9  3 5 F 3.14159 -1\/\/3 25  4 7 M -2.3 1\/\/4 49  5 9 X 0.333333 -1\/\/5 81  6 11 F 56.0 1\/\/6 121  7 13 M 100.0 -1\/\/7 169    Both select and transform can use multiple columns. The following example, takes the product between columns C and D .    @chain data begin  select([:C, :D] => ((c,d) -> @. c*d) => :prod)  end    where the macro @. has been used instead of using .* . This returns    7×1 DataFrame  Row prod  Float64  1 -3.0  2 1.25  3 -1.0472  4 -0.575  5 -0.0666667  6 9.33333  7 -14.2857    Note: there are also commands select and transform that perform the operations within the given dataframe. This can be destructive, but can save a lot of computational time for large DataFrames. It is recommended to stay with the non mutating (without the !) versions unless you need to save time\/memory.  Using the iris dataframe produce a new column called area which is the area of a petal using the PetalLength and PetalWidth variables and the area of an ellipse.    Sorting DataFrames  The DataFrames package also provides easy ways to sort. If we want to sort by the C column, we can do    sort(data, :C)    or staying within a @chain block    @chain data begin  sort(:C)  end    and the results are    7×4 DataFrame  Row A B C D  Int64 String Float64 Rational…  1 7 M -2.3 1\/\/4  2 9 X 0.333333 -1\/\/5  3 3 F 2.5 1\/\/2  4 1 M 3.0 -1\/\/1  5 5 F 3.14159 -1\/\/3  6 11 F 56.0 1\/\/6  7 13 M 100.0 -1\/\/7    where the datatype determines the way to sort. Note that the rows are preserved. This is different than when we saw in which sorted every column in either increasing or decreasing order. In the case of sorting by column C, it is numerically in increasing order. If we want the reverse:    @chain data begin  sort(:C, rev = true)  end    Julia will detect the datatype automatically. If we sort by column B, via    @chain data begin  sort(:B)  end    the result is    7×4 DataFrame  Row A B C D  Int64 String Float64 Rational…  1 3 F 2.5 1\/\/2  2 5 F 3.14159 -1\/\/3  3 11 F 56.0 1\/\/6  4 1 M 3.0 -1\/\/1  5 7 M -2.3 1\/\/4  6 13 M 100.0 -1\/\/7  7 9 X 0.333333 -1\/\/5    which sorts lexiographically automatically. Notice that the other items are not sorted or kept in the same order as original. If we want to sort by another column, say :D , we can do    @chain data begin  sort([:B,:D])  end    where the column names are placed inside an array.    Joining DataFrames  Often, data is split between different tables (or files) and they need to be joined before doing analysis. Let's revisit the dataset from :    simpsons = DataFrame(  name=[\"Homer\",\"Marge\",\"Lisa\",\"Bart\",\"Maggie\",\"Apu\",\"Moe\", \"Milhouse\", \"Patty\"],  age =[45,42,8,10,1,38,59, 10, 46],  current_school_grade = [missing, missing, 2, 4, missing, missing, missing, 4, missing],  favorite_food = [\"pork chops\",\"casserole\",\"salad\",\"hamburger\",missing,\"saag paneer\",\"peanuts\", missing, \"Lady Laramie 100s\"]  )    and a second dataset    jobs = DataFrame(  name = [\"Homer\",\"Marge\",\"Apu\",\"Moe\", \"Wiggam\"],  job = [\"nuclear technician\", \"housewife\", \"store owner\", \"bartender\", \"police chief\"],  salary = [50_000, 25_000, 60_000, 15_000, 75_000]  )    and we want to join these two together. In order to join two datasets, one of the columns in each dataframe needs to match. In this case, the column that makes most sense is the name column, which is common to both. For this example, we'll use the innerjoin command and the keyword attributed on must be used with the format col1 => col2 , where col1 is in the first DataFrame and col2 in the second one. The column that the sets are joined on are called the key of the DataFrame. The innerjoin command returns all rows in which the key is common to both datasets. The inner part is like the intersection of two sets. If we perform the following:    innerjoin(data, simpsons, on = :name => :name)    and the result will be    5×6 DataFrame  Row name age current_school_grade favorite_food job salary  String Int64 Int64? String? String Int64  1 Homer 45 missing pork chops nuclear technician 50000  2 Marge 42 missing casserole housewife 25000  3 Apu 38 missing saag paneer store owner 60000  4 Moe 59 missing peanuts bartender 15000  5 Patty 46 missing Lady Laramie 100s missing missing    Note: in this case, because the column name on the the two dataframes are the same, you can just do on = :name .  You may be surprised that there are only 5 rows in this DataFrame, however, recall that innerjoin merges two DataFrames, by including only where the name column is in both of the two DataFrames. There are other ways to join Dataframes, and a summary is:     innerjoin  the output contains rows for values of the key that exist in all passed data frames.    leftjoin  the output contains rows for values of the key that exist in the first (left) argument, whether or not that value exists in the second (right) argument.    rightjoin  the output contains rows for values of the key that exist in the second (right) argument, whether or not that value exists in the first (left) argument.    outerjoin  the output contains rows for values of the key that exist in any of the passed data frames.    semijoin  Like an inner join, but output is restricted to columns from the first (left) argument.    antijoin  The output contains rows for values of the key that exist in the first (left) but not the second (right) argument. As with semijoin, output is restricted to columns from the first (left) argument.    crossjoin  The output is the cartesian product of rows from all passed data frames.     In the exmaple above, suppose we want a DataFrame with all keys (names). In this case, we will use the outerjoin command. If we evaluate:    outerjoin(simpsons, jobs, on = :name)    then the result is    9×6 DataFrame  Row name age current_school_grade favorite_food job salary  String Int64? Int64? String? String? Int64?  1 Homer 45 missing pork chops nuclear technician 50000  2 Marge 42 missing casserole housewife 25000  3 Apu 38 missing saag paneer store owner 60000  4 Moe 59 missing peanuts bartender 15000  5 Patty 46 missing Lady Laramie 100s missing missing  6 Lisa 8 2 salad missing missing  7 Bart 10 4 hamburger missing missing  8 Maggie 1 missing missing missing missing  9 Milhouse 10 4 missing missing missing  10 Wiggam missing missing missing police chief 75000      Summarizing Data  Generally one wants to summarize a large dataset to a few numbers to get a sense or for comparison purposes. The describe does this, but in a fixed way. A more general function to do this is called the combine function. Consider the following:    combine(data, :C => mean, :D => mean, :C=>std, :C => length)    which returns    1×4 DataFrame  Row C_mean D_mean C_std C_length  Float64 Rational… Float64 Int64  1 23.2393 -319\/\/2940 39.5518 7    And this returns a new dataframe with 1 row and 4 columns (mean of C, mean of D, standard deviation of C and the number of rows in C).  We will also use combine after splitting a dataset for comparison purposes. We'll do this below in     Multiple Steps on a DataFrame  All of the previous examples in this chapter show a single step on a DataFrame. However, typically this is not how operations on DataFrames are not done. There are multiple steps. The next section will show this for a particular sequence of steps, but before moving onto that, let's look at a series of steps. Consider the following steps:     Merge\/join the simpsons and jobs DataFrames as shown above.    Make a new column that is the salary column minus 400 times the age. Call it happiness .    Drop any rows in which the happiness is missing.    Filter out any rows with the happiness column is negative.    Include only the columns name , age , favorite_food and happiness     Sort the result by happiness with largest values on top.     We're going to set this up as a @chain block with a separate line for each step. First, setup the block and peform the merge using innerjoin .    @chain simpsons begin  innerjoin(jobs, on = :name)  end    And this gives the merged dataset as above. Next, we'll use transform to create the happiness column.    @chain data begin  innerjoin(simpsons, on = :A => :id)  transform([:age, :salary] = > ((a, s) -> @. s - 400*a) => :happiness)  end    This will give a new column on the DataFrame with the calculation above. Notice that there is a missing value because the salary is missing on that row. For the next step, we add a dropmissing line like:    @chain data begin  innerjoin(simpsons, on = :A => :id)  transform([:C, :D, :salary] => ((c, d, s) -> @. s + c*d) => :happiness)  dropmissing(:happiness)  end    and the result of this is the following:    4×7 DataFrame  Row name age current_school_grade favorite_food job salary happiness  String Int64 Int64? String? String Int64? Int64  1 Homer 45 missing pork chops nuclear technician 50000 32000  2 Marge 42 missing casserole housewife 25000 8200  3 Apu 38 missing saag paneer store owner 60000 44800  4 Moe 59 missing peanuts bartender 15000 -8600    Next, we want to only include the rows with positive happiness and we can add a subset command. Including this in the @chain block.    @chain data begin  innerjoin(simpsons, on = :A => :id)  transform([:C, :D, :salary] => ((c, d, s) -> @. s + c*d) => :happiness)  dropmissing(:happiness)  subset(:happiness => h -> h .> 0)  end    and this drops the last row from the output above. Note that we have use the broadcast on the greater than ( .> ), however the @. could have also been used.  For the next step, we are only considering a few of the columns, and we can do this with the select command. Adding this to the @chain block as    @chain data begin  innerjoin(simpsons, on = :A => :id)  transform([:C, :D, :salary] => ((c, d, s) -> @. s + c*d) => :happiness)  dropmissing(:happiness)  subset(:happiness => h -> h .> 0)  select(:name, :age, :favorite_food, :happiness)  end    which results in    4×7 DataFrame  Row name age favorite_food happiness  String Int64 String? Int64  1 Homer 45 pork chops 32000  2 Marge 42 casserole 8200  3 Apu 38 saag paneer 44800    and the last step sorts by happiness with rev = true to sort largest to smallest    @chain data begin  innerjoin(simpsons, on = :A => :id)  transform([:C, :D, :salary] => ((c, d, s) -> @. s + c*d) => :happiness)  dropmissing(:happiness)  subset(:happiness => h -> h .> 0)  select(:name, :age, :favorite_food, :happiness)  sort(:happines, rev = true)  end    and this result is    3×7 DataFrame  Row name age favorite_food happiness  String Int64 String? Int64  1 Apu 38 saag paneer 44800  2 Homer 45 pork chops 32000  3 Marge 42 casserole 8200      Split-Apply-Combine  A common situation with data analysis is to have a dataset and you want to compare means or standard deviations within a dataset. What needs to often happen is that you first split a dataset, do some analysis on each group then summarize. This is know as split-apply-combine . We will demonstrate this with an example. Let's return to the iris dataset that we loaded in the previous chapter. Recall that the RDatasets package must be loaded and then load the dataset with    iris = RDatasets.dataset(\"datasets\",\"iris\")    First, we will split the dataset by the Species column using the groupby function in the @chain block as    @chain iris begin  groupby(:Species)  end    and the result shows two DataFrames (actually GroupedDataFrame s), the first and last. At the top of the output, it says GroupedDataFrame with 3 groups based on key: Species Even though we have ``split'' the dataset, it is all stored in a single variable of type GroupedDataFrame . It shows part of the first group and part of the last group. This is mainly because of space for the output.  Next, we may want to compare the variables between these three groups. For example, to compare the mean of the SepalLength variable, we use the combine function like:    @chain iris begin  groupby(:Species)  combine(:SepalLength => mean)  end    and the result is    3×2 DataFrame  Row Species SepalLength_mean  Cat… Float64  1 setosa 5.006  2 versicolor 5.936  3 virginica 6.588    If we want the number of rows in each set:    @chain iris begin  groupby(:Species)  combine(nrow)  end    which shows that there are 50 rows in each subset. Notice that this is different than the previous example (mean of the SepalLength) in that no column is needed and the function nrow is applied to the entire Grouped Data Frame.  We can also use combine to produce many summarizing values. If we want the number of rows, the mean of the SepalLength, the standard deviation of the SepalWidth and the maximum of the PetalWidth, we can do this with one command as in    @chain iris begin  groupby(:Species)  combine(nrow, :SepalLength => mean, :SepalWidth => std, :PetalWidth => maximum)  end    resulting in    3×5 DataFrame,  Row Species nrow SepalLength_mean SepalWidth_std PetalWidth_maximum  Cat… Int64 Float64 Float64 Float64  1 setosa 50 5.006 0.379064 0.6  2 versicolor 50 5.936 0.313798 1.8  3 virginica 50 6.588 0.322497 2.5      Summary of DataFrame Transformations  The examples in this chapter are relatively simple. and show more realistic data sets with a large census dataset and a olympic event dataset respectively, however use all of the techniques listed above.   "
},
{
  "id": "ch-manipulating-data-4-22",
  "level": "2",
  "url": "ch-manipulating-data.html#ch-manipulating-data-4-22",
  "type": "Check Your Understanding",
  "number": "26.1",
  "title": "",
  "body": "Using the iris dataset, find all setosa irises (look at the Species column) with SepalWidth larger than 4. How many are there in the dataset? "
},
{
  "id": "ch-manipulating-data-5-19",
  "level": "2",
  "url": "ch-manipulating-data.html#ch-manipulating-data-5-19",
  "type": "Check Your Understanding",
  "number": "26.2",
  "title": "",
  "body": "Using the iris dataframe produce a new column called area which is the area of a petal using the PetalLength and PetalWidth variables and the area of an ellipse. "
},
{
  "id": "ch-census",
  "level": "1",
  "url": "ch-census.html",
  "type": "Chapter",
  "number": "27",
  "title": "Analyzing Census Data",
  "body": " Analyzing Census Data   This chapter goes through an example of analyzing census data. We load the data then ask a number of questions of the data. It is expected that you have read and before this.    Loading Packages and the Dataset  Before we begin, make sure that you have added and loaded the following packages:   using DataFrames, Chain, Statistics, CSV, StatsPlots   Download the file Gaz\\_ua\\_national.csv and save it somewhere that you can access it from Julia. This file has a lot of census data that we will try to find answers. Information about the data is on the census website   We will start by loading the file with   census_data = CSV.read(\"Gaz_ua_national.csv\",DataFrame)     Answering Census Questions   There are a number of questions that we can answer. We will spend the rest of this chapter answer these questions.     What are the top 10 areas in population?    How many population areas are west of 120 degrees longitude?    Give a histogram plot in terms of population? (What are good bin sizes?)    What is the total population of all areas?    What the top 10 area in housing units?    What is the total number of housing units?    What are the top 10 areas in land size?    What are the top 10 areas in water size?    What are the Massachusetts areas in the data?    What is the average population, median and standard deviation of the areas?       What are the top 10 areas in population?  To solve this, we will start with the data frame and take only necessary columns, sort by the POP10 column and print out the top 10 rows. We will build up these steps within a @chain block:   @chain census_data begin select(:GEOID, :NAME, :POP10) sort(:POP10, rev = true) first(10) end     Find the total population of the areas west of 120 degrees longitude?  The number of degrees longitude is in the column INTPTLONG and is a negative number because it is west of the 0 degree longitude (that's the way it works). West of 120 degrees is less than -120.  We will filter (subset) the data frame using this and then combine to compute the sum.   @chain census_data begin subset(:INTPTLONG => long -> long .< -120) combine(:POP10 => sum) end   The result shows the total population west of 120 degrees is about 22 million.    Give a histogram plot in terms of population?  To produce a histogram of the population, we will use the histogram function of the package StatsPlots . Check out the documentation . If we do:    @df census_data histogram(:POP10)    then we get the following plot:     (for accessibility)    The trouble with this is that there are many many census areas with very little population. We can fix this with a log scale. If you enter   @df census_data histogram(:POP10, xscale = :log10, xlims = (10^3,10^6))   then the result is:     (for accessibility)      What is the total population of all areas?  This is basically asking the question of the total population in the United States. We can do this with    sum(census_data.POP10)    which returns 252746527 , which is just over 312 million.    What the top 10 area in housing density?  We are interested in finding the highest housing density, that is the number of people per housing units. We will create a new column to do this:   @chain census_data begin transform( [:POP10, :HU10] => ((p,h)-> p.\/h) => :Housing_Density) select(:NAME, :Housing_Density) sort(:Housing_Density, rev=true) first(10) end   the results of this is    What is the total number of housing units?  This is simply a summary statistic on the HU10 variable:   @chain census_data begin combine(:HU10 => sum) end   or more simply sum(census_data.HU10)   which has the result 105549535 .    What are the top 10 areas in land size?  This is a sorting of the dataset in terms of the ALAND variable:   @chain census_data begin select(:NAME, :ALAND) sort(:ALAND, rev=true) first(10) end     What are the top 10 areas in water size?  This is similar to the one above but use the AWATER variable:   @chain census_data begin select(:NAME, :AWATER) sort(:AWATER, rev=true) first(10) end     What are the Massachusetts areas in the data?  First, we'll need to filter (subset) the dataset to only include those with MA in the name. We can use the occursin function to do this:   @chain census_data begin subset(:NAME => (n -> occursin.(\"MA\",n))) combine(:POP10 => sum) end     What is the average population, median and standard deviation of the each of the areas?  This is similar to above, except we change the functions on the combine:   @chain census_data begin subset(:NAME => (n -> occursin.(\"MA\",n))) combine(:POP10 => mean, :POP10 => median, :POP10 => std) end   which results in    1×3 DataFrame  Row POP10_mean POP10_median POP10_std  Float64 Float64 Float64  1 3.69408e5 20717.5 9.44398e5       "
},
{
  "id": "fig-census-hist01",
  "level": "2",
  "url": "ch-census.html#fig-census-hist01",
  "type": "Figure",
  "number": "27.1",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-census-hist02",
  "level": "2",
  "url": "ch-census.html#fig-census-hist02",
  "type": "Figure",
  "number": "27.2",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-olympics",
  "level": "1",
  "url": "ch-olympics.html",
  "type": "Chapter",
  "number": "28",
  "title": "Olympic Medals",
  "body": " Olympic Medals   The data sets for this chapter contain all athletes that have participated in the Olympic games between 1896 and 2016. We use the dataset to answer a number of questions.   What is the total number of medals given in all Olympics in the dataset?    Collectively taking each summer Olympics, give the top 10 athletes by number of medals.    Which athlete had the most Olympic gold medals in the Summer 2000 games? How many medals?    List the top 10 countries by medals in only winter Olympics.    Plot the average weight for male and female in each year over the entire span of the Olympic games.    Plot the number of medals that the U.S. collected over each olympic year.    What age the most common athlete? What we are looking for is the mode of the age of all athletes.    Consider the winter games between 1950 and 1970. Collectively of these games, what are the top 5 sports by total medals given?        Downloading the Data and Loading the Packages  The dataset will be on a site called kaggle.com . More specifically, go to this site and click the download button on the upper right. The download is a zip file and within that there are two files. The one we are interested in is called athlete_events.csv .  For this chapter, we need the following packages.    using DataFrames, Chain, Statistics, CSV, StatsPlots      Loading the file  The file that we are interested in is a CSV , so will load it with the following:    olympics = CSV.read(\"olympic-athletes.csv\", DataFrame, missingstring = \"NA\")    where the option missingstring = \"NA\" is used to replace any NA with the missing value explained in . The first few rows of this DataFrame is:    271116×15 DataFrame 271106 rows omitted  Row ID Name Sex Age Height Weight Team NOC Games Year Season City Sport Event Medal  Int64 String String1 String3 String3 String31 String String3 String15 Int64 String7 String31 String31 String String7  1 1 A Dijiang M 24 180 80 China CHN 1992 Summer 1992 Summer Barcelona Basketball Basketball Men's Basketball missing  2 2 A Lamusi M 23 170 60 China CHN 2012 Summer 2012 Summer London Judo Judo Men's Extra-Lightweight missing  3 3 Gunnar Nielsen Aaby M 24 missing missing Denmark DEN 1920 Summer 1920 Summer Antwerpen Football Football Men's Football missing  4 4 Edgar Lindenau Aabye M 34 missing missing Denmark\/Sweden DEN 1900 Summer 1900 Summer Paris Tug-Of-War Tug-Of-War Men's Tug-Of-War Gold     Each row of the dataset is each event that has occurred in each Olympics for each athlete that has participated. This will be called an athlete-event in this chapter. Also, note that there are 271,116 rows in this DataFrame. The columns of the dataset are     ID  a number corresponding to each athlete    Name  the name of the athlete    Sex  the sex (either Male or Female) of the athlete    Height  the height of the athlete in cm    Weight  the weight of the athlete in kg    Team  the country the athlete participated for    NOC  the country code of the athlete (helpful for condensed printing)    Games  The year and season (summer or winter) of the Olympic games for the given event.    Year  The Year of the Olympic games for the event.    Season  The season of the Olympic games for the event.    City  The host city of the Olympic games    Sport  The sport (category) of the event    Event  The specific event the athlete competed in.    Medal  The medal type (Gold, Silver, Bronze) or NA if no medal was earned.       Answering the Questions   What is the total number of medals given in all Olympics in the dataset?  Since each row is an athlete-event, we drop all of the columns in the Medal column and then count all of the rows or   @chain olympics begin dropmissing(:Medal) nrow end   and the result is 39783     Give the top 10 athletes by number of medals in the Summer Olympics  This is a classic split-apply-combine example as shown in . For this, we first filter by only Summer games and then drop all rows without a medal. Since we are asking for the individual medals, we will next group by the athlete ID . This is the first 3 lines within the @chain block and is a good idea to run these lines.  Next, we want to combine the groups. In short, we want the total number of medals (this is simply found by calling nrow ) and the name, which is a little trickier. When using combine on a column in a grouped DataFrame, each of the functions that are called take in an array (or an iterator). That is, when extracting Name from the DataFrame, it returns an array of names. The line    combine(:Name => (names-> first(names)) => :Name, nrow)    will extract the first element of the names. Also, we wish to rename to Name .   @chain olympics begin subset(:Season => s-> s .== \"Summer\") subset(:Medal => m -> m .!= \"NA\") groupby(:ID) combine(:Name => (names-> first(names)) => :Name, nrow) sort(:nrow, rev = true) end     Which athlete had the most Olympic gold medals in the Summer 2000 games? How many medals?  First, we would like to take the data set and filter (subset) to the Summer 2000 games and only gold medals. However, if we try to subset on medals with missing values.   @chain olympics begin dropmissing(:Medal) subset([:Games, :Medal] => (g, m) -> g .== \"2000 Summer\" .&& m .== \"Gold\") groupby(:ID) combine(:Name => (names -> first(names)) => :Name, nrow) sort(:nrow, rev = true) first(10) end   The resulting DataFrame is    5×3 DataFrame  Row ID Name_function nrow  Int64 String Int64  1 85286 Aleksey Yuryevich Nemov 6  2 120087 Ian James Thorpe 5  3 121258 Dara Grace Torres (-Hoffman, -Minas) 5  4 25975 Inge de Bruijn 4  5 45039 Gary Wayne Hall, Jr. 4    This shows that Aleksey Nemov had 6 medals in the Summer 2000 games.    List the top 10 countries by medals in only winter Olympics.  To start off, we again filter only by those with medals and in this case the Season column has the value Winter . Then we group by the \\texttt{Team} column, which represents the Country. We then define Total_Medals to be the number within each group. Finally, we order (descending) by Total_Medals and print the first 10 rows.   @chain olympics begin subset(:Season => s-> s .== \"Winter\") subset(:Medal => m -> m .!= \"NA\") groupby(:NOC) combine(nrow) sort(:nrow, rev = true) end     Plot the average weight for male and female in each year over the entire span of the Olympic games.     @chain olympics begin transform(:Weight => ByRow(w -> w == \"NA\" ? missing : parse(Float64, w)) => :Weight_float) dropmissing(:Weight_float) groupby([:Year, :Sex]) combine(:Weight_float => mean) unstack(:Sex, :Weight_float_mean) plot(_.Year, [_.M, _.F], label = [\"M\" \"F\"], legend = :right) end     Plot the number of medals that the U.S. collected over each olympic year.  First, we filter by the country, but this time use the NOC column which is the country code. We also filter out all in the Medal column with value NA . Since we want the number of medals by year, we group by the Year column and define the num_medals to be the length of the number elements in each group. Finally, we can just send (pipe) the results to the @df macros which plots the dataframe.   @chain olympics begin dropmissing(:Medal) subset(:NOC => name -> name .== \"USA\") groupby(:Year) combine(nrow) bar(_.Year, _.nrow) end   It is interesting to note that this database lists some medals from 1906\\footnote{Suprising to the author, there was an event called the \\href{https:\/\/en.wikipedia.org\/wiki\/1906_Intercalated_Games}{1906 Intercalated Games} in Athens, Greece. This is listed in this database.} Also, it hard not to notice that the 1904 games sent a lot medals to the U.S.\\footnote{The 1904 Olympic games were held in St. Louis, Missouri, which was quite difficult to get to from Europe and other places around the world. This resulted in a large number of American athletes winning medals.    What age the most common athlete? What we are looking for is the mode of the age of all athletes.     @chain olympics begin combine(:Age => mode) end     What are the top 5 sports (not events) by total medals given for winter olympics between 1950 and 1970?       Exercise   Use the dataset for this chapter to answer the following questions:   Who has the most Winter Olympic Silver medals?   Create a bar plot of percentage male and female participation in the Olympics per year? Start with 1920, the first year that women started competing and use the groupedbar function from the StatsPlots package.   Note that one of the question asked was about the number of medals the U.S. has won in each Olympics and the 1904 games were a bonanza for the United States. How many countries participated in these Games? Determine the number of athletes from each country for this event.    "
},
{
  "id": "ch-olympics-6-2",
  "level": "2",
  "url": "ch-olympics.html#ch-olympics-6-2",
  "type": "Check Your Understanding",
  "number": "28.1",
  "title": "",
  "body": " Use the dataset for this chapter to answer the following questions:   Who has the most Winter Olympic Silver medals?   Create a bar plot of percentage male and female participation in the Olympics per year? Start with 1920, the first year that women started competing and use the groupedbar function from the StatsPlots package.   Note that one of the question asked was about the number of medals the U.S. has won in each Olympics and the 1904 games were a bonanza for the United States. How many countries participated in these Games? Determine the number of athletes from each country for this event.  "
},
{
  "id": "ch-lin-alg-intro",
  "level": "1",
  "url": "ch-lin-alg-intro.html",
  "type": "Chapter",
  "number": "29",
  "title": "Introduction to Linear Algebra",
  "body": " Introduction to Linear Algebra   Linear Algebra is probably the most important mathematical field for Scientific Computation And if you ask someone in the field, they will say most important field PERIOD! . This chapter covers the basics of Linear Algebra in Julia and how it can be used to solve scientific problems.  Also, a lot of these functions described here are standard functions (that is, part of the Base package which is automatically loaded), however many are also part of the LinearAlgebra package, which should be downloaded, but you will need to perform using LinearAlgebra . It is pointed out when you need this package.    Vectors and Matrices   Vector and matrices are the building blocks of linear algebra. In short a Vector is simply a 1D array and in julia the type Vector<T> is shorthand for Array{T,1} . We can make a vector just like we did with an array. For example, x = [1,2,3] makes an array of length three and the output:    3-element Vector{Int64}:  1  2  3    shows that it is a 1D integer array of length 3.  Similarly, there is a Matrix type which is an alias for a 2D array. If    A = [i+j for i=1:3,j=1:3]    then we get the results    3×3 Matrix{Int64}:  2 3 4  3 4 5  4 5 6      Addition and Subtraction of Vectors and Matrices  All of the construction methods for arrays of both 1D and 2D as seen in Chapter \\ref{ch:arrays} can be used. If we have    B = [ 3 2 1; 0 2 0; 1 2 3]  then A+B returns    3×3 Matrix{Int64}:  5 5 5  3 6 5  5 7 9    and A-B returns    3×3 Matrix{Int64}:  -1 1 3  3 2 5  3 3 3    Similarly if x=collect(1:5) and y=collect(1:2:9) then x+y returns    5-element Vector{Int64}:  2  5  8  11  14    and x-y returns    5-element Vector{Int64}:  0  -1  -2  -3  -4      scalar multiplication  Scalar multiplication of vectors and matrix work as expected using the * operator, which is implied if multiplying on the left by a number. Using A and x above, 3x returns    5-element Vector{Int64}:  3  6  9  12  15    and -4A returns    3×3 Matrix{Int64}:  -8 -12 -16  -12 -16 -20  -16 -20 -24      Matrix-vector products  Let x=[1, 4, 5] , and A and B as defined above. The vector-matrix product A*x returns    3-element Vector{Int64}:  34  44  54    and the matrix-matrix products A*B returns    3×3 Matrix{Int64}:  10 18 14  14 24 18  18 30 22    Note that if either scalar or matrix multiplication involves variables, then you will need to explicitly put in a * , since Julia can have variables of any length, if for example, you entered AB expecting the product, you will get UndefVarError: `AB` not defined in `Main` .    Matrix Transpose  Recall that the tranpose of a matrix is a matrix where the th row and column of A becomes the th column and th row of the transpose. In julia, the transpose function performs like. For example,    transpose(B)    returns    3×3 transpose(::Matrix{Int64}) with eltype Int64:  3 0 1  2 2 2  1 0 3    Notice that the type of a transpose is not a simple Matrix . It has transpose in the type. This is mainly for efficiency. For large matrices (say ones that take up a Gb of memory or more), simply a copy of a matrix is more efficient than doing the transpose operation. Julia will then known if it is a transpose then perform the correct operation using the transpose when needed.    Trace and Determinant of a Matrix  The trace of a matrix is the sum of the elements along the diagonal. In julia, you can use the tr function in the LinearAlgebra package. The function  tr(A)  returns 12   Also, the determinant of a matrix can be easily found in julia with the det function in the LinearAlgebra package.    det(A)    returns    0.0      Identity Matrix  Recall that the identity matrix, , is the matrix that satisfies for any matrix . It is matrix with ones along the diagonal and zeros elsewhere. If needed in julia, you can use   Matrix(I,3,3)   which returns    3×3 Matrix{Bool}:  1 0 0  0 1 0  0 0 1    Note: the I is part of the LinearAlgebra package and can be used without the size often. For example, I*B returns    3×3 Matrix{Int64}:  3 2 1  0 2 0  1 2 3    which is just B , but note that we didn't say that I was a 3×3 matrix.     Matrix Inverse  If you have a matrix , then if it exists, the inverse of , denoted satisfies and .  In julia, we can find the inverse with the inv function. For example, inv(B) returns    3×3 Matrix{Float64}:  0.375 -0.25 -0.125  0.0 0.5 -0.0  -0.125 -0.25 0.375    If we try to find the inverse of , above, inv(A) we get SingularException(3) which occurs because the matrix is singular, that is, it doesn't have a matrix inverse.    Solving Linear Systems  One of the most important aspects of linear algebra is that of solving a linear system. In general, this is solving the linear system:     for known matrix and vector . If    A = [0 1 1; 1 2 1; 1 1 -1]  b = [1,2,3]    then the solution can be found with    x = A \\ b    which returns    3-element Vector{Float64}:  -2.0  3.0  -2.0    which is the same as , but is more efficient.    Eigenvalues and Eigenvectors  Recall that a scalar and corresponding vector form an eigenvalue-eigenvector pair if     To find the eigenvalues of a matrix in julia,    eigvals(A)    which returns    3-element Vector{Float64}:  -1.6554423815498303  -0.21075588095919165  2.8661982625090223    The eigenvectors can be found with    eigvecs(A)    which returns    3×3 Matrix{Float64}:  -0.462272 0.785797 -0.410888  -0.114102 -0.51223 -0.851235  0.879367 0.346619 -0.326451    where the eigenvectors are the columns of the resulting matrix. The eigenvectors are in the same order as the eigenvalues, which is important in that they form pairs.  To get a particular eigenvector, you can use the standard array notation to pull out a particular column. For example, eigvecs(A)[:,2] will return the 2nd eigenvector.    Special Matrices   Special matrices arise throughout Linear Algebra.    Diagonal Matrices  For example, the identity matrix, can be thought of as a diagonal matrix and in julia there is a matrix type called Diagonal . For example,    D=Diagonal([1,2,3,4])    returns    4×4 Diagonal{Int64, Vector{Int64}}:  1 ⋅ ⋅ ⋅  ⋅ 2 ⋅ ⋅  ⋅ ⋅ 3 ⋅  ⋅ ⋅ ⋅ 4    and you'll notice that it doesn't just create a matrix where there are zeros on the off-diagonal. It will print out like a regular matrix, but it will only store the diagonal elements. This is precisely for saving on storage. However, you can still do operations with this matrix. For example, finding the eigenvalues of this with   eigvals(D)   and this returns    4-element Vector{Int64}:  1  2  3  4    which is what we expect as the eigenvalues of a diagonal matrix are the diagonal elements.    Tridiagonal Matrices  Another matrix that shows up often are tridiagonal matrices. For example, the following arises from discretizes a differential equation:  T = Tridiagonal([1 for i=1:9],[-2 for i=1:10],[1 for i=1:9])      10×10 Tridiagonal{Int64, Vector{Int64}}:  -2 1 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  1 -2 1 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  ⋅ 1 -2 1 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  ⋅ ⋅ 1 -2 1 ⋅ ⋅ ⋅ ⋅ ⋅  ⋅ ⋅ ⋅ 1 -2 1 ⋅ ⋅ ⋅ ⋅  ⋅ ⋅ ⋅ ⋅ 1 -2 1 ⋅ ⋅ ⋅  ⋅ ⋅ ⋅ ⋅ ⋅ 1 -2 1 ⋅ ⋅  ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ 1 -2 1 ⋅  ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ 1 -2 1  ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ 1 -2       Abstract Matrices   As with number types that we discussed in , matrices in julia are subtypes of the abstract type AbstractMatrix . There are a few functions that are common to all matrices and understanding this is helpful in working with different types of special matrices.  In short, an AbstractMatrix is the supertype of all matrices in julia. For example the multiplication of two matrices with * . If    T = Tridiagonal([-1 for i=1:4],[2 for j=1:5],[-1 for j=1:4])  D = Diagonal([1,2,3,4,5])    then D*T returns    5×5 Tridiagonal{Int64, Vector{Int64}}:  2 -2 ⋅ ⋅ ⋅  -1 4 -3 ⋅ ⋅  ⋅ -2 6 -4 ⋅  ⋅ ⋅ -3 8 -5  ⋅ ⋅ ⋅ -4 10    and notice that the type is a Tridiagonal . Depending on the types of the two input matrices, the multiplication will result in the appropriate output type.    Solving with Matrices\/Division  Another common    "
},
{
  "id": "ch-adv-lin-alg",
  "level": "1",
  "url": "ch-adv-lin-alg.html",
  "type": "Chapter",
  "number": "30",
  "title": "Advanced Topics in Linear Algebra",
  "body": " Advanced Topics in Linear Algebra   Sparse Matrices  We saw in the previous chapter, some of the matrices contained many zeros. As matrices get larger, the structure of them (like banded matrices), results in a matrix that is almost all zeros.  Consider the matrix:    A = [  0 1 0 0 0 0 0 0 0 0 0 0 0 ;  0 0 0 0 0 2 0 0 0 0 0 0 0 ;  0 0 -1 0 0 0 0 0 0 0 0 0 0 ;  0 0 0 0 0 0 0 0 0 1 0 0 0 ;  0 0 0 0 -2 0 0 0 0 0 0 0 0 ;  1 0 0 0 0 0 0 0 0 0 0 0 0 ;  0 0 0 0 0 0 0 0 0 0 0 0 -1 ;  0 0 0 0 0 0 2 0 0 0 0 0 0 ;  0 0 0 -1 0 0 0 0 0 0 0 0 0 ;  0 0 0 0 0 -2 0 0 0 0 0 0 0 ;  0 0 0 0 0 0 0 0 0 0 0 1 0 ;  0 0 0 0 0 0 0 0 0 0 2 0 0 ;  0 0 0 0 0 0 0 0 1 0 0 0 0 ]    and there is no apparent structure to the nonzero elements. Although this isn't that large, imagine a 1000 by 1000 version of this array with 1% of the elements nonzero. If we used a regular matrix, then such a matrix would take bytes, which is quite large. We can see this with sizeof(A) which returns 1352 , which is .  Instead, we will use a SparseMatrixCSC in the SparseArrays package to store these. There are a couple of ways to create the matrix. If it is stored as a regular (dense) matrix, then it can be converted easily.    using SparseArrays  SA = SparseMatrixCSC(A)    which returns    13×13 SparseMatrixCSC{Int64, Int64} with 13 stored entries:  ⋅ 1 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  ⋅ ⋅ ⋅ ⋅ ⋅ 2 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  ⋅ ⋅ -1 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ 1 ⋅ ⋅ ⋅  ⋅ ⋅ ⋅ ⋅ -2 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  1 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ -1  ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ 2 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  ⋅ ⋅ ⋅ -1 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  ⋅ ⋅ ⋅ ⋅ ⋅ -2 ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅  ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ 1 ⋅  ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ 2 ⋅ ⋅  ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ ⋅ 1 ⋅ ⋅ ⋅ ⋅    Notice that it only stores the nonzero elements. To determine that the storage amount is indeed small, entering sizeof(SA) which returns 40 .  Let's create a sparse vector with the following command: \\begin{jlblock}[la2] R = sparsevec([1,5,7,12,13],[-1,5,10,3,0]) \\end{jlblock} which returns \\jlc[la2]{display(R)}\\printpythontex[verbatim] and notice that lists the elements of the vector that are nonzero (except that we included   "
},
{
  "id": "ch-num-int",
  "level": "1",
  "url": "ch-num-int.html",
  "type": "Chapter",
  "number": "31",
  "title": "Numerical Integration",
  "body": " Numerical Integration   Numerical integration is a very important component of scientific computation. In tradition calculus classes, the integrals presented were ones that had antidervatives that could be found relatively easily. However, this is generally not true. For example, if trying to determine     the function does not have an antidervative in terms of standard functions. This however it a very important antidervative in that it is related to the normal probability distribution. Because of its importance, we define     as the error function it is important to calculate values for it for any value of .    Trapezoid Rule  introduction to the trapezoid rule  Instead of approximating the area with rectangles, we can use trapezoids to do this. A plot of the approximate integral of on the interval is given by          where 4 trapezoids have been used. The area of the a trapezoid like:          is     In the trapezoids in the function plot above, the trapezoid are oriented sideways to this one, so the value of is the horizontal distance or 0.5 for each one and the and are the function values, so the area of the four trapezoids above are:     The basic part of the trapezoid method is to use the area of a trapezoid on an interval with width . The area of one of the trapezoids is     and then a full approximation will be the sum of these:     Let's take a look at doing this in julia. To calculate the value we need a few things: 1) a function, 2) the interval we're doing the approximation on and 3) the number of trapezoids or subintervals. We presented the following in as   function trapRule(f::Function, a::Real, b::Real; num=10) local h = (b-a)\/num 0.5*h*sum(map(f, a:dx:b-dx)+map(f, a+dx:dx:b)) end      The parameter is .    Line can be written as the map of two arrays. And then summed.     This is short and (maybe) sweet, but note that there are two separate arrays created. We have learned throughout this text, that the creation of arrays is often the most expensive part of a calculation. So instead, we will do the following:   function trapRule(f::Function, a::Real, b::Real; num = 10) num > 0 || throw(ArgumentError(\"The number of trapezoids, num, must positive.\")) a < b || throw(ArgumentError(\"The left endpoint must be less than the right endpoint.\")) local h = (b-a)\/num (h\/2)*(f(a)+f(b)+2*sum(f,LinRange(a+h,b-h,num-1))) end   Although this looks to be nearly the same, we haven't created arrays. The LinRange function creates a range, but julia is savvy enough to not create the array to sum over it. See the exercise below. Let's first redo the example above:    trapRule(x -> exp(-x^2), 0, 2; num=4)    which returns 0.8806186341245393    Find using the trapezoid method for and points.   Use the BenchmarkTools and the @btime macro to compare the time of the trapezoid rule using the two functions shown here. Try integrating on for subintervals.     Simpson's Rule   The trapezoid rule uses straight lines to approximate the function and then integrates the line (or finds the area of the trapezoid). To find a better approximation if we use a quadratic function (parabola) to estimate the function. If we do this, then integrate the resulting parabola, this is called Simpson's Rule. There are numerous places to find the derivation of this, but the result is     where , and it is important that is an even number. Similar to the trapezoid rule, we can write Simpson's rule in julia as   function simpsonsRule(f::Function, a::Real, b::Real, n::Integer) n > 0 || throw(ArgumentError(\"The number of subintervals, n, must be positive.\")) n % 2 == 0 || throw(ArgumentError(\"The number of subintervals, n, must be even.\")) a < b || throw(ArgumentError(\"The left endpoint must be less than the right endpoint.\")) local h = (b-a)\/n xpts = LinRange(a,b,n+1) (h\/3)*(f(a)+f(b) + 4*sum(f,xpts[2:2:end-1]) + 2*sum(f,xpts[3:2:end-2])) end   Applying Simpson's Rule to as    simpsonsRule(x->x^2,0,3,10)    results in 9.0   It's interesting to note that this reports the exact value. In fact, Simpson's rule will numerically integrate any cubic (and lines and quadratics) exactly. If we return to trying to find and use Simpson's Rule, then    simpsonsRule(x -> exp(-x^2), 0, 2, 10)    returns 0.882074876854494 .  which is within 5 digits of the true answer.    Plotting the Error Function  We can use numerical integration to evaluate the error function at any value, so let's go ahead and plot it. First, let's make a function that defines the error function.   function erf(x::Real) local area = simpsonsRule(t -> exp(-t^2),0,abs(x),100) x > 0 ? area : -1*area end   where we have used the symmetry of the error function to evaluate it if x is positive or negative. If we don't check for this, we will get an error because simpsonsRule has a check that the interval needs to be put in as . Now, we can plot it with:    plot(x -> erf(x), -3, 3, label=false, title=\"Plot of the error function\")    which results in     (for accessibility)       Using the NumericalIntegration package  This package does some basic integration using both Trapezoid and Simpson's rule discussed above.   using NumericalIntegration x = LinRange(0,2,101) y = map(x -> exp(-x^2),x) ## compute an array of y based on each x v = integrate(x,y)   and the result is 0.8820789488400429 .   "
},
{
  "id": "fig-trap-rule",
  "level": "2",
  "url": "ch-num-int.html#fig-trap-rule",
  "type": "Figure",
  "number": "31.1",
  "title": "",
  "body": "       "
},
{
  "id": "fig-trap-rule2",
  "level": "2",
  "url": "ch-num-int.html#fig-trap-rule2",
  "type": "Figure",
  "number": "31.2",
  "title": "",
  "body": "       "
},
{
  "id": "ch-num-int-3-23",
  "level": "2",
  "url": "ch-num-int.html#ch-num-int-3-23",
  "type": "Check Your Understanding",
  "number": "31.3",
  "title": "",
  "body": " Find using the trapezoid method for and points.   Use the BenchmarkTools and the @btime macro to compare the time of the trapezoid rule using the two functions shown here. Try integrating on for subintervals.  "
},
{
  "id": "fig-erf",
  "level": "2",
  "url": "ch-num-int.html#fig-erf",
  "type": "Figure",
  "number": "31.4",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-diffeq",
  "level": "1",
  "url": "ch-diffeq.html",
  "type": "Chapter",
  "number": "32",
  "title": "Differential Equations",
  "body": " Differential Equations   Another extremely important topic in Scientific Computation is that of differential equations. These arise obviously in mathematics, but also in most other scientific fields including biology, chemistry, engineering, and economics. Also, it is rare that a differential equation has a nice closed form solution, so often numerical methods must be used to get a solution.  We will discuss two often-used methods for solving differential equations, Euler's method and Runge-Kutta methods and then delve into a very nice robust julia package.  A differential equation is simply an equation that has derivatively in it. For example     It is important to note that the order of a differential equation is the degree of the highest derivative, so in the example above, it is two. The following procedure can covert non order-1 differential equation to one that is a first-order system.  Let , then . Lastly and using the differential equation , this can be written:     or in matrix form:     and as long as , the highest-order term, can be isolated algebraically, one can write the differential equation as       Euler's Method   We start with one of the simplest methods to solve a differential equation. If we have are solving       with the understanding that we will solve this at a discrete set of points, so we let and , where is a small time step. We can then replace with the approximation:     and the differential equation in is     and solving for , we get:     and this iterative (or difference equation) is known as Euler's Method .    Implementing Euler's method in Julia  Let's take a look at Euler's method in Julia. Of course, we'll write a function to evaluate this and there are a few things that we need for the function:     The function , which is the right-hand side. Note that it takes in two variables.    An initial point, . There will be two real arguments for this.    A step size .    Either a final value or a number of steps to run Euler's method. We'll use the number of steps, a positive integer.     We'll return two arrays for the t and y values.  We'll also implement this as a for loop. Although there are some   function euler(f::Function, t0:: Real, y0::Real, dt::Real, num_steps::Integer) num_steps > 0 || throw(ArgumentError(\"The number of steps must be positive.\")) dt > 0 || throw(ArgumentError(\"The step size dt must be positive.\")) t = LinRange(t0,t0+num_steps*dt,num_steps+1) y = zeros(Float64,num_steps+1) y[1] = y0 for i=1:num_steps y[i+1] = y[i] + dt*f(t[i],y[i]) end (t,y) end    We'll solve , for dt=0.1 and steps.  t,y = euler( (t,y) -> y, 0, 1, 0.1, 10)    and this returns    ([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], [1.0, 1.1, 1.2100000000000002, 1.3310000000000002, 1.4641000000000002, 1.61051, 1.7715610000000002, 1.9487171, 2.1435888100000002, 2.357947691, 2.5937424601])    which is a tuple of two arrays. This results the and values based on Euler's method. However, perhaps it's more interesting to see a plot. Also, note that the analytic solution to this is , so the plot of the approximate solution using Euler's method as well as the analytic solution is    plot(t,y,label=\"Euler's solution\")  plot!(t->exp(t),0,1,label=\"Analytic solution\")       (for accessibility)        Runge Kutta methods   There is a family of other methods called the Runge Kutta methods that are relatively simple with a high order of accuracy. One version that was often a standard version is what is called the 4th-order Runge-Kutta or RK4 method is     where       RK4 in julia  The following is the rk4 method in julia. It is very similar to euler's method...   function rk4(f::Function, t0:: Real, y0::Real, dt::Real, num_steps::Integer) num_steps > 0 || throw(ArgumentError(\"The number of steps must be positive.\")) dt > 0 || throw(ArgumentError(\"The step size dt must be positive.\")) t=LinRange(t0,t0+num_steps*dt,num_steps+1) y=zeros(Float64,num_steps+1) y[1] = y0 for i=1:num_steps k1 = f(t[i],y[i]) k2 = f(t[i]+dt\/2,y[i]+dt\/2*k1) k3 = f(t[i]+dt\/2,y[i]+dt\/2*k2) k4 = f(t[i]+dt,y[i]+dt*k3) y[i+1] = y[i] + dt\/6*(k1+2k2+2k3+k4) end (t,y) end   and we can use this to solve , by    t,y = rk4((t,y) -> y, 0, 1, 0.1, 10)    and the results are .     Using the DifferentialEquations package   There is a very mature and robust package for solving differential equations aptly called DifferentialEquations . We will show a few examples to get a feeling for how to use the package, but as you can tell from the documentation , that there are a lot of possibilities with the package so we'll show a couple of examples.  In short, you'll need to include the equation, an initial condition and a range of values on which you want it solved. Don't forget to add the package and evaluate    using DifferentialEquations      A Simple Example  We will solve     the same equation as above using the DifferentialEquations package.  First, the equation needs to fit in the form:     where is a function of , the dependent variable, the parameter in the problem (if any) and , the independent variable. We will also defined the initial condition and the range of values for which to solve:    f(u,p,t) = u  u0 = 1.0  tspan = (0.0,1.0)    And then we create a differential equation problem with:  prob = ODEProblem(f,u0,tspan)    and note that this returns    ODEProblem with uType Float64 and tType Float64. In-place: false  timespan: (0.0, 1.0)  u0: 1.0    This gives information about the datatypes of the function and initial condition because some solvers will use this information differently. to solve this problem,   sol = solve(prob)   which returns \\jlc[diffeq]{display(sol)} \\printpythontex[verbatim]  Note that the solution appears to be an array of time (that isn't equally-spaced) and function values at those values. If you want to access one of them, you can do:   sol[3]   which returns \\jlc[diffeq]{print(sol[3])}\\printpythontex[verb], the third element in the array. However, this structure is much more than just an array. If you want the function value at 0.75, for example, you can access it like a function evaluation:   sol(0.75)   which returns \\jlc[diffeq]{print(sol(0.75))} \\printpythontex[verb]~ and this is interpolated from the generated points. The result guarantees accuracy to within a default tolerance of 1e-3 or you can set a different tolerance with the keyword reltol such as reltol=1e-6 .  So for example, you can generate an array of tuples with   [(t,sol(t)) for t=0:0.1:1]   which returns \\jlc[diffeq]{display([(t,sol(t)) for t=0:0.1:1])}\\printpythontex[verbatim]  One can also generate a plot of the solution with plot(sol)   or if you want to plot the numerical solution with the analytic solution , then   plot(sol,label=\"numerical\",legend=:topleft,lw=3) plot!(0:0.01:1,map(exp,0:0.01:1),label=\"analytic\",lw=3,ls=:dash)   which shows that they appear to the resolution of the plot that the two solutions are identical, however if we plot the error associated with the numerical method by   plot(0:0.01:1,map(t->sol(t)-exp(t),0:0.01:1))   this shows that error is within .    Example of a system of differential equations  Let's solve     which is an example of a harmonic oscillator. We first need to put this in a system form by letting and . Then from the differential equation or . We can then write this as     We will write this in julia using   function F(du,u,p,t) du[1] = u[2] du[2] = - u[1] end   and then create the differential problem with   prob2 = ODEProblem(F,[1;0],(0,6pi))   where [1;0] is the initial condition which would be and the solution is   sol2 = solve(prob2)   If you just plot the results:   plot(sol2)   you'll see the two elements of the vector plotted as functions of or:  If instead, you want the results plotted like a parametric equation, then we use the vars keyword and the (1,2) refers to the two elements of the solution if you use 0 for vars, that represents the independent variable--generally .   plot(sol2,vars=(1,2),aspect_ratio=:equal)     The Lorenz System  The Lorenz system is relatively famous system of differential equations for many reasons. It is a system of ODEs, it is nonlinear and for many parameters the solution exhibits sensitivity on initial conditions, an important property for differential equation that exhibit chaotic behavior. The Lorenz system is     and we will look for solution with and so we define   function lorenz!(du,u,p,t) du[1] = 10.0*(u[2]-u[1]) du[2] = u[1]*(28.0-u[3]) - u[2] du[3] = u[1]*u[2] - (8\/3)*u[3] end   and if the following timespan and initial conditions are used to solve the differential equation as in:   u0 = [1.0;0.0;0.0] tspan = (0.0,100.0) prob3 = ODEProblem(lorenz!,u0,tspan) sol3 = solve(prob3)   then the standard plot of the solution is   plot(sol3)   which shows each of the variables as a plot with respect to . Instead, the classic plot of this solution is as a 3D parametric plot, which you can see with:   plot(sol3,vars=(1,2,3))   and this results in    Other Aspects of the DifferentialEquations  If you take a look at the the documentation of the package , we have only touched the surface of this package and it can do a lot with many different differential equations including initial value problems (that all three examples fit into), boundary value problems, stiff equations (aka they are hard to solve numerically) and stocastic differential equations.  Also, the actual solvers are not discussed here, however if you want to know the details, the documentation explains them. I have found that the default solvers are generally good enough and unless there is an issue, probably work for most problems.    "
},
{
  "id": "ch-diffeq-2-3",
  "level": "2",
  "url": "ch-diffeq.html#ch-diffeq-2-3",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "differential equation "
},
{
  "id": "ch-diffeq-2-5",
  "level": "2",
  "url": "ch-diffeq.html#ch-diffeq-2-5",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "order "
},
{
  "id": "ch-diffeq-3-2-10",
  "level": "2",
  "url": "ch-diffeq.html#ch-diffeq-3-2-10",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Euler's Method "
},
{
  "id": "ch-diffeq-3-3-7",
  "level": "2",
  "url": "ch-diffeq.html#ch-diffeq-3-3-7",
  "type": "Example",
  "number": "32.1",
  "title": "",
  "body": " We'll solve , for dt=0.1 and steps.  t,y = euler( (t,y) -> y, 0, 1, 0.1, 10)    and this returns    ([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], [1.0, 1.1, 1.2100000000000002, 1.3310000000000002, 1.4641000000000002, 1.61051, 1.7715610000000002, 1.9487171, 2.1435888100000002, 2.357947691, 2.5937424601])    which is a tuple of two arrays. This results the and values based on Euler's method. However, perhaps it's more interesting to see a plot. Also, note that the analytic solution to this is , so the plot of the approximate solution using Euler's method as well as the analytic solution is    plot(t,y,label=\"Euler's solution\")  plot!(t->exp(t),0,1,label=\"Analytic solution\")       (for accessibility)    "
},
{
  "id": "ch-optimization",
  "level": "1",
  "url": "ch-optimization.html",
  "type": "Chapter",
  "number": "33",
  "title": "Optimization",
  "body": " Optimization   Optimization is an extremely useful subject in Scientific Computation and is often used in other fields. In short, optimization is the selection of some parameters in order to minimization or maximize some function. A simple example is if we have a function like which has the plot:     (for accessibility)    and we are trying to find the minimum of the function, which appears to be an from the plot.  Recall the following definitions of optimal points:    Consider a function that is continuous on some open interval containing .     a local minimum is a number , such that for all in the interval for some small .    a local maximum is a number , such that for all in the interval for some small .       We can extend this to functions of more that one variable. The following is the definition of optimal points of functions of two variables and further can be found in [REF??]    Consider a function that is continuous on some open ball of radius containing the point , denoted      a local minimum is a number , such that for all in the ball     a local minimum is a number , such that for all in the ball          Newton's Method  We saw Newton's Method in which found values where . If a function is differentiable, then we can use Newton's Method on to find minima and maxima.  First, make sure that you have the Rootfinding.jl file and then    include(\"Rootfinding.jl\")  using ForwardDiff, .Rootfinding, LinearAlgebra    Then we can use Newton's method on the derivative of the function    f(x::Real) = (x-1)^2    by    newton(x -> ForwardDiff.derivative(f,x),0)    which returns    The root is approximately x̂ = 1.0  An estimate for the error is 0.0  with f(x̂) = 0.0  which took 1 steps    This method works reasonably well to find local minima or maxima of functions of 1 variable if the function is differentiable. However, often, functions are of more than one variable and not differentiable and we would still like to find optimum points. There are other more robust methods that we start with below.    Gradient Descent   The basic method for optimizing functions of more than 1 variable is called gradient descent. Consider     we can produce a contour plot of the region with    x = y = LinRange(0,pi,101)  contour(x, y, (x, y) -> sin(0.5x^2-0.25y^2+2)*cos(x+y))    and these commands results in the following contour plot.     (for accessibility)    The colors of the contours have heights given on the bar to the side. There is a local minimum near the point and we will use a gradient descent method to find this.  The idea with gradient descent is that a starting point is chosen in a manner similar to that of Newton's method. The gradient of a function, , denotes a vector showing the direction of greatest increase. Since we are seeking a minimum, the direction of greatest descent is the opposite direction or .     where is some number that may depend on the point.    Gradient Descent using Julia  Here is some julia code that will peform a simple gradient descent algorithm.   function gradientDescent(f::Function,x₀::Vector; γ = 0.25, max_steps = 100) local steps = 0 local ∇f₀ = [1,1] # initialize it to get into while loop while norm(∇f₀) > 1e-8 && steps < max_steps ∇f₀ = ForwardDiff.gradient(f,x₀) x₀ = x₀ - γ*∇f₀ steps += 1 end steps < max_steps || throw(ErrorException(\"The number of steps has exceeded $max_steps\")) x₀ end   and we can use this code To get the symbol above, type \\nabla , then hit TAB. To get subscripts like x₀ , type x then \\_0 then hit tab. You can get other numerical subscripts with other digits after the underscore. to find a minimum of the function in , first we define it as    f(x::Vector) = sin(0.5x[1]^2-0.25x[2]^2+2)*cos(x[1]+x[2])    where the value x needs to be a Vector , which is a 1D array, for the ease of taking gradients with the ForwardDiff.gradient function. The standard and variables are x[1] and x[2] respectively. To find the minimum with this function use:    gradientDescent(f,[0.1,0.1])    which returns    2-element Vector{Float64}:  1.1036863833552772  2.0379062674731965    The maximum can be found using this same method by finding the minimum of the negative of this function. Find the maximum of this same function near the point .    The Barzilai–Borwein method  We used a constant for the value above, however, in [REF!!!], Barzilai and Borwein developed a steepest descent method that acts much like Newton's method in term of convergence speed by selecting:     Note, though that requires knowing information at the previous step (both and ) which is not available on the first step. We can use the simple gradient descent (where we used a constant value of ) on the first step and then   function gradientDescentBB(f::Function,x₀::Vector; max_steps = 100) local steps = 0 local ∇f₀ = ForwardDiff.gradient(f,x₀) local x₁ = x₀ - 0.25 * ∇f₀ while norm(∇f₀) > 1e-4 && steps < max_steps ∇f₁ = ForwardDiff.gradient(f,x₁) Δ∇f = ∇f₁-∇f₀ x₂ = x₁ - abs(dot(x₁-x₀,Δ∇f))\/norm(Δ∇f)^2*∇f₁ x₀ = x₁ x₁ = x₂ ∇f₀ = ∇f₁ steps += 1 end steps < max_steps || throw(ErrorException(\"The number of steps has exceeded $max_steps\")) x₁ end   Then   gradientDescentBB(f,[0.1,0.1])   which returns    2-element Vector{Float64}:  1.1036850670346863  2.0379038305805874       Fitting Data to a Line -- Linear Regression   We saw in of fitting various functions to data. We skipped over a lot of details there by using a package called LsqFit . We're going to revisit this by using the techniques here, which allows use to find fits in more generally ways than using that package. We'll start with a common task of finding the best fit line through a set of points and let's just take a small example. Let   pts=[(1,8), (2,7), (4,6), (5,6), (8,4) ,(9,2), (10,1)]   and let's plot them with   scatter(map(pt->pt[1],pts),map(pt->pt[2],pts),legend=false)   which results in     (for accessibility)    Let   and we want to minimize this recalling that the variables are and (note that and are the data). Basically, this comes down to defining the function in julia and using one of the methods from above. We can write down like    leastSqLine(coeffs::Vector{T}) where T <: Real = sum(pt -> (coeffs[1]*pt[1]+coeffs[2]-pt[2])^2,pts)    where pts is defined above. If we try    gradientDescent(leastSqLine,[-1,10])    the result is The number of steps has exceeded 100. Oops. This is common for some functions of more that one variable. If we look at a contour plot with the command:    x = LinRange(-5,5,201)  y = LinRange(5,15,201)  contour(x,y,(x,y) -> leastSqLine([x,y]),levels=[0,10,20,50,100,200,500,1000,2000])       (for accessibility)    you can see that there appears to be a minimum, however it is in a long narrow canyon. This is a common example where gradient descent does not work well, even if we try different values of . (Try it!!) Instead, if we use the Barzilai–Borwein method,    opt = gradientDescentBB(leastSqLine,[-1,10])    results in    2-element Vector{Float64}:  -0.7248062015540494  8.89534883720881    and this is the same as = -0.7248062015540494 and = 8.89534883720881.  Plotting the data above, with the least-square line with:    scatter(map(pt->pt[1],pts),map(pt->pt[2],pts),legend=false)  plot!(x->opt[1]*x+opt[2],-1,10)    resulting in     (for accessibility)    and this appears to be a good fit to the data.    Fitting Data to Polynomial  As discussed elsewhere, a polynomial has many nice properties for a function. This includes 1) there are only multiplications, additions and subtractions of numerical values to evaluate it (these are all fast operations on a CPU) and 2) horner's form of the polynomial make them super fast to evaluate. Because of this, using a polynomial as way to calculate other functions is common.  In this section, we will fit a polynomial to a natural logarithm. It will be similar to fitting data to a line, except the data will be generated from a function and we will use a polynomial (of some degree as the fit). Let's try to fit a cubic to a set of data generated by on . We first generate the x points with    x=LinRange(1,5,10)    and then can define the least squares for the log with:    leastSqLog(c::Vector{T}) where T <: Real = sum(xpt -> (c[1]+c[2]*xpt+c[3]*xpt^2+c[4]*xpt^3-log(xpt))^2,x)    and then using Barzilai–Borwein on this:    c = gradientDescentBB(leastSqLog,[-1,1,-1,1])    results in    4-element Vector{Float64}:  -1.0397984025249933  1.2746659713794941  -0.24265284063756612  0.018798253240499104    which are the 4 coefficients of the cubic polynomial.  and if we plot the function with the following: plot([x -> c[1]+c[2]*x+c[3]*x^2+c[4]*x^3,log],1,5, label=[\"Polynomial\" \"Natural Log\"], legend = :topleft)   which has the result     (for accessibility)    showing that they are almost identical. The error which is the difference between the polynomial and the log function can be plotted with:   plot(x->(abs(c[1]+c[2]*x+c[3]*x^2+c[4]*x^3- log(x))),1,5)   the result is     (for accessibility)    and this shows that with just a cubic, we can approximate the natural log to 0.016 (almost 2 digits). If we choose a higher-degree polynomial, we can do better and in fact, using polynomials as approximations is often the way that many mathematical functions are evaluated.     Using the JuMP package   There is a very nice package for optimization called the JuMP package \\cite{DunningHuchetteLubin2017} which allows the ability to set up a problem, then optimize it. Make sure you add the following packages and then   using JuMP, Ipopt   Let's first minimize the function of two variables at the top of this chapter with    model = Model(Ipopt.Optimizer)  @variable(model, x, start = 0.1)  @variable(model, y, start = 0.1)  @NLobjective(model, Min, sin(0.5x^2-0.25y^2+2)*cos(x+y))    and note that there was no output. This only adds the two variables as well as the objective function and since it is nonlinear, we use the @NLobjective macro.  To find the minimum,   optimize!(model)   which returns   ****************************************************************************** This program contains Ipopt, a library for large-scale nonlinear optimization. Ipopt is released as open source code under the Eclipse Public License (EPL). For more information visit https:\/\/github.com\/coin-or\/Ipopt ****************************************************************************** This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2. Number of nonzeros in equality constraint Jacobian...: 0 Number of nonzeros in inequality constraint Jacobian.: 0 Number of nonzeros in Lagrangian Hessian.............: 3 Total number of variables............................: 2 variables with only lower bounds: 0 variables with lower and upper bounds: 0 variables with only upper bounds: 0 Total number of equality constraints.................: 0 Total number of inequality constraints...............: 0 inequality constraints with only lower bounds: 0 inequality constraints with lower and upper bounds: 0 inequality constraints with only upper bounds: 0 iter objective inf_pr inf_du lg(mu) ||d|| lg(rg) alpha_du alpha_pr ls 0 8.9014960e-01 0.00e+00 2.21e-01 -1.0 0.00e+00 - 0.00e+00 0.00e+00 0 1 8.8938129e-01 0.00e+00 2.26e-01 -1.7 2.26e-03 2.0 1.00e+00 1.00e+00f 1 2 8.8683604e-01 0.00e+00 2.40e-01 -1.7 7.19e-03 1.5 1.00e+00 1.00e+00f 1 3 8.7635157e-01 0.00e+00 2.89e-01 -1.7 2.61e-02 1.0 1.00e+00 1.00e+00f 1 4 7.7132679e-01 0.00e+00 5.70e-01 -1.7 1.59e-01 0.6 1.00e+00 1.00e+00f 1 5 7.0600048e-01 0.00e+00 6.73e-01 -1.7 6.88e-02 1.0 1.00e+00 1.00e+00f 1 6 2.3792272e-01 0.00e+00 9.03e-01 -1.7 3.57e-01 0.5 1.00e+00 1.00e+00f 1 7 -8.1257894e-01 0.00e+00 6.74e-01 -1.7 1.13e+00 0.0 1.00e+00 1.00e+00f 1 8 -9.5265426e-01 0.00e+00 4.47e-01 -1.7 5.61e-01 - 1.00e+00 1.00e+00f 1 9 -9.9993858e-01 0.00e+00 1.64e-02 -1.7 2.12e-01 - 1.00e+00 1.00e+00f 1 iter objective inf_pr inf_du lg(mu) ||d|| lg(rg) alpha_du alpha_pr ls 10 -1.0000000e+00 0.00e+00 9.57e-05 -3.8 7.48e-03 - 1.00e+00 1.00e+00f 1 11 -1.0000000e+00 0.00e+00 3.43e-09 -5.7 4.25e-05 - 1.00e+00 1.00e+00f 1 Number of Iterations....: 11 (scaled) (unscaled) Objective...............: -1.0000000000000000e+00 -1.0000000000000000e+00 Dual infeasibility......: 3.4309616552489507e-09 3.4309616552489507e-09 Constraint violation....: 0.0000000000000000e+00 0.0000000000000000e+00 Variable bound violation: 0.0000000000000000e+00 0.0000000000000000e+00 Complementarity.........: 0.0000000000000000e+00 0.0000000000000000e+00 Overall NLP error.......: 3.4309616552489507e-09 3.4309616552489507e-09 Number of objective function evaluations = 12 Number of objective gradient evaluations = 12 Number of equality constraint evaluations = 0 Number of inequality constraint evaluations = 0 Number of equality constraint Jacobian evaluations = 0 Number of inequality constraint Jacobian evaluations = 0 Number of Lagrangian Hessian evaluations = 11 Total seconds in IPOPT = 0.032 EXIT: Optimal Solution Found.   There's a lot to unpack here, but there just a few things to note:     All of the steps are shown. This took 11 steps and you see the objective column reports the value of the objective starting at the point with value 8.901e-01 and decreasing to -1.0e+00     There are total number of function, gradient, Jacobian and Hessian evaluations, where the latter two are matrices of derivatives. Like we did in defining our gradient descent function, these are done with the ForwardDiff package. This is helpful if your function takes a long time to compute to see where time is spent.    The last line says EXIT: Optimal Solution Found. which is what we wanted.     Note that the point itself is not listed. We can get this with the value function, so   value(x),value(y)   returns    (1.1036863858138652, 2.0379062691204775)    which is the same point (to nearly the same precision) as we found above.    Linear Regression with JuMP  We can minimize this function with    model = Model(Ipopt.Optimizer)  set_optimizer_attribute(model,\"print_level\",3)  @variable(model,m,start=0)  @variable(model,b,start=0)  @NLobjective(model,Min, sum((m*pt[1]+b-pt[2])^2 for pt in pts))  optimize!(model)    where we have set the print_level attribute of the Ipopt solver to 3 to print out less information. Also, note that the way the objective function is called And we haven't shown the information here, but the most important aspect is that it found the solution. The values are    value(m),value(b)    which returns    (-0.7248062015503872, 8.8953488372093)    and now we can plot the result together with the points with    scatter(map(pt->pt[1],pts),map(pt->pt[2],pts),legend=false)  plot!(x->value(m)*x+value(b),-0.5,10.5)    resulting in     (for accessibility)       "
},
{
  "id": "fig-opt-xsq",
  "level": "2",
  "url": "ch-optimization.html#fig-opt-xsq",
  "type": "Figure",
  "number": "33.1",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "def-local-opt-var",
  "level": "2",
  "url": "ch-optimization.html#def-local-opt-var",
  "type": "Definition",
  "number": "33.2",
  "title": "",
  "body": "  Consider a function that is continuous on some open interval containing .     a local minimum is a number , such that for all in the interval for some small .    a local maximum is a number , such that for all in the interval for some small .      "
},
{
  "id": "def-local-rn",
  "level": "2",
  "url": "ch-optimization.html#def-local-rn",
  "type": "Definition",
  "number": "33.3",
  "title": "",
  "body": "  Consider a function that is continuous on some open ball of radius containing the point , denoted      a local minimum is a number , such that for all in the ball     a local minimum is a number , such that for all in the ball       "
},
{
  "id": "fig-contour",
  "level": "2",
  "url": "ch-optimization.html#fig-contour",
  "type": "Figure",
  "number": "33.4",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-optimization-4-3-10",
  "level": "2",
  "url": "ch-optimization.html#ch-optimization-4-3-10",
  "type": "Check Your Understanding",
  "number": "33.5",
  "title": "",
  "body": "The maximum can be found using this same method by finding the minimum of the negative of this function. Find the maximum of this same function near the point . "
},
{
  "id": "fig-opt-scatter",
  "level": "2",
  "url": "ch-optimization.html#fig-opt-scatter",
  "type": "Figure",
  "number": "33.6",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-opt-contour2",
  "level": "2",
  "url": "ch-optimization.html#fig-opt-contour2",
  "type": "Figure",
  "number": "33.7",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-opt-scatter2",
  "level": "2",
  "url": "ch-optimization.html#fig-opt-scatter2",
  "type": "Figure",
  "number": "33.8",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-opt-log",
  "level": "2",
  "url": "ch-optimization.html#fig-opt-log",
  "type": "Figure",
  "number": "33.9",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-opt-logerror",
  "level": "2",
  "url": "ch-optimization.html#fig-opt-logerror",
  "type": "Figure",
  "number": "33.10",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-opt-linregress",
  "level": "2",
  "url": "ch-optimization.html#fig-opt-linregress",
  "type": "Figure",
  "number": "33.11",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-complex",
  "level": "1",
  "url": "ch-complex.html",
  "type": "Chapter",
  "number": "34",
  "title": "Complex Numbers and Analysis",
  "body": " Complex Numbers and Analysis   Julia handles complex numbers in a natural manner. The type Complex is part of the Base package and is a subtype of the abstract data type Number . In this chapter, we go through basics of complex numbers in julia and see linear algebra and fourier transforms. You should have some basic knowledge of complex numbers before proceeding.    Complex Numbers   Entering    z1 = 1+2im    and checking the type with typeof(z1) returns Complex{Int64} which indicates that it is parametric type where the individual elements are integers. Notice that im is the imaginary constant. Naturally, there is a lot of basic arithmetic operations available, so if   z2 = 5-2im   Then      z1+z2 returns 6+0im .     z1-z2 returns -4+4im      z1*z2 returns 9 + 8im      z1\/z2 returns 0.03448275862068965 + 0.41379310344827586im      z1\/\/z2 returns 1\/\/29 + 12\/\/29*im      3z1-9z2 returns -42 + 24im .     Note the difference between the 3rd and 4th operation. The 3rd one does floating-point division, so the result is a Complex number of floats. The 4th does division resulting in Rational numbers. Test with typeof on both of these results.    Functions of Complex Numbers  Most functions ``just work'' in that they return the function evaluated at the complex number, however you need some basic understanding about what this means.      sqrt(z1) returns 1.272019649514069 + 0.7861513777574233im .     atan(z1) returns 1.3389725222944935 + 0.40235947810852507im .     log(-1+0im) returns 0.0 + 3.141592653589793im      exp(pi*im) returns -1.0 + 1.2246467991473532e-16im .     Although we won't go into how these are calculated A firm understanding of what the sine of a complex number requires some complex analysis , note that you get answers. For log(-1+0im) , this shows that if you are considering imaginary numbers, you can take the logarithm of a negative number, which is not allowed in the reals.  Also, the last one is the famous equation however since it using floating-point to do this, you get round-off error due to the limited precision.    Functions with Special Meaning for Complex Numbers  There are some functions that have special means for complex numbers. The functions real and imag return the real and imaginary part of the number (the result of each is a Real , generally an Int , Float or Rational .  The absolute value of a complex number is defined as the distance in the complex plane from the origin or if , then     Also, the complex conjugate, generally denoted , is       real(z1) returns 1 .     imag(z1) returns 2 .     abs(z1) returns 2.23606797749979      abs2(z1) returns 5 , which is the square of the absolute value. This is generally used for speed in that a square root is not needed.     conj(z1) returns 1 - 2im .     angle(z1) returns 1.1071487177940904 is the argument of , which is the angle in radians of the point plotted in the complex plane.        Linear Algebra with Complex Numbers  There are many applications (including Fourier Transforms that we will see in the next section) involving matrices of complex numbers and the corresponding functions.  The functions discussed in work with matrices involving complex numbers in a seamless manner including sums, differences, scalar and non-scalar multiplication and solving.  However there are many functions that have different meaning with complex numbers. Take for example, the matrix    C = [1 -im;2+im 3]    and if we take the transpose using   C'   the result is    2×2 adjoint(::Matrix{Complex{Int64}}) with eltype Complex{Int64}:  1+0im 2-1im  0+1im 3+0im    Unless you know how the transpose works with complex matrices, this may be surprising in that as the two non-diagonal element actually both switch as well as have the conjugate applied.  Notice also that the type of the result gives a hint at what the ' operator actually does. Thus this is the adjoint of the matrix.    Discrete Fourier Transforms   The Discrete Fourier Transform or DFT is a function that takes a vector in or ( ) to . In particular it is     where is the input vector, is the imaginary constant and is the length of the vector.  The DFT has multiple applications including transforming a time-series to a set of frequencies (and this is often used in filter), solving partial differential equations and data compression. We will see some of these later.  From a mathematical point of view the DFT in can be thought of as the matrix product:     where     where     is the primitive th root of unity.  As an example, let x=[1,0,2,0] and then we will define   F = [exp(j*k*2*pi*im\/4) for j=0:3,k=0:3]   which returns    4×4 Matrix{ComplexF64}:  1.0+0.0im 1.0+0.0im … 1.0+0.0im  1.0+0.0im 6.12323e-17+1.0im -1.83697e-16-1.0im  1.0+0.0im -1.0+1.22465e-16im -1.0+3.67394e-16im  1.0+0.0im -1.83697e-16-1.0im 5.51091e-16+1.0im    And if we want the DFT of the vector x , then   xt = F*x   which returns    4-element Vector{ComplexF64}:  3.0 + 0.0im  -1.0 + 2.4492935982947064e-16im  3.0 - 4.898587196589413e-16im  -1.0 + 7.347880794884119e-16im    Note that this is virtually a real vector in that the imaginary parts are due to round off errors and near the precision of Float64 types.    Fast Fourier Transform  You can probably tell from the matrix above that there is a lot of symmetry to the matrix. Not only is it symmetric in the sense that , but due the fact that exponentials with imaginary powers are actually periodic functions, there are additional  (Find a good reference for how the FFT works)  There are a number of packages that perform the fast fourier transform, however, the FFTW (which stands for the Fastest Fourier Transform in the West) claims to be the fastest. To use this, first add FFTW and    using FFTW    and then use the fft function.   fft(x)   which returns nearly nthe same as above or    4-element Vector{ComplexF64}:  3.0 + 0.0im  -1.0 + 0.0im  3.0 + 0.0im  -1.0 + 0.0im    where the difference is in round-off errors.    "
},
{
  "id": "ch-complex-5-2-1",
  "level": "2",
  "url": "ch-complex.html#ch-complex-5-2-1",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Discrete Fourier Transform "
},
{
  "id": "ch-polynomial",
  "level": "1",
  "url": "ch-polynomial.html",
  "type": "Chapter",
  "number": "35",
  "title": "Creating a Polynomial Module",
  "body": " Creating a Polynomial Module   This chapter aims to walk through the steps of creating a reasonably complex module for polynomials. This builds on the parametric data type first introduced using polynomials in , the modules and test suite in and the ability to parse strings found in . The goal is to use all of these pieces to build up to a module that has quite a bit of functionality of polynomials.    Polynomial Module  We first start by placing a lot of the code that we developed in into a module. This will look like   module Poly export Polynomial struct Polynomial{T <: Number} coeffs::Vector{T} end function Base.show(io::IO, p::Polynomial) print(io, strip(reduce((str, n) -> \"$str $(n==1 ? \"\" : \"+\") $(p.coeffs[n]) x^$(n-1)\", 1:length(p.coeffs), init=\"\"))) end end # of the module Poly   Note we have called the module Poly to not get ourselves confused over the struct Polynomial . Place this code into a file called Poly.jl . Recall that we also developed code for addition\/subtraction and scalar multiplication. We will add this later. Also, we have adapted the Base.show command to trim the ends of the string of any whitespace. We will load the Revise package and then load this file as    using Revise  includet(\"Poly.jl\")  using .Poly    where it is important that we use the includet function from the Revise package. Recall that this allows us to update the package and then reuse structs and functions in the package without restarting the kernel. Test that this is working with    p1 = Polynomial([1,2,3])    and you shouldn't get any errors and see the output 1 x^0 + 2 x^1 + 3 x^2 .    Testing the Polynomial Module  We are going to start testing the module immediately. Here's a fair straightfoward test suite that just creates the polynomial and tests each are the correct type:   using .Poly using Test function isequal(x::Polynomial,y::Polynomial) return x.coeffs == y.coeffs end ## test the creation of polynomials poly1 = Polynomial([1,2,3]) poly2 = Polynomial([1.0,2.0,3.0]) poly3 = Polynomial([2\/\/3,3\/\/4,5\/\/8]) poly4 = Polynomial([im,2+0im,3-2im,-im]) poly5 = Polynomial([n for n=1:6]) poly6 = Polynomial([1,1.5,2\/\/3]) @testset \"Creating a Polynomial as a Vector of Coefficients\" begin @test isa(poly1, Polynomial) @test typeof(poly1) == Polynomial{Int64} @test isa(poly2, Polynomial) @test typeof(poly2) == Polynomial{Float64} @test isa(poly3, Polynomial) @test typeof(poly3) == Polynomial{Rational{Int64}} @test isa(poly4, Polynomial) @test typeof(poly4) == Polynomial{Complex{Int64}} @test isa(poly5, Polynomial) @test typeof(poly5) == Polynomial{Int64} @test isa(poly6, Polynomial) @test typeof(poly6) == Polynomial{Float64} end   Save these lines to a file called test-polynomial.jl and then run the code with    include(\"test-polynomial.jl\")    where this time we use the include comamnd. We don't need the includet since this is not a module that needs to be tracked. Upon running this, you should see:    Test Summary: | Pass Total Time  Creating a Polynomial as a Vector of Coefficients | 12 12 0.2s    This test code creates 6 polynomials of different types and then tests that each is the correct type. Note that for poly6 , the array of coefficients is a mix of integers, floats and rationals, but Julia automatically changes it to an array of Floats.    Testing the Stringification  The other part of the code that we have included in the module is that of the Base.show command. Recall that this is usually called when producing output, however it is also called when a polynomial is wrapped with the string method. For example,    p1 = Polynomial([1,2,3])  string(p1)    returns \"1 x^0 + 2 x^1 + 3 x^2\" . So we can set up a testset and a few tests for the first few polynomials in the test suite with    @testset \"Base.show\" begin  @test string(poly1) == \"1 x^0 + 2 x^1 + 3 x^2\"  @test string(poly2) == \"1.0 x^0 + 2.0 x^1 + 3.0 x^2\"  @test string(poly3) == \"2\/\/3 x^0 + 3\/\/4 x^1 + 5\/\/8 x^2\"  end    and running the test code results in a all passing. The stringificaiton of poly4 is a bit of a problem because the complex numbers should be wrapped in parentheses.   Update the Base.show command to handle complex numbers by wrapping each coefficient in parentheses.   Test the type of the coefficient using the typeof command. If it is of type Complex surround the coefficient with () .   Add a test to the test suite for the complex polynomial poly4 .     Test Driven Development  The standard for developing code today falls into what is called Test Driven Development or TDD . In short, this means that before any code is written, the test suites are created. For developers that have never done this before, it is very difficult way to develop because developers typically just want to write code--why test? We'll show how this is done for the rest of the chapter and show how it can be beneficial.  Although we have already written a little code, we will switch to writing tests before writing code.    Tests for Addition, Subtraction and Multiplication  We first start with tests for Addition, subtraction, scalar multiplicaiton and polynomial multiplication. We have already written this code earlier, but we'll write the tests before including the code. We'll start with handling polynomials with integer coefficients. If we start with the following polynomials    poly10 = Polynomial([1, 2, 3])  poly11 = Polynomial([-2,1,0,1])    then we can run tests on these with    @testset \"Addition, Subtraction, Multiplication and Constant Multiplication\" begin  @test poly10+poly11 == Polynomial([-1,3,3,1])  @test poly11-poly10 == Polynomial([-3,-1,-3,1])  @test 4*poly10 == Polynomial([4,8,12])  @test poly10*poly11 == Polynomial([-2,-3,-4,4,3])  end    and recall that the polynomial multiplication is performed using distribution (extended FOIL).    Creating tests for string contructors  Although we have a constructor for creating a polynomial from the coefficients, it's also nice to have a constructor that parses a string. For example, if we have    poly21 = Polynomial(\"-3+10x-5x^4\")  poly22 = Polynomial(\"x^2+2x+3\")  poly23 = Polynomial(\"2x-1\")    and then include the following tests at the bottom of the test file:   @testset \"Creating a Polynomial from a string with integer coefficients\" begin @test isa(poly21, Polynomial) @test typeof(poly21) == Polynomial{Int64} @test isequal(poly21, Polynomial([-3,10,0,0,-5])) @test isa(poly22, Polynomial) @test typeof(poly22) == Polynomial{Int64} @test isequal(poly22, Polynomial([3,2,1])) @test isa(poly23, Polynomial) @test typeof(poly23) == Polynomial{Int64} @test isequal(poly23, Polynomial([-1,2])) end   We would like to handle polynomials with coefficients of other types: floats, rational and complex numbers. We construct the following polynomails:   poly31 = Polynomial([1.0, 2.0, 3.0]) poly32 = Polynomial([0,4.0,0,-1.0]) poly33 = Polynomial([1\/2,1\/4,1\/8,1\/10]) poly34 = Polynomial(\"3.0x^2+2.0x+1.0\") poly35 = Polynomial(\"-1.0x^3+4.0\") poly36 = Polynomial(\"0.5+0.25x+0.125x^2+0.1x^3\") poly41 = Polynomial([1\/\/2, 1\/\/3, 1\/\/4]) poly42 = Polynomial([1,0,0,1\/\/6]) poly43 = Polynomial([-1\/\/8,0,0,0,1]) poly44 = Polynomial(\"1\/\/4x^2+1\/\/3x+1\/\/2\") poly45 = Polynomial(\"1\/\/6x^3+1\") poly46 = Polynomial(\"x^4-1\/\/8\") poly51 = Polynomial([im, 2+im, 3-2im]) poly52 = Polynomial([im,0,1]) poly53 = Polynomial([im,2,3im,4]) poly54 = Polynomial(\"(3-2im)x^2+(2+im)x+im\") poly55 = Polynomial(\"im+x^2\") poly56 = Polynomial(\"4x^3+3imx^2+2x+im\")   After defining these, each of these should then be tested for constructions and other operations (stringification, addition, subtraction and multiplicaiton). All of these can be found here .    Testing polynomial evalution  The last set of tests that we are going to develop are those of polynomial evaluation.   "
},
{
  "id": "sect-test-poly-string-7",
  "level": "2",
  "url": "ch-polynomial.html#sect-test-poly-string-7",
  "type": "Check Your Understanding",
  "number": "35.1",
  "title": "",
  "body": " Update the Base.show command to handle complex numbers by wrapping each coefficient in parentheses.   Test the type of the coefficient using the typeof command. If it is of type Complex surround the coefficient with () .   Add a test to the test suite for the complex polynomial poly4 .  "
},
{
  "id": "ch-polynomial-6-2",
  "level": "2",
  "url": "ch-polynomial.html#ch-polynomial-6-2",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Test Driven Development TDD "
},
{
  "id": "ch-calc-pi",
  "level": "1",
  "url": "ch-calc-pi.html",
  "type": "Chapter",
  "number": "36",
  "title": "Calculating the digits of <span class=\"process-math\">\\(\\pi\\)<\/span>",
  "body": " Calculating the digits of   In , we saw a method to find the digits of using random numbers. You should have noticed that it was not a very good method in that it took a million or so random numbers to produce 3 digits of . In this chapter, we will explore ways to do it using Power Series, a way of representing functions using calculus.  Recall that a power series is a function of the form:     which is the sum of terms with nonnegative integer powers of and an important aspect is that power series do not have a highest power. Nearly every function can be represented by a power series. The classic one is     which is called the geometric series.    Power Series of Arctangent  We will see that the arctangent function and resulting power series can produce the digits of to many digits. Let's dive into the power series of arctangent.  If we let in , then     Since the variable name doesn't matter, we can also write this in as:     If we integrate both sides:   and there is an integration constant, but it is 0, so we haven't shown it.  Now we can use the fact that , so if substitute into , then     and multiplying through by 4 results in a power series representation of or     We can estimate using a few terms of the above series in julia with:    4*(1-1\/3+1\/5-1\/7+1\/9-1\/11+1\/13-1\/15+1\/17-1\/19)    and the results are 3.0418396189294032 , which hopefully you can tell is not so great. Let's be more systematic about this though.   function calcPi(n::Integer) n > 0 || throw(ArgumentError(\"The input n must be positive.\")) local sum = 1.0 for k=1:n sum += (-1)^k\/(2k+1) end 4*sum end   for example, we can now determine 10,000 terms of this series with    pi10_000 = calcPi(10_000)    and get the results 3.1416926435905346 , which appears to be about 4 digits and actually, a better way to measure is if we have the function:    absErr(x::Real)=abs(x-pi)    which just the absolute error of the approximation using the built-in value pi . The error above is found with    absErr(pi10_000)    or 9.99900007414567e-5   To see how good (or technically how poorly), this method is, let's look at the errors for a few different series or:    errors = map(n -> absErr(calcPi(10^n)),1:7)    which returns    7-element Vector{Float64}:  0.09072315581580082  0.009900747481198291  0.0009990007497511222  9.99900007414567e-5  9.999899927226608e-6  9.999989813991306e-7  9.999998829002266e-8    A visual of this can be found with scatter(1:7, -log10.(errors), legend=false)   where notice that we have taken the negative of the log of the errors to determine the number of digits of accuracy. The plots is     (for accessibility)    and this shows that every power of 10 more terms in the series results in about a 1 digit improvement in calculating --this is because the slope of the line is about . Also since   @time calcPi(1_000_000)   which takes 0.077268 seconds to get 20 digits of would take times longer than this or about 245,000 years.  In short, this is a terrible way to calculate .    Euler Improves this  This section presents how Euler (the most prolific 18th century mathematician) improved on this.  You may recall that there is the following formula for the tangent of the sum of two values:     If we let     then     so     so if we use the power series in , we can hopefully improve on the approximation of .  First, let's define:   function atan_series(x::Real,n::Integer) n > 0 || throw(ArgumentError(\"The input n must be positive.\")) local sum = x for k=1:n sum += (-1)^k*x^(2k+1)\/(2k+1) end sum end   which uses n terms of the power series of at the value .  To estimate , Let's just do 10 terms of this.    4*(atan_series(1\/2,10)+atan_series(1\/3,10))    and this returns: 3.1415926704506854 , which if you don't remember the first 15 digits of , the error is    absErr(4*(atan_series(1\/2,10)+atan_series(1\/3,10)))    which is 1.6860892237957614e-8 so this appears to converge much faster than the method in the previous section. If we repeat with 20 terms, the error is    absErr(4*(atan_series(1\/2,20)+atan_series(1\/3,20)))    which is 7.993605777301127e-15 , so about 14 digits. You should notice that quite quickly, the value is converging. Since we are quickly running out of precision for 64-bit floats, we will switch to BigFloat s and quite easily with:   4*(atan_series(1\/big(2),20)+atan_series(1\/big(3),20))   which returns    3.141592653589801775394859982612606961085892242193168775435423632752985359741545    Let's visually see how quickly this is converging. First, we'll find the errors with:   errors2=map(n -> absErr(4*(atan_series(1\/big(2), 10n) + atan_series(1\/big(3), 10n))), 1:5)   which returns    5-element Vector{BigFloat}:  1.686089269049955549324338738573041181676956757596130409476023763757476121934317e-08  8.536932216599333104076888722842818062954460479040445168953455346681077569196179e-15  5.541360098004753291440085860743946761847969162268014510791810751138256936210001e-21  4.005347048909364704518520476811412326265959273017889120734252574465535050431139e-27  3.075296346725383632749782433311833539450331895967037047902902585859740513243069e-33     scatter(10:10:50, -log10.(errors2), legend=false)   which results in     (for accessibility)    The slope of this line is about , which implies that every 10 terms results in another 6 digits of accuracy. Using the plot, we estimate that 100 digits would give an accuracy of over 60 digits and   @time absErr(4*(atan_series(1\/big(2),100)+atan_series(1\/big(3),100)))   took 0.000251 seconds and has a accuracy of about 63 digits.  which 5 times as many digits and is much faster than the estimated 245,000 years that the previous method was predicted to take.  Since the default number of decimal digits for a BigFloat is about 78 decimal places, we again will quickly run out of precision. Let's try to see about finding to 1000 digits. We're going to adjust the precision of BigFloat s, but instead of setting in everywhere we can set it on a block of code with    setprecision(4096) do  # run code here  end    then the number of digits of precision can be seen with    setprecision(4096) do  length(string(1\/big(3)))  end    which creates the BigFloat 1\/3, turns it to a string and finds the length. The result is 1237 , so this is plenty to calculate to 1000 digits.  To estimate the number of terms needed for 1000 digits, a line fitting the data above is about . So a little algebra for letting , results in terms. Entering:    setprecision(4096) do  @show pi1000=4*(atan_series(1\/big(2),1594)+atan_series(1\/big(3),1594))  absErr(pi1000)  end    results in    pi1000 = 4 * (atan_series(1 \/ big(2), 1594) + atan_series(1 \/ big(3), 1594)) = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321714865601239565154256531508207949971669743165722740018351762297978126407660203701569790495607661311942951883071049126683863914353996276446515815532113161156858922687498386163189387937947070163492538574522358773840865866641344202158314334039229961783600168318495477941285685  2.5975351095458754904195491157857696803622131507293634931295093187648738419240192667709752546427822529941468450549877713666966011614851313600669596886196498994143921672175459108290471960863459461639251291662232368565896246328120598260939106463457479630917174483761218561210120412869465176525005824807899438481196329993790493359900522454759482318202266105921331249007978097775724687956301642633550860637174924190228399842631614879639158046917042635291042631965291845166527036203452319813178296082929894900734880740547269432828997961816403444163166354514484699977363284177623290122184020750178932873624933570074682872942723076449879540864947698524422632479056630893008599428469562364494768790325744031011930601596329086026289242110179341279393200929314660273031057473081913078692798691499162555114494444741975803032974623739919031238086655685280832758980871795419698822680825529239750189369473347847251964195124706746244861133322038379060583915976636069455518781609572437864178386621806568957217481465862297442152542221932061173187093506126070914995792754149603406706779637343994385988667569337732890340690567393340395500287349361658707200982844137221365907346244068359959729947248038871713897283543740693133197921478035649291888640453449e-964    The exponential terms is 10 to the , that is about 964 digits of accuracy. Obviously this didn't find to the required 1000 digits. Our estimate was off a bit. Before we adjust this, note that we are really just interested in the number of digits, we can find by taking the log of the result or more-specifically:    numDigits(pi_approx::Real) = floor(Int,-log10(absErr(pi_approx)))    So instead, let's    setprecision(4096) do  pi1000=4*(atan_series(1\/big(2),1594)+atan_series(1\/big(3),1594))  numDigits(pi1000)  end    which will return 963 .  Since the 1594 was an estimate, let's bump up the number of terms to 1700:    @time setprecision(4096) do  pi1000=4*(atan_series(1\/big(2),1700)+atan_series(1\/big(3),1700))  numDigits(pi1000)  end    which showed the number of digits is 1027 and took 0.072266 seconds.    Speed of the arctangent series  Much of this chapter is about speed. We want to be able to calculate in a reasonable amount of time. We can actually speed up the algorithm in a way similar to the Horner's form as in in the following way. If we write in the following way:     we can sum this faster. Consider   function atan_series2(x::Real,n::Integer) n > 0 || throw(ArgumentError(\"The input n must be positive.\")) local negxsq = -x^2 local sum = 1.0 local ak = 1.0 for k=2:n ak *= negxsq sum += ak\/(2k-1) end x*sum end   Some of the ways this speeds up is by first calculating and this is the only power of calculated. Then sums of this term are made. To test the speed, let's first use the BenchmarkTools package and repeat the example above:    @btime setprecision(2^14) do  numDigits(4*(atan_series(1\/big(2),1700)+atan_series(1\/big(3),1700)))  end    which results in 395.834 ms and using the new series with    @btime setprecision(2^14) do  numDigits(4*(atan_series2(1\/big(2),1700)+atan_series2(1\/big(3),1700)))  end    and this results in 39.631 ms which is a 10 times speed enhancement.    If I had a million dollars digits  With apologies to the Barenaked Ladies, The Barenaked Ladies is a Canadian rock band, which the author was a fan of. One of their biggest hits was If I had a Million Dollars . let's see how feasible it is to find to a million digits. First, we need to make sure that we use a large enough BigFloat . If we try    setprecision(2^14) do  length(string(1\/big(3)))  end    using or 16384 bits results in a BigFloat with 4936 decimal digits. If you play with the power on the precision, note that we need a minimum of binary digits, this should be enough. However, note that at this level of precision, calculations slow down quite a bit. For example,    @time setprecision(2^22) do  numDigits(4*(atan_series2(1\/big(2),100)+atan_series2(1\/big(3),100)))  end    shows that the same 63 digits of accuracy took 13.153726 seconds. Also, it can be checked that doubling the number of terms will double the number of digits as well as doubling the time. It's estimated it would take 58 hours to use this method to find to 1 million digits.    Machin's Formula and related Formulas   The reason that Euler's formula worked much better that the first method is that it calculated the arctangents of and . This converges relatively quickly in that power series are powers of and . If we can develop similar formula for fractions closer to zero, this may converge even faster.  Machin in 1706 noticed the relationship     and was able to extend what Euler did as well in a much more efficient manner as we will see below. There are a lot of known Machin-type formula that exist (and check out Wikipedia site for some examples). In the 1970s and 1980s with the accelerated power of computers, many mathematicians and computer scientists founds many other formulas like . For example, in 1982, Kikuo Takano showed that     And for -day in 2024, Matt Parker A favorite of the author who has both a podcast and youtube channel with fascinating and entertiaining mathematical-related material. covened many people to hand calculate . This group used the following relationship:       Using Machin's Formulas to Calculate  Notice that in , , and , they are all linear combinations of integer coefficients with arctangents of 1 over an integer. Because of this, we can write the following Julia function to calculate all of these:   function machin(coeffs::Vector{Int}, xvals::Vector{T},n::Int) where T <: Integer length(coeffs) == length(xvals) || throw(ArgumentError(\"The lengths of the vectors must match\")) local sum=big(0) for i=1:length(coeffs) sum += coeffs[i]*atan_series2(1\/big(xvals[i]),n) end 4*sum end   Then for a testing example, we can reproduce the Euler formula with    setprecision(2^14) do  numDigits(machin([1,1],[2,3],100))  end    and this returns 62 . Use this on Machine's formula in and we'll put the precision back to handling a million digits and the following    @time setprecision(2^22) do  numDigits(machin([4,-1],[5,239], 100))  end    results in 141 digits of accuracy in 11.025900 seconds . If we double the number of terms used from 100 to 200, the time roughly doubles to 19.208941 seconds. and the number of terms goes to 352 . This would seem to show that to get to million digits would take just about 19 hours, which is shorter than Euler's method, but not great.  If we apply the Takano's formula in with    @time setprecision(2^22) do  numDigits(machin([44,7,-12,24],[57,239,682,12943], 100))  end    this shows that we get 352 digits of accuracy in 16.688353 seconds. Again, doubling the number of terms doubles both the accuracy (704 digits) and the time it takes ( 27.553502 seconds ). Again, extrapolating, Takano's method would take 10.87 hours to do 1 million digits.  And lastly, the formla that Matt Parker used in can be calculated with    @time setprecision(2^22) do  numDigits(machin([83,17,-22,-24,-44,12,22],  [big(107),big(1710),big(103697),big(2513489),big(18280007883),big(7939642926390344818), big(3054211727257704725384731479018)], 100))  end    which resulted in 407 digits of accuracy in 25.319640 seconds . Again, doubling the number of terms used doubled the accuracy to 813 digits and took 43.706857 seconds . Extrapolating this would result in a million digits in 14.93 hours. Notice that each of these Machin's formulas are good, but would take quite a bit of computing time. Notice that the method of Parker was slower than Takano's formula, but the goal of Matt Parker was to calculate this by hand using the formula. For a bit of a spoiler, the group calculated to 120 digits during a week of work.      The Chudnovsky Brothers and Ramanujan   There is a fascinating article in the March 2, 1992 issue of the New Yorker magazine (provide ref) A pair of brothers with last name Chudnovsky built a supercomputer out of mail-order parts in their New York City apartment with the goal of finding the digits of . They used the following series:     which was originally attributed to Ramanujan. I won't get into the details of the story here or Ramanujan, but the New Yorker story is a easy and great read and learning about Ramanujan is yet another wonderful tangent.   This equation can be written as     If we let     then using we can solve for with:     We can do this in julia with the following:   function chud(n::Integer) sum = big(0) for k=0:n ak = (-1)^k*factorial(big(6k))\/factorial(big(3k))\/ factorial(big(k))^3\/ (big(640320)^3)^(k+0.5) sum += big(545140134)*k*ak + big(13591409)*ak end 1\/(12sum) end   and let's check out it's performance by a comparison to Takano's method above:    @time setprecision(2^22) do  numDigits(chud(20))  end    and the result shows that this calculates to 297 digits and took 145 seconds. Note that we only used 20 terms for this calculation. Before, trying to determine the total time to get to 1 million digits, we can use some of the same techniques that we used to speed up the arctangent series in the function atan_series2 as   function chudnovsky(n::Integer) local sum1 = big(1.0) local sum2 = big(0.0) local top = big(1) local bottom = big(1) local C = big(640320)^3 for k=1:n top *= -24*(6*k-5)*(2*k-1)*(6*k-1) bottom *= C*k^3 sum1 += top\/bottom sum2 += k * top\/bottom end 426880*sqrt(big(10005))\/(13591409*sum1 + 545140134*sum2) end   and computing the first 20 terms of this using:    @time setprecision(2^22) do  numDigits(chudnovsky(20))  end    results in the same 297 terms (which is good that we got the same results) in 7.862153 seconds.  and try with twice as many terms with:    @time setprecision(2^22) do  numDigits(chudnovsky(40))  end    and the result is 581 digits in 10.962281 seconds and if we go to 80 terms, then we get 1148 terms in 15.179335 seconds. The relationship seems to be roughly linear, so we expect the total time to calculate to a million digits would be about 3.67 hours.    A parallel version of the Chudnovsky Algorithm  All of the algorithms here in this chapter can be adapted for parallelization because the sums can be split into pieces to be distributed over multiple processors or cores. If you need to, you may want to review the material in for background on distributed computing in julia.   using Distributed   We rewrite the chudnovsky function so it can be parallelized. We want to be able to break up the sum in to sum between and .   @everywhere function paraChud(n1::Integer,n2::Integer,prec::Integer) setprecision(prec) local C = big(640320)^3 local bottom = big(1) local top = big(1) for k=1:n1 bottom *= k^3*C top *= -8*(6k-1)*(6k-3)*(6k-5) end local sum1 = n1*top\/bottom local sum2 = top\/bottom for k=n1+1:n2 bottom *= k^3*C top *= -8*(6k-1)*(6k-3)*(6k-5) sum1 += k*top\/bottom sum2 += top\/bottom end 545140134*sum1 + 13591409*sum2 end   A number of comments about this function:     On line 1, recall that @everywhere is needed for parallelization.    Also due to parallelization, we need to set the precision on each core\/processor, so the precision is passed into the function and set on line 2.    Line 3--11, build up the values of bottom and top needed for the 2nd for loop. These are needed because instead of actually calculating the factorial, we build up the values term by term. Note, we also keep the terms bottom and top as BigInt s for speed instead of calculating each term as a BigFloat .    The for loop in lines 12--17 repeat the calculations for the terms, however in this case calculate the terms for sum1 and sum2 .    The number that is returned is the number in in the parentheses for the terms through . This doesn't return because we need to add the terms up first.     An example of how to use this function (although not in a parallel fashion) is    @time let  prec = 2^22  p1 = paraChud(0,9,prec)  p2 = paraChud(10,19,prec)  p3 = paraChud(20,29,prec)  p4 = paraChud(30,39,prec)  numDigits(sqrt(big(640320)^3)\/(12*(p1+p2+p3+p4)))  end    which returns:  Note that p1 through p4 calculate 10 terms of the series each. Then the last line is the equation and for .  To do parallelization, we can adapt from above using the pmap function, which recall, does parallel map. We can repeat the above line as:    @time setprecision(2^22) do  local p = pmap(i -> paraChud(10*(i-1),10i-1,2^22),1:4)  local s = sum(p)  numDigits(sqrt(big(640320)^3)\/(12s))  end    which returns nearly the same number of digits (597) in 8.644556 seconds just a bit smaller than the non parallel version. The machine that I am using has 8 cores, so we'll change the end of the second line to 1:8 or    @time setprecision(2^22) do  local p = pmap(i -> paraChud(10*(i-1), 10i-1, 2^22),1:8)  local s = sum(p)  numDigits(sqrt(big(640320)^3)\/(12s))  end    which will double to the number of digits to 1134 in 11.959962 seconds.  Cranking up to a total of 800 terms with    @time setprecision(2^22) do  local p = pmap(i->paraChud(100*(i-1),100i-1,2^22),1:8)  local s = sum(p)  numDigits(sqrt(big(640320)^3)\/(12s))  end    resulted in 11345 digits of accuracy in 48.279909 seconds and using this method would be predicted that we could calculate to just over 1 million digits in about 71 minutes. This was on my 8-core Macbook Air. Just for comparison, the New Yorker article cited above mentioned that the Chudnovsky brothers computed to more that 1 billion digits. It didn't mention how long it took.  You can't just take the 18 minutes and multiply by 1000 to get to a billion digits because I used the floating-point precision that was just over a million and would have to scale that.   Parallelize the machin and atan_series2 functions above. Note: you will need to do similar techniques to that in the paraChud function.   Test these by comparing to the non parallelized versions.     "
},
{
  "id": "fig-pi-atan-error",
  "level": "2",
  "url": "ch-calc-pi.html#fig-pi-atan-error",
  "type": "Figure",
  "number": "36.1",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-err-euler",
  "level": "2",
  "url": "ch-calc-pi.html#fig-err-euler",
  "type": "Figure",
  "number": "36.2",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "ch-calc-pi-8-3-21",
  "level": "2",
  "url": "ch-calc-pi.html#ch-calc-pi-8-3-21",
  "type": "Check Your Understanding",
  "number": "36.3",
  "title": "",
  "body": " Parallelize the machin and atan_series2 functions above. Note: you will need to do similar techniques to that in the paraChud function.   Test these by comparing to the non parallelized versions.  "
},
{
  "id": "ch-api",
  "level": "1",
  "url": "ch-api.html",
  "type": "Chapter",
  "number": "37",
  "title": "Working with a web API and JSON strings",
  "body": " Working with a web API and JSON strings  This chapter will shown how to interact with a web API, a common way of getting data from a webserver in a way that can be more easily processed than with a HTML page. We first start with what a JSON string is and how to parse it, recall some basics of dictionaries from and then make API calls using some network tools in Julia.  "
},
{
  "id": "ch-getting-started",
  "level": "1",
  "url": "ch-getting-started.html",
  "type": "Appendix",
  "number": "A",
  "title": "Getting Started with Julia",
  "body": " Getting Started with Julia   This appendix shows how to get started with using Julia. The recommended way is first to install julia as described in . Then follow the steps in to install Visual Studio Code, an open-source text editor. Some other methods include using a website Repl.it to run julia in a webpage on a remote server, which the instructions are not up to date. Lastly, there are some older instructions to install and run jupyter which creates a local web server which you can run julia notebooks in any browser.    Downloading and Installing Julia  At the top of the main Julia website , click the green Download button, taking you to the downloads page. At the top of this page, you will get a single line to copy paste into Terminal (MacOS or Linux) or PowerShell in Windows. This will install both julia and a nice tool called juliaup which is a program that can update julia. Note that all of the commands were run on a Mac (with a M1 chip) in August 2024. If you run these commands on a different platform at a different time, your results will vary a bit.  Running the MacOS version results in   Installing Juliaup   (for accessibility)    continuing with the default installation, hit yes and hopefully you see:    Now installing Juliaup  Installing Julia 1.10.5+0.aarch64.apple.darwin14  Configured the default Julia version to be 'release'.  Julia was successfully installed on your system.    although the default version might be different. There may be instructions to ensure that your system path is set up correctly. Follow the details at the end of the installation process before continuing. Each environment may be a bit different and the install script should detect it correctly and give you the right answers.   juliaup , short for julia update is a script that helps you install and update julia. We can check what version of julia is running with juliaup status and after the install as above, we get:    Default Channel Version Update  -----------------------------------------------------------  * release 1.10.5+0.aarch64.apple.darwin14    This shows all of the versions that are installed and the * shows that the release channel (official current version). Let's add one more version to see how things work. Since 1.11 is about to come out, it is in release candidate (rc) stage. We can add this version with    juliaup add rc    and you should see that 1.11 is being downloaded. Once finished, checking the status with juliaup status results in    Default Channel Version Update  ---------------------------------------------------------------  rc 1.11.0-rc3+0.aarch64.apple.darwin14  * release 1.10.5+0.aarch64.apple.darwin14    and this shows that there is now a release candidate channel and the release channel is still default. Note that there is no update. If there was, you would see what version was available. There are many other versions and channels available. For example, you can specify a version. If you enter juliaup add 1.11 and check the status then    Default Channel Version Update  ---------------------------------------------------------------  1.11 1.11.0-rc3+0.aarch64.apple.darwin14  rc 1.11.0-rc3+0.aarch64.apple.darwin14  * release 1.10.5+0.aarch64.apple.darwin14    And noticed that both 1.11 and rc are both using the same version--this is common.  You can open the julia REPL (explain in detail below) by typing julia on the command line of Terminal or PowerShell. You should see something like the following.   Julia running in a terminal window   Julia running in a terminal window    Note that the version that we are running is at the startup of the REPL. Quit this with CTRL-D. You should be returned to the prompt. Let's say that we want to switch to the rc channel. We do this with juliaup default rc . Rerun julia on the command line. You should see:   Julia running in a terminal window   Julia running in a terminal window    Try 2+2 and hit ENTER. You should see 4 and you're off and running. If you played with the Repl.it website, you'll notice that it is much more responsive. Although this is way to run julia, it generally isn't the way most people use it.    Installing Visual Studio Code  A nice environment that is similar to jupyter is Visual Studio Code, often shortened to vscode. This is an open-source text editor\/integrated development environment (IDE) that has capability of handling many different languages. The download and install is quite simple in that you should visit the VScode website , click the Download button and install the standard way for your platform. Opening the app, you should see something that looks like     (for accessibility)    and it wouldn't hurt to go through the Learn the Fundamentals tutorial off the welcome page.  Since VSCode works with files on your local computer, it is fundamental to have a folder that VSCode works from. You should have or create a folder that is a project. If you don't have one currently, use the Finder (MacOS) or Explorer (Windows) to create one inside your Documents folder called My Project . Next, in VSCode, go to File , Add Folder to Workspace... and navigate to the folder you just made. You will be asked if you trust this folder.  Although you can use VSCode to access the REPL or write files written in Julia, it's most powerful and flexible by running a notebook file. To do this there are two ways to start a file:     Open a new document ( File , then New File... ). Then save it somewhere ending with .ipynb for example test.ipynb . You should see a file that looks like   A test.ipynb file.     Another way to start a file is to click on the top left sidebar button that looks like two file icons. Create a new file inside the project by selecting the directory that you want it to go in. (If nothing is selected it will go in the top-level). Hover over the name of the project and click the icon that looks like a file with a +. It will make a new file which you should name like test.ipynb .     Next, in the upper right corner, you should see \"Select Kernel\". In this case, select the Julia 1.11 kernel if you installed that. If not, select one that was installed.  In the cell, enter 2+2 or some simple calculation. If you get 4 below the cell with no errors, everything was installed correctly.  It is a good idea to also install the IJulia package. You can do this within VSCode, by first revealing a terminal with View , the Terminal (also CTRL ` --backtick) will work or CMD-J on the Mac. You should see the bottom of the VSCode window split revealing a terminal. Within this type julia , then the following two lines:    using Pkg  Pkg.add(\"IJulia\")      Running Julia code inside VSCode   MORE HERE.    Running a Julia REPL  The Julia REPL is where you enter single julia statements. A REPL is short for Read-Eval-Print-Loop and is often a interpretative shell where you can enter commands in some language. To get started, click on the REPL part of Atom and hit ENTER. This starts up julia and you should see:   REPL inside of VScode   REPL inside of VScode    Notice that it's ready for you to enter something with the julia> prompt.  We will enter a few commands to get started. All julia commands throughout the book will be written in a \\verb|monospace font| and it is a good idea to type along at the same time.  Enter a=2 at one prompt and b=3 at another prompt. You will see the response of 2 and 3 as well. (Additionally, you may notice that the Workspace tab in the upper right has changed. We will discuss that later.). Now enter a+b in a prompt and you should see the result 5.  Later in this chapter we do a simple plot, but need to load a package first. Type ] at a prompt and the julia prompt will turn into (@1.11) pkg> which is the package manager mode. First, type up to update all packages. You will need to authenticate first. Your default browser will automatically open and you will need to login. After you authenticate, the browser will say that it was successful and you can close that tab. Return to Atom and you should see that julia is updating some packages. This may take a minute or so.  Next, we will install the Plots package. At the (@1.11) pkg> prompt, type add Plots . Julia will need to add a lot of other packages, but you won't need to worry about this. We will use this in the next section. We will also learn much more about packages in .  To exit the package manager mode, enter CONTROL-C. You will leave this mode and return to julia prompt.     using the Repl.it website   To get started immediately with julia, we can use the http:\/\/repl.it website. Navigate to that in a browser and set yourself up with an account to get started. You will answer a number of questions including languages that you are interested in. At the end, you can click the big blue button in the top right corner + new repl to get a playground. Select \\text{julia} for the language. You should get something that looks like:   Screenshot of Repl.it   Screenshot of Repl.it    The idea with the website is that you can have files (for julia files, they end in .jl ) which are listed on the left side. The middle is the current file being edited (and by default this is called main.jl ) and then the REPL which has either output from the run file or by entering commands is on the right side.  Try entered 2+2 in the right side and hitting ENTER. You'll see 4 and this means that everything seems to be working.    Limitations of Repl.it  Although Repl.it is nice when starting out, there's a number of limitations:     Since it is a website, you must have internet access.    Also, since it is a website, there is latency, that is it may appear that commands and actions don't happen right away.    It doesn't appear to use the latest version of julia (or probably any language). When you're starting out, this isn't that important, but you may be trying to find a feature that was newly released that isn't on Repl.it .    Many of the advanced features of julia don't work quite including the parallel processing and GPU features.     In short, if you are just starting in julia or trying it out, it's a good way to start, but I would download your own version of it as soon as you can.     Downloading and running Jupyter   A Jupyter Jupyter stands for Ju lia, Pyt hon and R , three languages that run inside these notebooks, although there are plenty of others. notebook is a way to run julia within a webpage interface and is quite easy, but powerful to use.  It's not trivial to install, but once there are a couple of hurdles, it should be smooth. In short, you need to start with a python version on your machine.    Installing Jupyter on Mac   There are a few things that you'll need to get a Jupyter browser: 1) a python interpreter and some packages and 2) the IJulia package for julia.    Installing Python  Although python is currently available on MacOS, it is an old version. There are a number of ways to get python, but I will use homebrew do to this.     Install Homebrew from \\url{https:\/\/brew.sh}. Open the Terminal and then enter:    \/bin\/bash -c \"$(curl -fsSL https:\/\/raw.githubusercontent.com\/Homebrew\/install\/master\/install.sh)\"      Install python by entering in a terminal:    brew install python    There are a number of related packages needed as well, but after a few minutes you should have python installed.    Install jupyter and jupyter lab:   pip3 install jupyterlab        Installing IJulia   IJulia is a julia package for interaction. It is installed like all other packages and details are in , however you can do  using Pkg  Pkg.add(\"IJulia\")      Running Jupyter  Lastly, to run jupyter , in a terminal, enter    jupyter lab    and that should automatically open your default browser and start Jupyter in the current directory. If all works well, you should see:   Jupyter   jupyter        Using Jupyter  Jupyter looks and acts like a web app. There is a menu bar at the top, a tool bar on the left side, a sidebar on the left part of the page and the main screen (which starts with a launcher).    The kernel   In many ways, julia is a program like any other that you run on your computer, however because of the nature of it parsing statements and then giving output, you have to think about it a bit differently. When you start julia, we often will say that you are starting the kernel, which is a basic state which you can feed variables and statements to julia and get output. There are three different ways that this can occur:    The REPL  If you open julia directly from your computer (either clicking on an icon or using some sort of application launcher), you'll set the REPL as explained above. This is a very simple, but often helpful, way to enter julia code. When this starts up you enter commands like:    a=2  b=3  a+b    This all goes to the julia kernel.     Restarting the Kernel   Julia doesn't have a way of removing variables, functions or modules, whereas often we will need to do so. The best way is to restart the kernel, which basically means to shut down julia and restart. It depends on how this you run julia.    Restarting the Kernel in the julia REPL  This is probably the simplest. If you opened julia by launching the app by double-clicking an icon, just close the window and you stop the program. Note: you lose everything that you have done, which is another reason why I don't use this often. Then restart by reopening julia.  If you started julia from a terminal or PowerShell, quit julia using CTRL-D. Then restart julia with the command julia .    Restarting the Kernel in Jupyter  To restart the kernel in Jupyter, click the Kernel menu, then select Restart Kernel\\ldots . To restart, just rerun a cell in Jupyter. Note: you'll probably need to reload any packages in the notebook if you have any.    Restarting the Kernel in VSCode  To restart the kernel in VSCode click the Restart button at the top of the document. Unfortunately there is not indication that anything happens, but reevaluating a cell should indicate that it has been restarted. Note that the cells are numbers and should restart at 1.    "
},
{
  "id": "fig-juliaup-install",
  "level": "2",
  "url": "ch-getting-started.html#fig-juliaup-install",
  "type": "Figure",
  "number": "A.1",
  "title": "",
  "body": " Installing Juliaup   (for accessibility)   "
},
{
  "id": "fig-repl",
  "level": "2",
  "url": "ch-getting-started.html#fig-repl",
  "type": "Figure",
  "number": "A.2",
  "title": "",
  "body": " Julia running in a terminal window   Julia running in a terminal window   "
},
{
  "id": "fig-repl2",
  "level": "2",
  "url": "ch-getting-started.html#fig-repl2",
  "type": "Figure",
  "number": "A.3",
  "title": "",
  "body": " Julia running in a terminal window   Julia running in a terminal window   "
},
{
  "id": "fig-vscode",
  "level": "2",
  "url": "ch-getting-started.html#fig-vscode",
  "type": "Figure",
  "number": "A.4",
  "title": "",
  "body": "   (for accessibility)   "
},
{
  "id": "fig-repl-startup",
  "level": "2",
  "url": "ch-getting-started.html#fig-repl-startup",
  "type": "Figure",
  "number": "A.5",
  "title": "",
  "body": " REPL inside of VScode   REPL inside of VScode   "
},
{
  "id": "fig-repl-it",
  "level": "2",
  "url": "ch-getting-started.html#fig-repl-it",
  "type": "Figure",
  "number": "A.6",
  "title": "",
  "body": " Screenshot of Repl.it   Screenshot of Repl.it   "
},
{
  "id": "fig-jupyter",
  "level": "2",
  "url": "ch-getting-started.html#fig-jupyter",
  "type": "Figure",
  "number": "A.7",
  "title": "",
  "body": " Jupyter   jupyter   "
},
{
  "id": "ch-packages",
  "level": "1",
  "url": "ch-packages.html",
  "type": "Appendix",
  "number": "B",
  "title": "Managing Packages",
  "body": " Managing Packages   As with many software packages, additional functionality is available in other libraries or packages. If you take a look at https:\/\/juliaobserver.com there are about 2000 packages (as of Fall 2018). Clicking on any of the package names will give additional information about the package including documentation (hopefully).  If you don't have a package installed and try to use it, like:   using Primes   you will get an error that it isn't installed--unless you actually installed it previously. You can add the package by   using Pkg Pkg.add(\"Primes\")   and after fetching the package, rerunning   using Primes   should no longer give an error. Then, for example, try   isprime(17)   which returns \\verb!true! because 17 is a prime number. This is a nondeterministic function that determines if a number is true. The documentation for the Primes package is at \\url{https:\/\/github.com\/JuliaMath\/Primes.jl} and demonstrates 4 commands including isprime and factor which returns all prime factors (and the order).  A few other packages that we have seen or will see:   IJulia -- provides the browser interface to Julia. You are probably already using this.    ForwardDiff -- does Automatic Differentiation (see Chapter 8)    Plots -- A plotting packages (See Chapter 11)    GR -- A backend to the Plots package.    PlotlyJS -- Another nice backend to the Plots package.    DataFrames -- a way to nicely handle datasets generally loaded from external files.    will show how to create our own packages also called a module.    Managing Packages in Julia   Although we can use the Pkg package to handle packages, this section will use the terminal REPL to handle any non-standard packages. Additional documentation on this is given in https:\/\/docs.julialang.org\/en\/latest\/stdlib\/Pkg\/ First, open up a terminal version of julia (generally by opening the application that you downloaded). You will get:    _  _ _ _(_)_ | Documentation: https:\/\/docs.julialang.org  (_) | (_) (_) |  _ _ _| |_ __ _ | Type \"?\" for help, \"]?\" for Pkg help.  | | | | | | |\/ _` | |  | | |_| | | | (_| | | Version 1.4.1 (2020-04-14)  _\/ |\\__'_|_|_|\\__'_| | Official https:\/\/julialang.org\/ release  |__\/ |    or similar and then   julia>   which means we're ready to handle julia commands. If we type {] }, then the prompt turns into:   (v1.4) pkg>   where the 1.4 will be the version of julia that you are running. There are a number of commands that we will cover here:     add    remove (rm)    develop (dev)    status    update (up)    test    build    precompile     and the commands in parentheses are the shortcut.    Adding a package  In the package command line, type add \\emph{package\\_name} to add the package. For example, to add the ForwardDff package:   add ForwardDiff   and it is not installed, you will get something like:   Updating registry at `~\/.julia\/registries\/General` Updating git-repo `https:\/\/github.com\/JuliaRegistries\/General.git` Updating `~\/.julia\/environments\/v1.0\/Project.toml` [f6369f11] + ForwardDiff v0.9.0 Updating `~\/.julia\/environments\/v1.0\/Manifest.toml` [9e28174c] + BinDeps v0.8.10 [bbf7d656] + CommonSubexpressions v0.2.0 [163ba53b] + DiffResults v0.0.3 [b552c78f] + DiffRules v0.0.7 [f6369f11] + ForwardDiff v0.9.0 [77ba4419] + NaNMath v0.3.2 [276daf66] + SpecialFunctions v0.7.0 [90137ffa] + StaticArrays v0.8.3   A few things to note:     You results will vary depending on version numbers avaiable and what subpackages (like \\verb!DiffRules! or \\verb!StaticArrays! are needed for the current version of the package you want to load.    The line after the 2nd Updating line is the package (and version) that you are installing.    All of the lines after the 3rd Updating line is all of the packages that this depends on.    The + sign means that the package is being added.     If you want to add multiple packages at the same time, say packages A, B and C, type add\\ A\\ B\\ C . You can also add particular versions of a package (often for testing or to avoid a bug). For example, if you want version 0.3.0 of ForwardDiff type:   add ForwardDiff@0.3.0   You will then get info on the dependencies on that version.    Package Status  The status command (or st ) will just list all of the main packages installed. For example,   Status `~\/.julia\/environments\/v1.0\/Project.toml` [c52e3926] Atom v0.7.6 [336ed68f] CSV v0.3.1 [a93c6f00] DataFrames v0.13.1 [f6369f11] ForwardDiff v0.9.0 [7073ff75] IJulia v1.12.0 [e5e0dc1b] Juno v0.5.3 [1a8c2f83] Query v0.10.0   and note that these are just the packages added by the add command, not all of the dependencies. If you want all of the dependencies as well, type st\\ -\\\/-manifest and I get a huge list of packages.    Removing a Package  You can remove a package by typing remove or rm then the package name. If I want to remove the ForwardDiff package, then    remove ForwardDiff    we get the following:   Updating `~\/.julia\/environments\/v1.0\/Project.toml` [f6369f11] - ForwardDiff v0.3.0 Updating `~\/.julia\/environments\/v1.0\/Manifest.toml` [49dc2e85] - Calculus v0.4.1 [c5cfe0b6] - DiffBase v0.2.0 [f6369f11] - ForwardDiff v0.3.0 [77ba4419] - NaNMath v0.3.2   Note:     The rm command removes the package from the list of available packages, but doesn't remove them from your harddrive.    If you want to see everything installed, navigate to the \\textasciitilde{ \/.julia\/packages} directory, which is where they are stored.       Updating packages  If you type update or up you will update all of the installed packages (and dependencies). For example:   Updating `~\/.julia\/environments\/v1.0\/Project.toml` [7073ff75] ↑ IJulia v1.11.1 ⇒ v1.12.0 Updating `~\/.julia\/environments\/v1.0\/Manifest.toml` [7073ff75] ↑ IJulia v1.11.1 ⇒ v1.12.0 [b85f4697] ↑ SoftGlobalScope v1.0.5 ⇒ v1.0.7 [5e66a065] ↑ TableShowUtils v0.1.1 ⇒ v0.2.0   and all updates will be with an ↑. If you only want to update a single package, type the name after update .    Building Packages  Generally a package is built after it is installed. Building a package might include running code (or unpacking files) after it is installed. Sometimes if things get wonky, rebuilding is a good thing to do.    build    or if you only want say IJulia built,   build IJulia     Precompiling packages  When a package is used, often it requests to be compiled. For example, when using\\ Primes , then following is shown:   [ Info: Precompiling Primes [27ebfcd6-29c5-5fa9-bf4b-fb8fc14df3ae]   and basically some code is compiled beforehand, generally to speed up code. You can precompile all code with   precompile   and it may take a while, but you won't have to wait, when you load the package with the using command.    Testing a Packages  To test a packge, say the ForwardDiff package, then    test ForwardDiff    It list all of the dependencies first, and then runs a number of tests (and we will show how to write tests soon) and timing information. After a while, it finishes sucessfully.    "
},
{
  "id": "ch-num-rep",
  "level": "1",
  "url": "ch-num-rep.html",
  "type": "Appendix",
  "number": "C",
  "title": "Binary Represenation of Numbers",
  "body": " Binary Represenation of Numbers   In , numeric data types were introduced. Some details of integers and floating points were given, however, some of the gorier details were left to here.    Integer Representation   We discussed the binary representation of non-negative numbers in . Negative numbers is more difficult. This method of data storage in called 2's complement . A nice description of this is Ryan's Tutorial on negative binary numbers .  Although seems a bit strange, let's first discuss the conversion of binary to integer. Let the 8-bit binary number be written as , where the first bit is the sign and the other 7-bit compose the number then representation of in decimal is     As an example, note that if , then this is identical to the integer representation of positive integer. Again, 00010010 would be     Let's look at an example with a negative number. Let x=11010111 , then in decimal:       Converting from decimal to binary  Again, like above, let's concentrate only on 8-bit numbers. That is, we will take a decimal number x in the range and return an array of length 8 of bits (you can even think of booleans) or we need to find from .  First, let's examine only non-negative numbers, so . And let's use the number . We'll work from the larger digits to the smaller ones, so to .     Let x6 = 47     Let x5 = mod(x6,64) = 47 and a6 = div(x6,64) = 0 .    Let x4 = mod(x5,32) = 15 and a5 = div(x5,32) = 1 .    Let x3 = mod(x4,16) = 15 and a4 = div(x4,16) = 0 .    Let x2 = mod(x3,8) = 7 and a3 = div(x3,8) = 1 .    Let x1 = mod(x2,4) = 3 and a2 = div(x2,4) = 1 .    Let x0 = mod(x1,2) = 1 and a1 = div(x1,2) = 1 .     This shows that the result is 00101111. Again, bitstring(Int8(47)) returns \"00101111\" the same result.  A function that does this is as follows.   function dec2bin(n::Int) -128 <= n <=127 || throw(ArgumentError(\"The value of n must be between -128 and 127\")) bdigits=zeros(Bool,8) ## this function calclates the digit of the decimal number k that goes in slot digit function calcDigit(k::Int,digit::Int) if digit==0 bdigits[1] = k else bdigits[digit+1] = div(k,2^digit) calcDigit(mod(k,2^digit),digit-1) end end calcDigit(n,6) bdigits end   Note that first this uses recursion as explained in . In addition, the error checking is explained in . This function returns a boolean array (ones and zeros). For example:    dec2bin(47)    returns [1 1 1 1 0 1 0 0] . And note that since the array returns the digits in the order from small to large, this result is the same as we showed by hand above and using the function bitstring .    Representing Negative Integers  To find the representation of a negative integer, we return to and note that . A little algebra results in     and with , we define the left side as and now the right side is the same representation of a positive number and if , then .  Let's check out an example. Consider , then . Using the algorithm to find the binary representation of 61 or dec2bin(61) which returns [1 0 1 1 1 1 0 0] recalling that the order is reversed from the function above.  Since we are looking for the decimal representation of -67 , not 61 , the sign bit is 1, so we have 10111101 and checking with the built-in function bitstring(Int8(-67)) or \"10111101\" .  This method of storage of negative integers is called 2's complement .   Write out by hand the binary representation of                 Including negative Integers  If we extend the function above to include negative numbers, the following:   function dec2bin(n::Int) bdigits=zeros(Bool,8) ## this function calclates the digit of the decimal number k that goes in slot digit function calcDigit(k::Int,digit::Int) if digit==0 bdigits[1] = k else bdigits[digit+1] = div(k,2^digit) calcDigit(mod(k,2^digit),digit-1) end end if n>=0 calcDigit(n,6) else calcDigit(128+n,6) bdigits[8]=1 end bdigits end   Calling dec2bin(-57) results in [1 1 1 0 0 0 0 0] and this is the same as above. The output is a little tricky so we have another function that will take this boolean array to a string.    arr2str(arr::Array{Bool,1}) = reduce((x, y)->string(x,y ? \"1\" : \"0\"),reverse(arr),init=\"\")    where the reduce function in is used and the function reverse takes an array and reverses the elements. This is must more convenient with arr2str(dec2bin(-57))   returns \"00000111\" , the same as above and the same as bitstring for 8-bit integers.   Use the functions dec2bin and arr2str to find the binary represenation of                 A binary to decimal function  It's also nice to have a function that reverses this.   ## this function takes a 0-1 array (boolean array) and changes it to a decimal. # the first element is the 2^0 digits, the 7th digit is the 2^6 digit and the 8th digit is the sign digit # this uses the 2's complement representation # function bin2dec(arr::Array{Bool,1}) sum=0 for i=1:7 sum += arr[i]*2^(i-1) end sum - arr[8]*128 end   To use this, we need to start with a binary array, so let's start with    arr = map(x-> x==1 ? true : false, [1,1,1,0,0,0,1,1])    and then we can use the bin2dec function as    bin2dec(arr)    returns -57 .  And the following is a function that will take a binary string and turn it to an array    str2arr(str::String) = reverse(map(x-> x==\"1\" ? true : false, split(str,\"\")))    If we use this in conjunction with bin2dec , we have some convenient functions. That is    bin2dec(str2arr(\"11000111\"))    results in -57 .     Operations on Binary Integers   Adding two positive binary integers is much like adding decimal integers. An example of could be:     where the standard algorithm is used  The result of this in decimal is bin2dec(str2arr(\"01001001\")) or 73 .  Note that if we try to add 01001100 and 01100010 we get 10101110 (try it!) and if we use the conversion to get back to decimal results in bin2dec(str2arr(\"10101110\")) or -82 , which clearly is not the sum of two positive numbers. The reason this occurred is that the sum of the two numbers does not fit in an 8-bit integer, whose max value is 127. We can tell this directly from the binary result in that the first digit is a 1 (due to the sum of the two one's in the second position). Recall that this first digit is a sign bit. This is an overflow error.    Unary minus  The unary minus operator negates a number. To see how to do this in binary, let's look at what a bit flip looks like with a few examples. Let's take the decimal number 54 or 00110110 and flip all of the bits (changes 0s to 1s and 1s to 0s) to get 11001001 and using bin2dec(str2arr(\"11001001\")) which returns -55 . If we use 10101010 which is , the bit flips are 01010101 which is . Note that the sum of a binary number and it's bit flips is 11111111 which is .  To determine the negation of a binary number, we will 1) flip the bits and 2) add one. So for example, 00101101 or 45 . The bit flip of this is 11010010 and then add one to get 11010011 , which is -45 .   Show that the unary minus of 0 in binary is still 0. (Note: this is one of the very nice features of using 2's complement for storing integers.)   There is one 8-bit integer than does not have negative (that is an 8-bit integer). What is it?      Subtraction of binary integers  There are a couple of ways to think about subtraction. One can use the column algorithm like is standard for subtraction of decimal numbers and adapt to binary integers. However an easier way is to thing of as and use the negative from the previous section. For example, look at .     The two integers in binary are \"01001110\" and \"01010101\" .    The negation of 85 is 10101010 + 00000001 or 10101011     The sum of 01001110 and 10101011 is \"00111001\" .    converting back to decimal results in .       Multiplication of Binary Integers     which shows that 10   6 equals 60 .   Discuss multiplication of negative integers...    Put all of these functions in a module as in Chapter \\ref{ch:modules}. This will include   Creating a type called Integer8 which is an alias for a binary array of length 8.   Create a Base.show method for Integer8 to display as a string. See Chapter \\ref{ch:modules} to do this and use the function in this chapter   Create a function parseBin , which takes in a string of length 8, and returns a value of type Integer8 . Use the str2arr function from this chapter.   Create a unary minus, plus and minus on the type Integer8 types. Use the example of Polynomials in section \\ref{sect:parametric-types} for examples on how to do this.   Create a test suite to thoroughly test all of the functions that you write.    Scientific Notation  Recall that any number written in decimal form with only a finite number of digits can be written in scientific notation that is in the form:   where and is an integer. For example can be written as , so and .  In this form the number is often called the \\textbf{significand} or \\textbf{mantissa} and the number is \\textbf{exponent}. This example has the base 10, however other bases are common (generally base 2).  One major advantage to using numbers in this form is the simple multiplication and division. Consider multiplying and . Using properties of exponentials we get     and typically we would like to put this back into scientific notation by shifting the exponent so .  Division can be done in a similar manner and perhaps surprisingly, addition and subtraction are more difficult due to the fact that the exponents of the two numbers need to be equal before adding and subtracting.    Floating Point Numbers of a given size  The reason for using floating point numbers in calculations is twofold. First, there is a finite size of storage for a number and secondly, routines for performing operations on floating-point numbers are fast and usually encoded on a computer chip.  Consider a floating point of a given size, say 64 bits generally called a double precision floating point number . The first bit is generally used for the sign, the next 11 are the exponent and the final 52 bits store the mantissa. A floating point number has two limitations and that is the precision (how many digits that can be stored) and the magnitude (the largest number). Double precision numbers are store in binary and converted to decimal with the form:     where is the sign is the exponent and stores the mantissa. For example, consider the following number:     where spaces separate out , and . Converting to decimal:     The mantissa is calculated in the following way     and thus the floating point number is:   The double precision number system falls into a class of number systems that we can commonly call floating-point number systems.   "
},
{
  "id": "ch-num-rep-3-4-8",
  "level": "2",
  "url": "ch-num-rep.html#ch-num-rep-3-4-8",
  "type": "Check Your Understanding",
  "number": "C.1",
  "title": "",
  "body": " Write out by hand the binary representation of              "
},
{
  "id": "ch-num-rep-3-5-8",
  "level": "2",
  "url": "ch-num-rep.html#ch-num-rep-3-5-8",
  "type": "Check Your Understanding",
  "number": "C.2",
  "title": "",
  "body": " Use the functions dec2bin and arr2str to find the binary represenation of              "
},
{
  "id": "ch-num-rep-4-3-4",
  "level": "2",
  "url": "ch-num-rep.html#ch-num-rep-4-3-4",
  "type": "Check Your Understanding",
  "number": "C.3",
  "title": "",
  "body": " Show that the unary minus of 0 in binary is still 0. (Note: this is one of the very nice features of using 2's complement for storing integers.)   There is one 8-bit integer than does not have negative (that is an 8-bit integer). What is it?  "
},
{
  "id": "ch-num-rep-6-4",
  "level": "2",
  "url": "ch-num-rep.html#ch-num-rep-6-4",
  "type": "Paragraph (with a defined term)",
  "number": "",
  "title": "",
  "body": "Discuss multiplication of negative integers... "
},
{
  "id": "ch-num-rep-6-5",
  "level": "2",
  "url": "ch-num-rep.html#ch-num-rep-6-5",
  "type": "Check Your Understanding",
  "number": "C.4",
  "title": "",
  "body": " Put all of these functions in a module as in Chapter \\ref{ch:modules}. This will include   Creating a type called Integer8 which is an alias for a binary array of length 8.   Create a Base.show method for Integer8 to display as a string. See Chapter \\ref{ch:modules} to do this and use the function in this chapter   Create a function parseBin , which takes in a string of length 8, and returns a value of type Integer8 . Use the str2arr function from this chapter.   Create a unary minus, plus and minus on the type Integer8 types. Use the example of Polynomials in section \\ref{sect:parametric-types} for examples on how to do this.   Create a test suite to thoroughly test all of the functions that you write.  "
},
{
  "id": "backmatter-5",
  "level": "1",
  "url": "backmatter-5.html",
  "type": "Colophon",
  "number": "",
  "title": "Colophon",
  "body": " This book was authored in PreTeXt .  "
}
]

var ptx_lunr_idx = lunr(function () {
  this.ref('id')
  this.field('title')
  this.field('body')
  this.metadataWhitelist = ['position']

  ptx_lunr_docs.forEach(function (doc) {
    this.add(doc)
  }, this)
})
